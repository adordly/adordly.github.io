<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>分布式缓存与分布式锁 | 咳咳</title><meta name="keywords" content="分布式"><meta name="author" content="咳咳"><meta name="copyright" content="咳咳"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="分布式缓存与分布式锁 在大型的业务中，频繁的查询数据库是非常消耗性能的，那么，我们会将一部分读多写少的数据放入缓存中，以加速访问。  哪些数据适合放入缓存中呢？  即时性和数据一致性要求不高的，也就是不需要修改后马上得到修改后的值，只需要满足最终一致性的数据(弱一致性）。 访问量大而又不频繁修改的数据，也就是读多写少的数据。  传统本地缓存 我们需要将数据缓存，查询数据时，先查缓存，缓存没有，再查"><meta property="og:type" content="article"><meta property="og:title" content="分布式缓存与分布式锁"><meta property="og:url" content="https://jhuarui.work/2022/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/index.html"><meta property="og:site_name" content="咳咳"><meta property="og:description" content="分布式缓存与分布式锁 在大型的业务中，频繁的查询数据库是非常消耗性能的，那么，我们会将一部分读多写少的数据放入缓存中，以加速访问。  哪些数据适合放入缓存中呢？  即时性和数据一致性要求不高的，也就是不需要修改后马上得到修改后的值，只需要满足最终一致性的数据(弱一致性）。 访问量大而又不频繁修改的数据，也就是读多写少的数据。  传统本地缓存 我们需要将数据缓存，查询数据时，先查缓存，缓存没有，再查"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jhuarui.work/img/fbs.jpg"><meta property="article:published_time" content="2022-05-16T07:23:47.000Z"><meta property="article:modified_time" content="2022-07-06T09:09:53.619Z"><meta property="article:author" content="咳咳"><meta property="article:tag" content="分布式"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://jhuarui.work/img/fbs.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://jhuarui.work/2022/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"分布式缓存与分布式锁",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-07-06 17:09:53"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/social_img.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/fbs.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">咳咳</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式缓存与分布式锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-16T07:23:47.000Z" title="发表于 2022-05-16 15:23:47">2022-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-06T09:09:53.619Z" title="更新于 2022-07-06 17:09:53">2022-07-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="分布式缓存与分布式锁"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="分布式缓存与分布式锁"><a href="#分布式缓存与分布式锁" class="headerlink" title="分布式缓存与分布式锁"></a>分布式缓存与分布式锁</h1><blockquote><p>在大型的业务中，频繁的查询数据库是非常<strong>消耗性能</strong>的，那么，我们会将一部分读多写少的数据放入<strong>缓存</strong>中，以加速访问。</p></blockquote><p><em><strong>哪些数据适合放入缓存中呢？</strong></em></p><ul><li><strong>即时性</strong>和<strong>数据一致性</strong>要求不高的，也就是不需要修改后马上得到修改后的值，只需要满足<strong>最终一致性</strong>的数据(弱一致性）。</li><li><strong>访问量大</strong>而又不频繁修改的数据，也就是<strong>读多写少</strong>的数据。</li></ul><h2 id="传统本地缓存"><a href="#传统本地缓存" class="headerlink" title="传统本地缓存"></a>传统本地缓存</h2><blockquote><p>我们需要将<strong>数据缓存</strong>，查询数据时，先查缓存，缓存没有，再查数据库，之后将查到的数据重新放入缓存，下次就直接可以从缓存中拿了.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = cache.load(dataId);  <span class="comment">//先去缓存中找</span></span><br><span class="line"><span class="keyword">if</span>(data == <span class="literal">null</span>) &#123;</span><br><span class="line">    data = db.load(dataId); <span class="comment">//缓存中没有，就查数据库</span></span><br><span class="line">    cache.put(data);  <span class="comment">//查到后放入数据库中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：实际开发中，放入缓存中的数据都应该设置有过期时间，防止因为不良因素导致的死锁，缓存雪崩等等问题。</strong></p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><blockquote><p><strong><code>Redis</code><strong>作为一个良好的</strong>缓存中间件</strong>，在实际开发中，经常作为缓存的组件来使用。</p></blockquote><h3 id="集成SpringBoot"><a href="#集成SpringBoot" class="headerlink" title="集成SpringBoot"></a>集成SpringBoot</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：通常使用<code>Redis</code>默认是使用<code>Lettuce</code>来操作客户端，它是使用<code>Netty</code>来进行网络通信的，但是<code>Lettuse</code>存在一些bug可能导致<code>Netty</code>堆外溢出，虽然可以通过自行增大服务堆外内存来降低bug风险，但对性能要求还是有点高，咱们就可以使用<code>Jedis</code>来操作客户端，只是换了一个操作引擎，<code>redis</code>的基本用法是没有变的。</strong></p><p>redis的基本用法我就不过多说了，很简单，可以参照<strong>官方文档</strong>或者其他博客进行学习就行。</p><h2 id="基于Redis实现的分布式缓存"><a href="#基于Redis实现的分布式缓存" class="headerlink" title="基于Redis实现的分布式缓存"></a>基于Redis实现的分布式缓存</h2><blockquote><p>之前咱们看了看<strong>传统的本地缓存</strong>，只在<strong>单服务</strong>系统中适用，在分布式系统中，每个服务都是独立的，A服务的缓存数据B服务是获取不到的，等于说一个服务需要自己开辟一个自己的局部缓存，也就失去了缓存的意义，需求是所有服务共用一个缓存，才能保证后序读取数据的<strong>统一和一致性。</strong></p><p>所以我们要让缓存独立成一个系统（类似于独立出一个服务），其他服务就可以调用同一个缓存数据来操作同一个缓存数据了。</p></blockquote><h3 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">xxx</span>  <span class="string">//配置服务的主机ip</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">xxx</span> <span class="string">//配置redis服务所在端口</span></span><br></pre></td></tr></table></figure><p><strong>注意：redis有自己的主机ip和端口，相当于一个服务器。</strong></p><p>不管是分布式还是本地缓存，<strong>思路</strong>是没有变的：</p><p><strong>查缓存–&gt;缓存没有就查数据库，之后将数据库存入缓存;如果缓存有，直接拿缓存中的数据</strong></p><p>参考Redis中文文档中的分布式样例：</p><p>咱们来看看代码怎么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCacheData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(dataId); <span class="comment">//查询缓存</span></span><br><span class="line">	<span class="keyword">if</span>(s == <span class="literal">null</span>) &#123;</span><br><span class="line">        s = 查询数据库;  <span class="comment">//缓存没有就查询数据库</span></span><br><span class="line">        redisTemplate.opsForValue().set(dataId, s); <span class="comment">//存入缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote><p><strong>缓存穿透</strong>是指<strong>查询一个一定不存在的数据</strong>，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次 请求都要到存储层去查询，失去了缓存的意义。 <strong>在流量大时</strong>，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。</p></blockquote><ul><li><strong>解决：</strong>缓存空结果、并且设置短的过期时间。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。</p></blockquote><ul><li><strong>解决</strong>：<strong>原有的失效时间基础上增加一个随机值</strong>，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote><p>对于一些设置了过期时间的<strong>key</strong>，如果这些<strong>key</strong>可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：如果这个<strong>key</strong>在大量请求同时进来前正好失效，那么所有对这个 <strong>key</strong> 的数据查询都落到<strong>db</strong>，我们称为<strong>缓存击穿</strong>。</p></blockquote><ul><li><strong>解决</strong>：加锁</li></ul><h2 id="解决缓存击穿"><a href="#解决缓存击穿" class="headerlink" title="解决缓存击穿"></a>解决缓存击穿</h2><blockquote><p>缓存击穿解决的最好办法就是<strong>加锁</strong>，当很多并发请求同一个接口数据时，因为key失效，我们只需要一个线程来查询数据库后将该数据放入缓存，查询期间其他线程阻塞等待，当第一个线程查询完后，后面的线程可以判断缓存中是否存在，存在就直接去缓存中拿数据，而避免了并发请求数据库导致的数据库崩溃，”<strong>一人查库，其他等着查缓存</strong>“。这就需要一把锁来实现。</p></blockquote><h3 id="本地锁"><a href="#本地锁" class="headerlink" title="本地锁"></a>本地锁</h3><blockquote><p><strong>本地锁</strong>，说白了就是在本地服务下才有效的锁，一个服务代表着一个进程，本地锁能够锁住当下进程下的线程。</p></blockquote><p>为了要在一个时刻只有一个线程能执行业务程序，我们采用同步锁**<code>synchronized</code>**实现。</p><p>编写一个测试类看看,<strong>查询缓存的代码和之前的一模一样，就是加了个锁解决了并发而已</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testLocalLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">//加锁，this代表当前应用，也就是当前服务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(dataId); <span class="comment">//查询缓存</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = 查询数据库;  <span class="comment">//缓存没有就查询数据库</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">//模拟查询数据库花的时间</span></span><br><span class="line">            redisTemplate.opsForValue().set(dataId, s); <span class="comment">//存入缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，第一个线程拿到锁，其他的线程只能等到，第一个线程执行完成后，缓存中以及有数据了，等到第二个线程再来，判断缓存中有数据，就直接去缓存中取啦！！</p><p><em><strong>同样，跟之前本地缓存一样，本地锁只解决了单应用缓存击穿问题，在分布式系统中咋办呢？</strong></em></p><p>那就需要使用分布式锁来解决了,说到分布式锁，就还是要用到**<code>Redis</code>**来实现了。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><blockquote><p>可以通过Redis的简单Api实现一个简易的<strong>分布式锁</strong>，单也就是简单的<strong>同步锁</strong>而已。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catalog2Vo&gt;&gt; <span class="title function_">getCatalogJsonFromDBWithRedisLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.占分布式锁，去redis占坑</span></span><br><span class="line">    <span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">    <span class="comment">// 2.设置过期时间,防止死锁,必须和加锁是同步的,满足原子性</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid,<span class="number">50</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="comment">//占坑成功,执行查询业务</span></span><br><span class="line">        Map&lt;String, List&lt;Catalog2Vo&gt;&gt; dataFromDB;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dataFromDB = getDataFromDB(); <span class="comment">//调用方法获取数据库数据</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//脚本原子解锁 --&gt;一段脚本要么全成功要么失败，满足原子性</span></span><br><span class="line">            String script= <span class="string">&quot;if redis.call(\&quot;get\&quot;,KEYS[1]) == ARGV[1] then\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;    return redis.call(\&quot;del\&quot;,KEYS[1])\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;    return 0\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">lock1</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;(script, Long.class), Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁(但是，执行业务过程中，可能锁过期，另一个线程占锁，最终删除的就是被人的锁)，解错锁的问题 ---&gt;给锁设置唯一的UUID标识</span></span><br><span class="line"> <span class="comment">//String s = redisTemplate.opsForValue().get(&quot;lock&quot;);</span></span><br><span class="line">        <span class="comment">//if(s.equals(uuid)) &#123;</span></span><br><span class="line">        <span class="comment">//redisTemplate.delete(&quot;lock&quot;);</span></span><br><span class="line">     <span class="comment">//&#125; //这样又会有一个问题，因为不满足查看锁uuid和删除锁的原子性，查看s返回的过程中可能锁过期，最后还是删除的新占锁的					锁。----&gt;满足查看和删除的原子性，使用LUA脚本</span></span><br><span class="line">        <span class="keyword">return</span> dataFromDB;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取分布式锁失败...等待重试&quot;</span>);</span><br><span class="line">        <span class="comment">//加锁失败 ...重试,自旋</span></span><br><span class="line">        <span class="comment">//休眠100ms重试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonFromDBWithRedisLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，**<code>Redis</code><strong>的分布式锁实现有点笨重，需要循环自旋判断是否能得到锁，这样就很不够智能，官方文档提供了</strong><code>Redis</code><strong>分布式锁的java实现库</strong><code>Redisson</code>**,有中文文档，也比较友好:<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/1.-%E6%A6%82%E8%BF%B0"><strong>Redisson</strong></a></p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><blockquote><p><strong><code>Redisson</code><strong>是一个在Redis的基础上实现的</strong>Java驻内存数据网格</strong>（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(<code>BitSet</code>, <code>Set</code>, <code>Multimap</code>, <code>SortedSet</code>, <code>Map</code>, <code>List</code>, <code>Queue</code>, <code>BlockingQueue</code>, <code>Deque</code>, <code>BlockingDeque</code>, <code>Semaphore</code>, <code>Lock</code>, <code>AtomicLong</code>, <code>CountDownLatch</code>, <code>Publish / Subscribe</code>, <code>Bloom filter</code>, <code>Remote service</code>, <code>Spring cache</code>, <code>Executor service</code>, <code>Live Object service</code>, <code>Scheduler service</code>) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对**<code>Redis</code>**的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></blockquote><p>**<code>Redisson</code><strong>的核心组件就是</strong><code>RedissonClient</code><strong>，咱们需要自己配置一个</strong><code>RedissonClient</code>**来操作我们的Redis实现分布式锁。</p><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedissonConfig</span> &#123;</span><br><span class="line">    <span class="comment">//所有对Redisson的使用都是通过RedissonClient对象</span></span><br><span class="line">    <span class="meta">@Bean(destroyMethod=&quot;shutdown&quot;)</span></span><br><span class="line">    RedissonClient <span class="title function_">redisson</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://redis的ip:端口号&quot;</span>);</span><br><span class="line">        <span class="comment">//创建出RedissonClient实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="comment">//配置到ioc容器中</span></span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配好了，咱们就可以通过自动注入的方式使用了。</p><h4 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h4><p><strong>注意：最好的是，<code>Redisson</code>中的<code>RLock</code>锁类都继承了JUC中的<code>Lock</code>接口，也就是说，了解JUC，Redisson也就非常简单了，调用的API都一样。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RLock</span> <span class="keyword">extends</span> <span class="title class_">Lock</span>, RLockAsync &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">(<span class="type">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> var1, <span class="type">long</span> var3, TimeUnit var5)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> var1, TimeUnit var3)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">forceUnlock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isHeldByThread</span><span class="params">(<span class="type">long</span> var1)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isHeldByCurrentThread</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">remainTimeToLive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><blockquote><p>Redisson提供了很多锁的API，这里就测试一些比较常用的。</p></blockquote><h5 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h5><p>编写一个测试接口一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedissonClient redisson;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取一把锁，只要锁名字一样， 就是同一把锁</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;my-lock&quot;</span>);</span><br><span class="line">        <span class="comment">//2.加锁</span></span><br><span class="line">        <span class="comment">// 1)锁的自动续期，  看门狗：如果业务超长，会在运行期间自动给锁续上新的30s，不用担心业务时间长锁被自动删除</span></span><br><span class="line">        <span class="comment">// 2)加锁的业务只要运行完成，就不会给当前锁续期，即使不手动续期，锁默认在30s以后自动删除</span></span><br><span class="line">        <span class="comment">//lock.lock(); //阻塞式等待， 默认锁30s过期时间</span></span><br><span class="line">        lock.lock(<span class="number">10</span>, TimeUnit.SECONDS); <span class="comment">//10秒自动解锁,自动解锁时间一定要大于业务的执行时间</span></span><br><span class="line">        <span class="comment">//问题：在锁时间到了后不会自动续期</span></span><br><span class="line">        <span class="comment">// 如果我们传递了锁的超时时间，就执行脚本，发送给redis执行，进行占锁，默认超市就是我们指定的时间</span></span><br><span class="line">        <span class="comment">// 如果我们未指定锁的超时时间，就使用看门狗的30*1000的超时时间</span></span><br><span class="line">        <span class="comment">//    只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间】，新的过期时间还是30*1000</span></span><br><span class="line">        <span class="comment">//    三分之一看门狗时间(10*1000)自动续一次期，续到满时间</span></span><br><span class="line">        <span class="comment">//最佳实战</span></span><br><span class="line">        <span class="comment">//还是推荐使用自定义过期时间的lock，省掉续期操作, 手动解锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加锁成功，执行业务...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">            Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3.解锁  假设解锁代码因为异常没运行，redisson会不会出现死锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;释放锁...&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实说白了就是: <strong>获取锁（锁名一样，就是同一个锁）—&gt;加锁—-&gt;（执行业务…）—&gt;解锁。</strong></p><p>中间的业务代码就会被拿锁的线程占有，只有释放锁后，另一个线程抢到锁，才能执行业务逻辑，执行业务就是被锁住的代码块。</p><p>上面的Redis锁都设置有<strong>过期时间</strong>，这也是解决死锁的关键，就算程序崩溃掉，缓存的锁也会在一定时间后自动删除，其他线程也会得到锁，但Redisson中有一个更智能的机制：<strong>看门狗</strong>，不光能自动为锁设置过期时间（默认30s），如果程序执行到30s的<strong>1&#x2F;3</strong>时间，也就是10s还没有执行完，会<strong>自动为锁蓄满时间到30s</strong>，程序运行完，也会在一定事件后锁释放消失。但在实际开发中，还是推荐使用<strong>自定义过期时间</strong>的lock，<strong>省掉续期操作</strong>, <strong>手动解锁</strong>。</p><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><blockquote><p><strong>读写锁</strong>，就是写数据加写锁，对应被<strong>读锁</strong>锁住的程序就需要等待相应的<strong>写锁</strong>程序释放锁后，才能执行到读锁中的程序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/write&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">writeValue</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//获取读写锁，名字相同锁相同</span></span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;rw-lock&quot;</span>);</span><br><span class="line">    <span class="comment">//获取读写锁中的写锁</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 改数据，加写锁</span></span><br><span class="line">        <span class="comment">//2. 读数据，加读锁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;写锁加锁成功...&quot;</span>);</span><br><span class="line">        s = UUID.randomUUID().toString();</span><br><span class="line">        Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;writeValue&quot;</span>, s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/read&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取相同的读写锁</span></span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;rw-lock&quot;</span>);</span><br><span class="line">    <span class="comment">//加读锁</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读锁加锁成功&quot;</span>);</span><br><span class="line">        s = redisTemplate.opsForValue().get(<span class="string">&quot;writeValue&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>读 + 读</strong>； 相当于无锁，同时并行读取。</li><li><strong>写 + 读</strong>： 等待写锁释放。</li><li><strong>写 + 写</strong>： 阻塞。</li><li><strong>读 + 写</strong>： 有读锁，写需要等待。</li></ul><p><strong>注意：</strong></p><ul><li><strong>保证一定能读到最新数据,修改期间，写锁是一个排他锁，读锁是一个共享锁</strong>。</li><li><strong>只要有写的存在，都必须等待</strong>。</li><li><strong>写没释放，读就必须等待</strong>。</li></ul><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><blockquote><p>信号量，可以理解成<strong>车位</strong>，可以设置<strong>车位的位数</strong>，当车位被占满后，就会阻塞等待，等待车位释放车位后，相应的线程才能得到车位运行程序。</p><p>通常用来解决<strong>限流</strong>问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="meta">@GetMapping(&quot;/park&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">park</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//在redis中的key为&quot;park&quot;的value设置为5：相当于限流为5，就是最多5个车位。</span></span><br><span class="line">       <span class="type">RSemaphore</span> <span class="variable">park</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">       park.acquire(); <span class="comment">//获得一个信号获取一个值，占一个车位，阻塞式等待</span></span><br><span class="line">       <span class="comment">//boolean b = park.tryAcquire(); //尝试获取，不会阻塞，获取不到就返回false</span></span><br><span class="line">       <span class="keyword">if</span>(b) &#123;</span><br><span class="line">           <span class="comment">//业务代码</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;流量太大...请等待！&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/go&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">RSemaphore</span> <span class="variable">park</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">       park.release();  <span class="comment">//释放一个车位</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h5><blockquote><p><strong>闭锁</strong>，相当于放学关门，必须等几个班全部走光了才能关门，就是锁必须要等对应数量的线程全部跑完后才能释放。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/lockDoor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">lockDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">door</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;door&quot;</span>);</span><br><span class="line">    <span class="comment">//设置闭锁数为5</span></span><br><span class="line">    door.trySetCount(<span class="number">5</span>);</span><br><span class="line">    door.await();  <span class="comment">//等待闭锁都完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;放假了..&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/gogogo/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">gogogo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">door</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;door&quot;</span>);</span><br><span class="line">    door.countDown(); <span class="comment">//计数减去1</span></span><br><span class="line">    <span class="keyword">return</span> id+<span class="string">&quot;班的人都走了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决缓存一致性"><a href="#解决缓存一致性" class="headerlink" title="解决缓存一致性"></a>解决缓存一致性</h4><blockquote><p>当数据库中的<strong>数据库</strong>更改时，如何保持<strong>缓存中的数据</strong>和<strong>数据库</strong>的数据一致呢？</p></blockquote><h5 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h5><blockquote><p>可以采用更新<strong>数据库</strong>后即时更新<strong>缓存</strong>的方法来实现一致性。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205170041548.png" alt="image-20220517004104415"></p><p><strong>注意：可见，双写模式，如果写缓存时网络很慢，最终到达缓存更改会把别人新写的缓存数据覆盖掉导致读到脏数据，这是一个问题哈。</strong></p><h5 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h5><blockquote><p><strong>失效</strong>，就是在更新数据库数据后删除缓存对应的数据，下次请求发现没有缓存会自动查数据库并再次缓存，也满足了一致性，不过可能就是<strong>最终一致性</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205170045232.png" alt="image-20220517004526143"></p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><h6 id="分布式读写锁"><a href="#分布式读写锁" class="headerlink" title="分布式读写锁"></a>分布式读写锁</h6><p>可以采用读写锁，操作<strong>数据库和缓存</strong>加锁，就能解决<strong>脏读</strong>的问题。</p><h6 id="cananl中间件"><a href="#cananl中间件" class="headerlink" title="cananl中间件"></a>cananl中间件</h6><blockquote><p><strong><code>Cananl</code><strong>是一个</strong>中间件</strong>，可以订阅数据库的<strong>更改日志</strong>，实时发现数据库的操作并<strong>更新</strong>缓存中的相应数据。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205170127639.png" alt="image-20220517012729547"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>分布式业务中，分布式缓存和锁用的很多，在以后的业务开发中，多考虑一下业务场景，判断这个业务场景到底适不适合使用分布式锁和分布式缓存。更有利于我们设计出一个严谨，缜密的系统。</strong></p></blockquote><p><strong>附</strong>：这篇博客老早之前就写了，一直搞忘上传了。。后面SpringCache内容之前学了搞忘记录了，之后啥时候勤快了再补起来emmm。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">咳咳</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jhuarui.work/2022/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">https://jhuarui.work/2022/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归咳咳所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div><div class="post_share"><div class="social-share" data-image="/img/fbs.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/26/RabbitMQ/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/RabbitMQ/RabbitMQ.jpeg" onerror='onerror=null,src="/img/404.jpeg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/15/%E5%9F%BA%E4%BA%8ESpringSecurity%E7%9A%84%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/springboot/security.jpeg" onerror='onerror=null,src="/img/404.jpeg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基于SpringSecurity的认证授权</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/social_img.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">咳咳</div><div class="author-info__description">没有选择会是唯一的路</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://adordly.github.io/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一名拖更的懒博主</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">分布式缓存与分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">传统本地缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis"><span class="toc-number">1.2.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90SpringBoot"><span class="toc-number">1.2.1.</span> <span class="toc-text">集成SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">导入依赖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.</span> <span class="toc-text">基于Redis实现的分布式缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AERedis"><span class="toc-number">1.3.1.</span> <span class="toc-text">配置Redis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">缓存失效问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.4.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.4.3.</span> <span class="toc-text">缓存击穿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.5.</span> <span class="toc-text">解决缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%94%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">本地锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson"><span class="toc-number">1.5.3.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">配置类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RLock"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">RLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">1.5.3.3.1.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.5.3.3.2.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.5.3.3.3.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E9%94%81"><span class="toc-number">1.5.3.3.4.</span> <span class="toc-text">闭锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">解决缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%86%99%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.3.4.1.</span> <span class="toc-text">双写模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B1%E6%95%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.3.4.2.</span> <span class="toc-text">失效模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">1.5.3.4.3.</span> <span class="toc-text">解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.5.3.4.3.1.</span> <span class="toc-text">分布式读写锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cananl%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.5.3.4.3.2.</span> <span class="toc-text">cananl中间件</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/26/RabbitMQ/" title="RabbitMQ"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/RabbitMQ/RabbitMQ.jpeg" onerror='this.onerror=null,this.src="/img/404.jpeg"' alt="RabbitMQ"></a><div class="content"><a class="title" href="/2022/06/26/RabbitMQ/" title="RabbitMQ">RabbitMQ</a><time datetime="2022-06-25T17:23:47.000Z" title="发表于 2022-06-26 01:23:47">2022-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="分布式缓存与分布式锁"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/fbs.jpg" onerror='this.onerror=null,this.src="/img/404.jpeg"' alt="分布式缓存与分布式锁"></a><div class="content"><a class="title" href="/2022/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="分布式缓存与分布式锁">分布式缓存与分布式锁</a><time datetime="2022-05-16T07:23:47.000Z" title="发表于 2022-05-16 15:23:47">2022-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/15/%E5%9F%BA%E4%BA%8ESpringSecurity%E7%9A%84%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/" title="基于SpringSecurity的认证授权"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/springboot/security.jpeg" onerror='this.onerror=null,this.src="/img/404.jpeg"' alt="基于SpringSecurity的认证授权"></a><div class="content"><a class="title" href="/2022/05/15/%E5%9F%BA%E4%BA%8ESpringSecurity%E7%9A%84%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/" title="基于SpringSecurity的认证授权">基于SpringSecurity的认证授权</a><time datetime="2022-05-15T15:23:47.000Z" title="发表于 2022-05-15 23:23:47">2022-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/09/ElasticSearch/" title="ES基础用法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Es/es.jpeg" onerror='this.onerror=null,this.src="/img/404.jpeg"' alt="ES基础用法"></a><div class="content"><a class="title" href="/2022/05/09/ElasticSearch/" title="ES基础用法">ES基础用法</a><time datetime="2022-05-09T14:23:47.000Z" title="发表于 2022-05-09 22:23:47">2022-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/02/JSR303%E6%A0%A1%E9%AA%8C/" title="JSR303数据校验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Spring/JSR303.jpeg" onerror='this.onerror=null,this.src="/img/404.jpeg"' alt="JSR303数据校验"></a><div class="content"><a class="title" href="/2022/05/02/JSR303%E6%A0%A1%E9%AA%8C/" title="JSR303数据校验">JSR303数据校验</a><time datetime="2022-05-01T17:23:47.000Z" title="发表于 2022-05-02 01:23:47">2022-05-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/fbs.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 咳咳</div><div class="footer_custom_text">Hi, welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"GsGNLORFmjCB9yFfADJIBAR4-gzGzoHsz",appKey:"DeLHVpVyM3s1NHtFDhAuQeMY",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!1},null))}"function"==typeof Valine?n():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}btf.loadComment(document.getElementById("vcomment"),loadValine)</script></div><script type="text/javascript" src="/js/fairyDustCursor.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>