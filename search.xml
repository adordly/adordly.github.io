<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES基础用法</title>
    <url>/2022/05/09/ElasticSearch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h1><blockquote>
<p>之前在没有了解过全文搜索之前，咱们都是将数据持久到数据库当中，但是，数据库的数据分析，存储和搜索性能是有限的，尤其是面对海量数据的时候，操作就会比较复杂了，而<code>ES</code>是一个<strong>分布式的全文检索框架</strong>，则可以快速地储存，搜做和分析海量数据。</p>
</blockquote>
<h2 id="Elastic简介"><a href="#Elastic简介" class="headerlink" title="Elastic简介"></a>Elastic简介</h2><p><code>Elastic</code>是<strong>全文搜索引擎</strong>，也是咱们这篇博客的主角，它的底层是<code>lucence</code>。如果直接操作<code>lucence</code>，调用很繁琐，<code>Elastic</code>就是对<code>lucence</code>做了一个非常好的<strong>封装</strong>，只需要通过<code>Rest API</code>，也就是<strong>发送请求</strong>的方式，就能获取相应的增删改查等功能,同时<code>Rest API</code>具有天然跨平台的良好特性。</p>
<p><strong><a href="%5B%E5%AE%98%E7%BD%91%E6%96%87%E6%A1%A3%5D(https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)">官网文档</a></strong></p>
<p><strong>注意：一些中文文档更新可能不太迅速，还是推荐看官方文档来的快。</strong></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>都说了，<code>ElasticSearch</code>也具备增删改查功能，也就是说，他的内部，也相当于一个数据库，也具有“数据库”，“表”，“属性”等特性，但说法发生了些许变化。</p>
</blockquote>
<h3 id="Index索引"><a href="#Index索引" class="headerlink" title="Index索引"></a>Index索引</h3><ul>
<li>动词：相当于 <code>MySQL</code> 中的 <code>insert</code>（插入）</li>
<li>名词：相当于 <code>MySQL</code> 中的 <code>DataBase</code>（数据库）</li>
</ul>
<h3 id="Type类型"><a href="#Type类型" class="headerlink" title="Type类型"></a>Type类型</h3><ul>
<li>相当于 <code>MySQL</code> 中的 <code>Table</code>（表）</li>
</ul>
<h3 id="Document文档"><a href="#Document文档" class="headerlink" title="Document文档"></a>Document文档</h3><ul>
<li>相当于 <code>MySQL</code> 中某个<code>Table</code>中的<strong>内容</strong></li>
</ul>
<p><strong>注意：在<code>ElasticSearch</code>6.x之后，就不再使用Type这个概念了，就只有<code>Index</code>到<code>Document</code>的过渡了，因为就算分了Type，ElasticSearch查询底层还是会搜素整个索引中所有类型下满足的文档，那么设置类型也就失去了意义。</strong></p>
<h2 id="倒排索引机制"><a href="#倒排索引机制" class="headerlink" title="倒排索引机制"></a>倒排索引机制</h2><blockquote>
<p>这是<code>ElasticSearch</code>中<strong>特别重要</strong>的一个机制，也是<code>ElasticSearch</code>查询的强大之处。它会将咱们存到<code>ElasticSearch</code>的各个文档内容进行分词，在后序查询过程中，会采用<strong>全文索引</strong>的方式，并不是要完全匹配到相应字段才会被检索出来，而是存在相似的分词的文档就会被查出，通过（<strong>检索的文档分词匹配数&#x2F;索引文档分词数</strong>）的大小来决定优先级，一般会有一个<code>score</code>字段（<strong>命中的权重</strong>）作为标识，表示哪个文档的匹配程度更高。</p>
</blockquote>
<p>举个很简单的例子，加入我们索引中有四种文档，id分别为：</p>
<ol>
<li><strong>红海行动</strong> –&gt; “红海”,”行动”</li>
<li><strong>红海探索行动</strong> –&gt; “红海”,”探索”,”行动”</li>
<li><strong>红海特别行动</strong> –&gt; “红海”，”特别”，”行动”</li>
<li><strong>红海记录片</strong> –&gt; “红海”，”纪录片”</li>
<li><strong>红海特工特别探索</strong> –&gt; “红海”，”特工”，”特别”， “探索”</li>
</ol>
<p>那么，我们通过对每个id的分词后，可以得到一张这样的倒排索引表：</p>
<table>
<thead>
<tr>
<th align="center">词</th>
<th align="center">记录</th>
</tr>
</thead>
<tbody><tr>
<td align="center">红海</td>
<td align="center">1， 2， 3， 4， 5</td>
</tr>
<tr>
<td align="center">行动</td>
<td align="center">1， 2， 3</td>
</tr>
<tr>
<td align="center">探索</td>
<td align="center">2， 5</td>
</tr>
<tr>
<td align="center">特别</td>
<td align="center">3，5</td>
</tr>
<tr>
<td align="center">纪录片</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">特工</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>咱们就维护了这样一张倒排索引表，加入有这样一个场景，我们要查询”红海探索”的匹配文档id，那么：</p>
<ul>
<li><p><strong>第一步</strong>：也是将”红海探索”分词 –&gt; “红海”,”探索”</p>
</li>
<li><p><strong>第二步</strong>：咱们在把这些分词拿到倒排索引表中进行匹配，只要远索引中存在分词和查询的分词相同的，就会被检索到。</p>
</li>
<li><p><strong>第三步</strong>：查询到的结果，就是这样，之所以是这样排序的，是按照查询出来的score进行排序的，为什么是这样呢？咱们具体问题具体分析，就拿第一个”红海探索行动”为例子，它分词得到了三个词（ “红海”,”探索”,”行动”），咱们检索的”红海探索”分词为两个词（”红海”,”探索”），这两个词都命中在了”红海探索行动”的分词中，那么概率就是 2&#x2F;3 相比于其他几个，是最高的，就排在了第一位：</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">文档id</th>
<th align="center">score</th>
</tr>
</thead>
<tbody><tr>
<td align="center">红海探索行动</td>
<td align="center">2&#x2F;3</td>
</tr>
<tr>
<td align="center">红海行动</td>
<td align="center">1&#x2F;2</td>
</tr>
<tr>
<td align="center">红海特工特别探索</td>
<td align="center">2&#x2F;4</td>
</tr>
<tr>
<td align="center">红海记录片</td>
<td align="center">1&#x2F;2</td>
</tr>
<tr>
<td align="center">红海特别行动</td>
<td align="center">1&#x2F;3</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p><strong>注意：检索出来的<code>score</code>并不是我们所算的整个分数，但排序是相同的，是按照一定的权重乘积后的结果，检索后的结果<code>ElasticSearch</code>也会自动将<code>score</code>从大到小排序，第一个就是最匹配的结果了。</strong></p>
<h2 id="ES基础"><a href="#ES基础" class="headerlink" title="ES基础"></a>ES基础</h2><blockquote>
<p>基础是真的挺基础的，在这就不过多赘述了，索引，查询等思想跟MySQL大差不差，只是语法变了而已，同样需要下载安装，有文档后序查就行了，不是重点。</p>
</blockquote>
<h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><blockquote>
<p>前面的倒排索引提到了分词机制，但是，ES自带的分词并没有想象中的那么智能，只能分出一些传统的词，个别自定义的词是分不出来的。</p>
</blockquote>
<h3 id="ik分词器"><a href="#ik分词器" class="headerlink" title="ik分词器"></a>ik分词器</h3><p>是一个第三方github分词器，需要下载导入到自己的ES中以供使用。</p>
<h2 id="集成SpringBoot"><a href="#集成SpringBoot" class="headerlink" title="集成SpringBoot"></a>集成SpringBoot</h2><blockquote>
<p>了解了一些<code>ES</code>基础，重点还是如何集成<code>SpringBoot</code>投入实际开发，</p>
</blockquote>
<p>咱们采用Java Rest Client文档来定义相关配置。<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html"><strong>Java Rest Client</strong></a></p>
<p>集成之前，先要了解一下，ES分为两个端口：<strong>9300</strong>，<strong>9200</strong>：</p>
<ul>
<li><strong>9300</strong>： 是<code>ES</code>节点之间通讯使用的端口。它是<code>tcp</code>通讯端口，集群间和<code>TCPclient</code>都走的它。</li>
<li><strong>9200</strong>： 是<code>ES</code>节点与外部通讯使用的端口。它是<code>http</code>协议的<code>RESTful</code>接口（各种CRUD操作都是走的该端口,如查询等）.</li>
</ul>
<p>咱们集成测试CRUD，采用9200端口。</p>
<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义配置类"><a href="#自定义配置类" class="headerlink" title="自定义配置类"></a>自定义配置类</h3><p>所有索引，查询操作都是基于这个<code>RestHighLevelClient</code>来发送请求的，所以需要自定义配置一个我们的RestHighLevelClient到容器中供后序使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallElasticSearchConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RequestOptions.DEFAULT.toBuilder();</span><br><span class="line"><span class="comment">//        builder.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + TOKEN);</span></span><br><span class="line"><span class="comment">//        builder.setHttpAsyncResponseConsumerFactory(</span></span><br><span class="line"><span class="comment">//                new HttpAsyncResponseConsumerFactory</span></span><br><span class="line"><span class="comment">//                        .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));</span></span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">esRestClient</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//配置自己的ES信息</span></span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;ip地址&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><p>咱们的数据模型是这样的：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205092250935.png" alt="image-20220509225010898"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GulimallSearchApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="comment">//数据模型对应的Bean类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> account_number;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">        <span class="keyword">private</span> String firstname;</span><br><span class="line">        <span class="keyword">private</span> String lastname;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String gender;</span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line">        <span class="keyword">private</span> String employer;</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="keyword">private</span> String state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">searchData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 创建检索请求</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>();</span><br><span class="line">        <span class="comment">//    指定索引（也就是指定查哪个表）</span></span><br><span class="line">        searchRequest.indices(<span class="string">&quot;bank&quot;</span>);</span><br><span class="line">        <span class="comment">//    指定DSL,检索条件</span></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">        <span class="comment">//1.1) 构造检索条件</span></span><br><span class="line">        sourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;MILL&quot;</span>));</span><br><span class="line">        <span class="comment">//1.2) 按照年龄值分布进行聚合</span></span><br><span class="line">        <span class="type">TermsAggregationBuilder</span> <span class="variable">size</span> <span class="operator">=</span> AggregationBuilders.terms(<span class="string">&quot;ageAgg&quot;</span>).field(<span class="string">&quot;age&quot;</span>).size(<span class="number">10</span>);</span><br><span class="line">        sourceBuilder.aggregation(size);</span><br><span class="line">        <span class="comment">//1.3）计算平均薪资进行聚合</span></span><br><span class="line">        <span class="type">AvgAggregationBuilder</span> <span class="variable">balanceAvg</span> <span class="operator">=</span> AggregationBuilders.avg(<span class="string">&quot;balanceAvg&quot;</span>).field(<span class="string">&quot;balance&quot;</span>);</span><br><span class="line">        sourceBuilder.aggregation(balanceAvg);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;检索条件&quot;</span> + sourceBuilder.toString());</span><br><span class="line"></span><br><span class="line">        searchRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 执行检索</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, GulimallElasticSearchConfig.COMMON_OPTIONS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 分析结果</span></span><br><span class="line">        System.out.println(searchResponse.toString());</span><br><span class="line">        <span class="comment">//3.1) 获取所有查到的数据 hits</span></span><br><span class="line">        <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line">        SearchHit[] searchHits = hits.getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> searchHit.getSourceAsString();</span><br><span class="line">            <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> JSONUtil.toBean(sourceAsString, Account.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;account: &quot;</span>+account);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2) 获取这次检索的分析信息</span></span><br><span class="line">        <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> searchResponse.getAggregations();</span><br><span class="line">        <span class="type">Terms</span> <span class="variable">ageAgg</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;ageAgg&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Terms.Bucket bucket : ageAgg.getBuckets()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">keyAsString</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄：&quot;</span>+ keyAsString+<span class="string">&quot;==&gt;&quot;</span>+bucket.getDocCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Avg</span> <span class="variable">balanceAvg1</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;balanceAvg&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> balanceAvg1.getValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;平均薪资: &quot;</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试存储数据</span></span><br><span class="line"><span class="comment">     * 更新也可以</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">indexData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        indexRequest.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSONUtil.toJsonStr(user);</span><br><span class="line">        indexRequest.source(s, XContentType.JSON);</span><br><span class="line">        <span class="comment">//执行保存操作</span></span><br><span class="line">        <span class="type">IndexResponse</span> <span class="variable">index</span> <span class="operator">=</span> client.index(indexRequest, GulimallElasticSearchConfig.COMMON_OPTIONS);</span><br><span class="line">        <span class="comment">//提取有用的相应数据</span></span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> String gender;</span><br><span class="line">        <span class="keyword">private</span>  Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<ul>
<li><p>contextLoads()：打印出了自定义配置进io容器中的<strong>RestHighLevelClient</strong>信息</p>
<ul>
<li><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205092253676.png" alt="image-20220509225317618"></li>
</ul>
</li>
<li><p>indexData()： 测试插入一个用户数据，打印了返回值</p>
<ul>
<li><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205092254488.png" alt="image-20220509225445417"></li>
</ul>
</li>
<li><p>searchData（）:构建了一个复杂查询，打印了检索条件，以及检索出来的值筛选分析。</p>
<ul>
<li><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205110132051.png" alt="image-20220511013229896"></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>ES的语法很多，多用才能更加熟练，不懂得直接查官方文档就是了。</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>JSR303数据校验</title>
    <url>/2022/05/02/JSR303%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JSR303校验"><a href="#JSR303校验" class="headerlink" title="JSR303校验"></a>JSR303校验</h1><blockquote>
<p>前端表单提交数据的时候，需要进行一轮数据校验，以保证数据的合法，但是如果绕过前端给后端发送请求（Postman等），就无法保证数据的合法性了，那么，后端对提交的数据进行校验是十分重要的。</p>
</blockquote>
<p>通常我们采取JSR303校验法，面向注解校验，提高开发效率。</p>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p><strong>注意：需要指定starter的版本</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入依赖后，查看jar包中的注解包，发现了有很多校验的注解：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205020006727.png" alt="image-20220502000604653"></p>
<p>知名知意：就知道注解的大概意思了。</p>
<p>咱们只需要在需要校验的Bean字段上加上相应的<strong>约束注解</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;pms_brand&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrandEntity</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@TableId</span></span><br><span class="line">	<span class="keyword">private</span> Long brandId;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotBlank(message = &quot;品牌名必须提交&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@URL(message = &quot;logo必须合法&quot;)</span></span><br><span class="line">	<span class="meta">@NotBlank(message = &quot;logo不能为空&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String logo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String descript;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer showStatus;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pattern(regexp = &quot;^[a-zA-Z]$&quot;,message = &quot;首字母必须a-z或A-Z之间&quot;)</span></span><br><span class="line">	<span class="meta">@NotEmpty</span></span><br><span class="line">	<span class="keyword">private</span> String firstLetter;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Min(value = 0,message = &quot;排序必须大于等于0&quot;)</span></span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">private</span> Integer sort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的注解都是对特定字段加以了限制。</p>
<h2 id="常用的校验注解"><a href="#常用的校验注解" class="headerlink" title="常用的校验注解"></a>常用的校验注解</h2><p>同样，注解也具有一些属性值，比如上面的例子中<code>message</code>指定了报错的提示信息，<code>regexp</code>指定的是满足的正则表达式。</p>
<p>我整理了一些<strong>常用的校验注解</strong>：</p>
<p><strong>Bean Validation 中内置的 constraint:</strong></p>
<table>
<thead>
<tr>
<th align="center">注释</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#96;@NotNull</td>
<td align="center">注释的元素必须<strong>不为 null</strong></td>
</tr>
<tr>
<td align="center">@Null</td>
<td align="center">被注释的元素<strong>必须为 null</strong></td>
</tr>
<tr>
<td align="center">@AssertTrue</td>
<td align="center">被注释的元素<strong>必须为 true</strong></td>
</tr>
<tr>
<td align="center">@AssertFalse</td>
<td align="center">被注释的元素<strong>必须为 false</strong></td>
</tr>
<tr>
<td align="center">@Min(value)（@DecimalMin(value)）</td>
<td align="center">被注释的元素必须是一个数字，其值必须<strong>大于等于</strong>指定的最小值（value）</td>
</tr>
<tr>
<td align="center">@Max(value)（@DecimalMax(value)）</td>
<td align="center">被注释的元素必须是一个数字，其值必须<strong>小于等于</strong>指定的最大值（value）</td>
</tr>
<tr>
<td align="center">@Size(max&#x3D;, min&#x3D;)</td>
<td align="center">被注释的元素的大小必须在指定的范围内**[min,max]**</td>
</tr>
<tr>
<td align="center">@Digits(integer, fraction)</td>
<td align="center">被注释的元素必须是一个<strong>数字</strong>，其值必须在可接受的范围内</td>
</tr>
<tr>
<td align="center">@Past</td>
<td align="center">被注释的元素必须是一个<strong>过去</strong>的日期</td>
</tr>
<tr>
<td align="center">@Future</td>
<td align="center">被注释的元素必须是一个<strong>将来</strong>的日期</td>
</tr>
<tr>
<td align="center">@Pattern(regexp&#x3D;,flag&#x3D;)</td>
<td align="center">被注释的元素必须符合指定的<strong>正则表达式</strong></td>
</tr>
</tbody></table>
<p><strong>Hibernate Validator 附加的 constraint:</strong></p>
<table>
<thead>
<tr>
<th align="center">注释</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@NotBlank</td>
<td align="center">验证<strong>字符串非null</strong>，且<strong>长度必须大于0</strong></td>
</tr>
<tr>
<td align="center">@Email</td>
<td align="center">被注释的元素必须是<strong>电子邮箱地址</strong></td>
</tr>
<tr>
<td align="center">@Length(min&#x3D;,max&#x3D;)</td>
<td align="center">被注释的<strong>字符串</strong>的大小必须在指定的范围内[min,max]</td>
</tr>
<tr>
<td align="center">@NotEmpty</td>
<td align="center">被注释的<strong>字符串</strong>的<strong>必须非空</strong></td>
</tr>
<tr>
<td align="center">@Range(min&#x3D;,max&#x3D;,message&#x3D;)</td>
<td align="center">被注释的<strong>元素</strong>必须在合适的范围内</td>
</tr>
</tbody></table>
<p>注意：其中一些注解需要注意一下@NotNull，@NotBlank，@NotEmpty的区别。</p>
<h2 id="NotNull，-NotBlank，-NotEmpty的区别"><a href="#NotNull，-NotBlank，-NotEmpty的区别" class="headerlink" title="@NotNull，@NotBlank，@NotEmpty的区别"></a>@NotNull，@NotBlank，@NotEmpty的区别</h2><ul>
<li><strong><code>@NotEmpty</code></strong> :<strong>不能为null</strong>，且Size&gt;0，@NotEmpty注解的String、Collection、Map、数组是不能为null或长度为0</li>
<li><strong><code>@NotNull</code></strong> :<strong>不能为null</strong>，但可以为empty,没有Size的约束，带注释的元素不能为null。接受任何类型</li>
<li><strong><code>@NotBlank</code></strong> :<strong>只用于String</strong>,不能为null且trim()之后size&gt;0，纯空格的String也是不符合规则的，此注解只能用于验证String类型</li>
</ul>
<blockquote>
<p>限制了Bean的字段约束，当然还需要再<strong>Controller</strong>的接收表单上加以注解，提示需要校验的类。</p>
</blockquote>
<h2 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h2><blockquote>
<p>放在参数对象上，提示需要：该对象需要被校验</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">update</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand)</span>&#123;</span><br><span class="line">    brandService.updateById(brand);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入了<code>@Valid</code>后，传来的<code>BrandEntity</code>类就会被校验，校验的标准就是之前类字段上的那些约束，违背了约束，就会抛出异常。</p>
<p>那么，抛出了异常，异常类型是<code>MethodArgumentNotValidException</code>，知道了抛出的异常，当然还需要提示用户，哪些地方出现了问题，也就是之前注解上的<code>Message</code>显示。</p>
<h2 id="异常信息显示"><a href="#异常信息显示" class="headerlink" title="异常信息显示"></a>异常信息显示</h2><blockquote>
<p>可以在约束的对象后紧跟一个参数 <strong>BindingResult</strong> bindingResult，这个对象中存储了异常的细化信息。</p>
</blockquote>
<p>通过<code>BindingResult</code>对象，我们就可以知道所有的异常信息了，可以封装起来返回给前端，使异常更加清晰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand,BindingResult result)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123;</span><br><span class="line">        <span class="comment">//1.获取校验的结果集</span></span><br><span class="line">        List&lt;FieldError&gt; fieldErrors = result.getFieldErrors();</span><br><span class="line">        Map&lt;String,String&gt;map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (FieldError item : fieldErrors) &#123;</span><br><span class="line">            <span class="comment">//获取错误提示信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//获取错误的属性名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="number">400</span>,<span class="string">&quot;提交数据不合法&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        brandService.save(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以通过<strong>特定的返回码和data体</strong>，更细化的表达了异常信息，dddd。</p>
<p>返回异常信息就类似这样了，更加清晰明了:</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205020037147.png" alt="image-20220502003729102"></p>
<p><em><strong>那么问题来了，未必，我们每次校验后，都得繁琐的写这些异常获取和返回吗，有没有一种方法可以不写呢？</strong></em></p>
<p>当然有，就是<strong>全局异常统一处理</strong>，听着都不陌生，之前学了，就在这记一笔吧。</p>
<h2 id="全局异常统一处理"><a href="#全局异常统一处理" class="headerlink" title="全局异常统一处理"></a>全局异常统一处理</h2><blockquote>
<p>顾名思义，就是将全局的异常都交给一个地方统一处理，省去了业务中每次都要处理异常的繁琐，也提高了代码的可读性和可维护性。</p>
</blockquote>
<h3 id="RestControllerAdvice"><a href="#RestControllerAdvice" class="headerlink" title="@RestControllerAdvice"></a>@RestControllerAdvice</h3><p>这个注解，是全局异常处理的核心，标注在类上，声明这是一个全局异常处理类，所有的类就会经过他来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//basePackages说明要处理那个包下的异常</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.gulimall.product.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallExceptionControllerAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">handleValidException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取 BindingResult</span></span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        <span class="comment">//获取异常集合并遍历将异常信息存入Map</span></span><br><span class="line">        bindingResult.getFieldErrors().forEach((fieldError) -&gt; &#123;</span><br><span class="line">            map.put(fieldError.getField(), fieldError.getDefaultMessage());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> R.error(BizCodeEnum.VALID_EXCEPTION.getCode(),BizCodeEnum.VALID_EXCEPTION.getMsg()).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">handleValidException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.error(BizCodeEnum.UNKOWN_EXCEPTION.getCode(),BizCodeEnum.UNKOWN_EXCEPTION.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之前说了校验抛出的是<code>MethodArgumentNotValidException</code>异常，直接交到<strong>全局异常处理类</strong>来处理，代码跟之前Controller里的一模一样，只不过，写一遍，等于写了一万遍，之后就不用在每个Controller里面都写一遍了。Controller只剩下这几行代码了，非常简洁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand)</span>&#123;</span><br><span class="line">    brandService.save(brand);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说到这，应该都懂了全局异常怎么用，其实就一个注解，一个类，标识要处理的异常类，把处理内容写进去就行了，很简单。</p>
</blockquote>
<p>那么问题又来了：<em><strong>我们约束的字段，约束条件很固定，那么，存在这样一种情况，修改（Update）情况下，类的某个字段可以不填，但增加（Add）情况下，这个字段又要非空，字段的约束条件是跟着<code>Controller</code>的变化而变化的，怎么解决呢？</strong></em></p>
<p>有问题，就有解决方法，就引出了<strong>分组校验</strong>的思想。</p>
<h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><h3 id="Validated"><a href="#Validated" class="headerlink" title="@Validated"></a>@Validated</h3><blockquote>
<p>跟**<code>@Valid</code><strong>注解类似，但更强大，它声明了这是分组校验，可以添加一个</strong><code>groups</code>**属性，声明是运用哪一组的校验方法。</p>
</blockquote>
<p>同样，看看Bean字段约束相比于之前的变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;pms_brand&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrandEntity</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotNull(message = &quot;修改必须指定品牌id&quot;, groups = &#123;UpdateGroup.class&#125;)</span></span><br><span class="line">	<span class="meta">@Null(message = &quot;新增不能指定品牌id&quot;, groups = &#123;AddGroup.class&#125;)</span></span><br><span class="line">	<span class="meta">@TableId</span></span><br><span class="line">	<span class="keyword">private</span> Long brandId;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotBlank(message = &quot;品牌名必须提交&quot;, groups = &#123;AddGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@URL(message = &quot;logo必须合法&quot;,groups = &#123;AddGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">	<span class="meta">@NotBlank(groups = &#123;AddGroup.class&#125;)</span></span><br><span class="line">	<span class="keyword">private</span> String logo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String descript;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer showStatus;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pattern(regexp = &quot;^[a-zA-Z]$&quot;,message = &quot;首字母必须a-z或A-Z之间&quot;,groups = &#123;UpdateGroup.class, AddGroup.class&#125;)</span></span><br><span class="line">	<span class="meta">@NotEmpty(groups = &#123;AddGroup.class&#125;)</span></span><br><span class="line">	<span class="keyword">private</span> String firstLetter;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Min(value = 0,message = &quot;排序必须大于等于0&quot;,groups = &#123;UpdateGroup.class,AddGroup.class&#125;)</span></span><br><span class="line">	<span class="meta">@NotNull(groups = &#123;UpdateGroup.class&#125;)</span></span><br><span class="line">	<span class="keyword">private</span> Integer sort;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，注解中，都加上了<code>groups</code>属性，就声明了，这个约束在哪个组中生效，传入的是一个<strong>Class集合</strong>，元素是一个个<strong>分组接口</strong>，需要我们自己声明，但这个接口其实就是<strong>一种声明</strong>而已，并没有实际作用，一个接口就是一个组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddGroup</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，需要在Controller中说明参数对象是需要用哪个组进行约束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;product/brand&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrandController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BrandService brandService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@Validated(AddGroup.class)</span> <span class="meta">@RequestBody</span> BrandEntity brand)</span>&#123;</span><br><span class="line">        brandService.save(brand);</span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(UpdateGroup.class)</span><span class="meta">@RequestBody</span> BrandEntity brand)</span>&#123;</span><br><span class="line">		brandService.updateById(brand);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到第一个接口和第二个接口参数对象都是<code>BrandEntity</code>类，但是使用了不同的分组校验后，校验方式就完全不同了，校验方式就跟Bean字段的约束对应了，什么校验组，就用什么校验方式。</p>
<p><strong>注意：用<code>@Validated</code>标识后，如果某个字段有校验信息但没有分组约束，默认不生效</strong></p>
<p>还算简单吧，都是为了简化开发。</p>
<h2 id="返回状态封装"><a href="#返回状态封装" class="headerlink" title="返回状态封装"></a>返回状态封装</h2><blockquote>
<p>实际开发中，返回给前端的都是一个{code，msg，data}的对象数据，更加统一，也更清晰。开发者就可以通过手册差到什么样的异常对应什么样的处理方式。</p>
</blockquote>
<ul>
<li>**<code>code</code>**：返回状态码。</li>
<li>**<code>msg</code>**： 状态码对应的信息。</li>
<li>**<code>data</code>**：返回的数据封装。</li>
</ul>
<p>返回类通常封装成一个<strong>枚举类</strong>，其中列举每一种信息就行了，用个简单的例子说明一下就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BizCodeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    UNKOWN_EXCEPTION(<span class="number">10000</span>,<span class="string">&quot;系统未知异常&quot;</span>),</span><br><span class="line">    VALID_EXCEPTION(<span class="number">10001</span>, <span class="string">&quot;参数校验错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    BizCodeEnum(<span class="type">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后我们就只需要BizCodeEnum.UNKOWN_EXCEPTION的方式获取状态码和msg了，返回就得到了统一，标准了开发规范。</p>
<h2 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h2><blockquote>
<p>有时候，基本的校验注解满足不了我们对属性字段的约束，那么，我们就需要自定义注解来实现相应的约束功能。</p>
</blockquote>
<p>自定义，当然是得模仿提供的约束注解来写，就以<code>@NotNull</code>为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(List.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotNull &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.错误提示信息来自javax.validation.constraints.NotNull.message</span></span><br><span class="line">	String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;javax.validation.constraints.NotNull.message&#125;&quot;</span>;</span><br><span class="line">    <span class="comment">//2.分组信息</span></span><br><span class="line">	Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">	<span class="comment">//3.携带的载体信息</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span></span><br><span class="line">	<span class="meta">@Retention(RUNTIME)</span></span><br><span class="line">	<span class="meta">@Documented</span></span><br><span class="line">	<span class="meta">@interface</span> List &#123;</span><br><span class="line">		NotNull[] value();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参照这个注解，编写自定义注解，来约束显示状态字段<code>ShowStatus</code>：</p>
<h3 id="编写校验注解"><a href="#编写校验注解" class="headerlink" title="编写校验注解"></a>编写校验注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; ListValueConstraintValidator.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;com.common.valid.ListValue.message&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//咱们要约束的限制值集合</span></span><br><span class="line">    <span class="type">int</span>[] vals() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到咱们<code>@Constraint</code>中添加了一个<code>ListValueConstraintValidator</code>类，这个类是一个校验类，说明了咱们的注解是按照什么样的校验方式校验的。</p>
<p>点进<code>@Constraint</code>，我们可以看到源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123; ANNOTATION_TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraint &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//传入的类必须继承ConstraintValidator，代表该类是一个校验类</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">ConstraintValidator</span>&lt;?, ?&gt;&gt;[] validatedBy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConstraintValidator</span>&lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>, T&gt; &#123;</span><br><span class="line">	<span class="comment">//初始化方法</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(A constraintAnnotation)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//是否校验成功</span></span><br><span class="line">    <span class="comment">//value： 要校验的值</span></span><br><span class="line">    <span class="comment">//context: 校验的上下文环境</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(T value, ConstraintValidatorContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，依葫芦画瓢，编写自己的校验类吧</p>
<h3 id="编写自己的校验类"><a href="#编写自己的校验类" class="headerlink" title="编写自己的校验类"></a>编写自己的校验类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;ListValue,Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//判断是否校验成功</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//set中存在value就校验通过了</span></span><br><span class="line">        <span class="keyword">return</span> set.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ListValue constraintAnnotation)</span> &#123;</span><br><span class="line">        <span class="comment">//constraintAnnotation.vals() 获取约束集合 --&gt; set</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : constraintAnnotation.vals()) &#123;</span><br><span class="line">            set.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定注解到相应的校验类"><a href="#绑定注解到相应的校验类" class="headerlink" title="绑定注解到相应的校验类"></a>绑定注解到相应的校验类</h3><p>就是通过<code>@Constraint</code>来绑定就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Constraint(validatedBy = &#123; ListValueConstraintValidator.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：<code>validatedBy</code>中的值是一个集合，就代表这，咱们的注解可以适配多个校验器。</strong></p>
<h3 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h3><p>自定义了注解后，就像之前使用包注解一样使用就行了，非常简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;pms_brand&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrandEntity</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="meta">@NotNull(groups = &#123;AddGroup.class, UpdateStatusGroup.class&#125;)</span></span><br><span class="line">	<span class="meta">@ListValue(vals = &#123;0,1&#125;,groups = &#123;AddGroup.class, UpdateStatusGroup.class&#125;)</span></span><br><span class="line">	<span class="keyword">private</span> Integer showStatus;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>JSR303校验是后端对请求数据的常用校验方式，当然发送请求前，需要先进行前端的校验逻辑后，前端校验通过后，才能发送给后端校验，两次校验，也保证了数据的安全性。</strong></p>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2022/02/26/Maven/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><h1 id="Maven项目管理工具"><a href="#Maven项目管理工具" class="headerlink" title="Maven项目管理工具"></a>Maven项目管理工具</h1></li>
<li><h3 id="Maven-项目管理工具（软件工程）2020最新Maven教程-Maven基础篇之Maven实战入门-哔哩哔哩-bilibili"><a href="#Maven-项目管理工具（软件工程）2020最新Maven教程-Maven基础篇之Maven实战入门-哔哩哔哩-bilibili" class="headerlink" title="Maven:项目管理工具（软件工程）2020最新Maven教程-Maven基础篇之Maven实战入门_哔哩哔哩_bilibili"></a>Maven:项目管理工具（软件工程）<a href="https://www.bilibili.com/video/BV1dp4y1Q7Hf?p=16&spm_id_from=pageDriver">2020最新Maven教程-Maven基础篇之Maven实战入门_哔哩哔哩_bilibili</a></h3></li>
<li><h4 id="一部分"><a href="#一部分" class="headerlink" title="一部分:"></a>一部分:</h4><ul>
<li><h5 id="1）完成一个java项目："><a href="#1）完成一个java项目：" class="headerlink" title="1）完成一个java项目："></a>1）完成一个java项目：</h5><ul>
<li><p>1.分析项目要做什么，知道项目的组成部分</p>
</li>
<li><p>2.设计项目，通过哪些步骤，使用哪些技术，需要多少人，多长时间</p>
</li>
<li><p>3.组建团队，构建设备，招人，服务器，软件，笔记本</p>
</li>
<li><p>4.开发人写代码，开发人员测试自己写的代码，重复多次的操作</p>
</li>
<li><p>5.测试人员，测试项目功能是否符合要求，测试开发人员提交代码–如果测试有问题—需要开发人员修改—在提交给测试人员。。。循环往复，直至测试代码通过</p>
</li>
</ul>
</li>
<li><h5 id="2）传统开发项目的问题，没有使用maven管理的项目"><a href="#2）传统开发项目的问题，没有使用maven管理的项目" class="headerlink" title="2）传统开发项目的问题，没有使用maven管理的项目"></a>2）传统开发项目的问题，没有使用maven管理的项目</h5><ul>
<li><p>​        很多的模块，模块之间还有关系，手工管理关系很繁琐</p>
</li>
<li><p>​        需要很多第三方功能，需要很多jar文件，需要手工从网络中获得jar包</p>
</li>
<li><p>​        需要管理jar包的版本，需要mysql5.1.5.jar 不能其他版本</p>
</li>
<li><p>​        管理jar文件之间的依赖，你的项目要使用a.jar需要使用b.jar里面的类，则必须先准备b.jar才能用a.jar，存在jar依赖</p>
</li>
</ul>
</li>
<li><h5 id="3）需要改进项目开发和管理，需要maven"><a href="#3）需要改进项目开发和管理，需要maven" class="headerlink" title="3）需要改进项目开发和管理，需要maven"></a>3）需要改进项目开发和管理，需要maven</h5><ul>
<li><p>1.maven可以管理jar文件</p>
</li>
<li><p>2.自动下载jar和他的文档，源代码</p>
</li>
<li><p>3.管理jar之间的依赖</p>
</li>
<li><p>4.自动管理jar版本</p>
</li>
<li><p>5.帮你去编译程序，把java编译为class</p>
</li>
<li><p>6.帮你测试你的代码是否正确</p>
</li>
<li><p>7.帮你打包文件，形成jar文件和war文件</p>
</li>
<li><p>8.帮你部署项目</p>
</li>
</ul>
</li>
<li><h5 id="4）构建：项目的构建"><a href="#4）构建：项目的构建" class="headerlink" title="4）构建：项目的构建"></a>4）构建：项目的构建</h5><ul>
<li><p>构建面向过程，就是一些步骤，完成项目代码的编译，测试，运行，打包，部署等等</p>
</li>
<li><p>maven支持的构建包括：</p>
<ul>
<li><p>1.清理，  把之前项目编译的东西删除掉，为新的编译代码做准备</p>
</li>
<li><p>2.编译，   批量把程序源代码编译为执行代码，java—&gt;class，批量，maven可同时把成千上百个文件编译为class。</p>
<ul>
<li>和javac不一样，javac一次只能一个文件</li>
</ul>
</li>
<li><p>3.测试，maven可以执行测试程序代码，验证你的功能是否正确，批量的，maven同时执行多个测试代码，一次性测试多个功能</p>
</li>
<li><p>4.报告， 生成测试结果的文件，测试是否通过</p>
</li>
<li><p>5.打包， 把项目中所有class，配置文件等所有资源放到一个压缩文件中，这压缩文件通常是结果文件，通常java压缩文件是.jar，web应用压缩文件为.war</p>
</li>
<li><p>6.安装， 把打包生成的jar或者war安装到本机仓库</p>
</li>
<li><p>7.部署， 把程序安装好可以执行，部署到服务器上运行</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="5）maven的核心概念：用好maven需要了解的maven"><a href="#5）maven的核心概念：用好maven需要了解的maven" class="headerlink" title="5）maven的核心概念：用好maven需要了解的maven"></a>5）maven的核心概念：用好maven需要了解的maven</h5><ul>
<li>1.POM：一个文件，名称pom.xml,pom翻译过来叫做项目模型。maven把一个项目当作一个模型来使用，控制maven构建项目的过程，管理jar依赖</li>
<li>2.约定的目录结构：maven项目的目录和文件的位置都是规定的</li>
<li>3.坐标: 是一个唯一的字符串,用来表示资源</li>
<li>4.依赖管理:管理你的项目可以使用的jar文件</li>
<li>5.仓库管理(了解):你的资源存放的位置</li>
<li>6.生命周期(了解):maven工具构建项目的过程,就是生命周期</li>
<li>7.插件和目标(了解): 执行maven构建的时候用的工具是插件</li>
<li>8.继承:</li>
<li>9.聚合:</li>
</ul>
</li>
</ul>
<h3 id="讲maven的使用-先难后易"><a href="#讲maven的使用-先难后易" class="headerlink" title="讲maven的使用,先难后易."></a>讲maven的使用,先难后易.</h3><h3 id="难-使用maven的命名-完成maven的使用"><a href="#难-使用maven的命名-完成maven的使用" class="headerlink" title="难:使用maven的命名,完成maven的使用"></a>难:使用maven的命名,完成maven的使用</h3><h3 id="易-在IDEA中直接使用maven-代替命令"><a href="#易-在IDEA中直接使用maven-代替命令" class="headerlink" title="易:在IDEA中直接使用maven,代替命令."></a>易:在IDEA中直接使用maven,代替命令.</h3><ul>
<li><h5 id="6-maven工具的安装和配置"><a href="#6-maven工具的安装和配置" class="headerlink" title="6)maven工具的安装和配置"></a>6)maven工具的安装和配置</h5><ul>
<li><p>1.需要从官网下载maven的安装包 apache-maven-3.8.4</p>
</li>
<li><p>2.解压安装包,解压到一个目录,非中文目录 </p>
<ul>
<li><p>子目录 bin:执行程序,主要是mvn.cmd</p>
</li>
<li><p>conf:maven工具本身的配置文件 settings.xml</p>
</li>
</ul>
</li>
<li><p>3.配置环境变量</p>
</li>
<li><p>在系统的环境变量中,指定一个M2_HOME的名称,指定它的值是maven安装目录安装bin之前的目录</p>
</li>
<li><p>再把M2_HOME加入到path之中,在所有路径之前加入 %M2_HOME%bin</p>
</li>
</ul>
</li>
<li><p>4.验证,新的命令行cmd中,执行mvn -v,若出现maven版本,则安装配置成功</p>
</li>
<li><p>注意:需要配置jdk环境变量</p>
</li>
</ul>
</li>
<li><h4 id="二部分"><a href="#二部分" class="headerlink" title="二部分:"></a>二部分:</h4><ul>
<li><p>1.maven约定的目录结构,约定是大家都遵循的一个规则</p>
<ul>
<li><p>每一个maven项目在磁盘中都是一个文件夹(项目 : Hello)</p>
</li>
<li><p>目录结构:<img src="https://api2.mubu.com/v3/document_image/0d3a2642-99ab-4164-a5b3-89c1839059b2-12278667.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>2.疑问 : mvn compile 编译src&#x2F;main目录下的所有java文件</p>
<ul>
<li><p>为什么要下载那么多jar:maven工具执行的操作是需要很多插件 (java类—jar文件) 来完成</p>
</li>
<li><p>下载的是什么东西:jar文件—插件,完成某些功能</p>
</li>
<li><p>下载的东西存在哪:默认仓库:C:\Users\咳咳.m2\repository</p>
</li>
<li><p><a href="http://repo.maven.apache.org/">http://repo.maven.apache.org</a>  :中央仓库地址</p>
</li>
</ul>
</li>
<li><p>执行mvn compile 结果是在项目的根目录下生成target目录(结果目录)</p>
</li>
<li><p>设置本机存放资源的目录位置(设置本机仓库)</p>
<ul>
<li><p>1.修改maven的配置文件,maven中的settings.xml,记得先备份</p>
</li>
<li><p>2.修改 <localrepository> 指定你的目录 (不要使用中文目录)</p>
</li>
</ul>
</li>
<li><p>3.仓库</p>
<ul>
<li><p>1)仓库是什么: 仓库是存放东西的,存放jar和项目使用的jar</p>
<ul>
<li><p>maven使用的插件(各种jar)</p>
</li>
<li><p>第三方jar包</p>
</li>
</ul>
</li>
<li><p>2)仓库分类</p>
<ul>
<li><p>本地仓库</p>
</li>
<li><p>远程仓库:互联网上的,使用网络才能使用的仓库</p>
<ul>
<li><p>中央仓库:唯一</p>
</li>
<li><p>中央仓库的镜像:就是中央仓库的备份,在各大洲和重要城市都有镜像</p>
</li>
<li><p>私服:在公司内部,在局域网中使用的,不是对外使用的</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3)仓库的使用,maven仓库的使用不需要人为 参与</p>
<ul>
<li>eg.  开发人员需要使用mysql驱动——&gt;maven首先查本地仓库——–&gt;查私服——–&gt;访问中央仓库镜像———&gt;访问中央仓库</li>
</ul>
</li>
</ul>
</li>
<li><p>4.pom:项目的对象模型，是一个pom.xml文件</p>
<ul>
<li><p>坐标：唯一值，在互联网中唯一标识一个项目的<img src="https://api2.mubu.com/v3/document_image/e24be792-cbb9-41d1-9ed4-3f78aa520e21-12278667.jpg" alt="img"></p>
</li>
<li><p><a href="http://mvnrepository.com/">http://mvnrepository.com</a> &#x2F;： 搜索中央仓库的资源，使用groupId或者artifactId查找</p>
</li>
<li><p>pom.xml初识<img src="https://api2.mubu.com/v3/document_image/ce220aed-dc85-4589-92ca-63c8547ca9e6-12278667.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/4368e62e-d27b-4513-8402-a32f1da34ec5-12278667.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/fd017289-cd28-46be-8de0-ce304d3765e9-12278667.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>5.maven的生命周期，maven的命令，maven的插件</p>
<ul>
<li><p>maven的生命周期：就是maven构建项目的过程</p>
</li>
<li><p>maven的命令：maven独立使用通过命令</p>
</li>
<li><p>maven插件：maven命令执行时，真正完成功能的插件，就是一些jar</p>
</li>
<li><p>1）单元测试：用junit，junit是一个专门测试的框架，junit测试的内容，测试的是类中的方法，每一个方法都是独立测试的，方法是测试的基本单位（单元）</p>
<ul>
<li>maven借助单元测试，批量测试你类中的方法是否符合预期</li>
</ul>
</li>
<li><p>2）使用步骤</p>
<ul>
<li><p>在pom.xml加入junit依赖  单元测试</p>
</li>
<li><p>在maven项目中的src &#x2F;test&#x2F;java目录下，创建测试程序</p>
<ul>
<li>推荐</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="三部分（必会）："><a href="#三部分（必会）：" class="headerlink" title="三部分（必会）："></a>三部分（必会）：</h4><ul>
<li><h5 id="1-在IDEA中设置Maven，结合使用很方便，IDEA中内置了一个Maven，一般不使用内置的，因为用内置的修改Maven设置不方便，使用自己安装的Maven，需要配置IDEA的Maven"><a href="#1-在IDEA中设置Maven，结合使用很方便，IDEA中内置了一个Maven，一般不使用内置的，因为用内置的修改Maven设置不方便，使用自己安装的Maven，需要配置IDEA的Maven" class="headerlink" title="1.在IDEA中设置Maven，结合使用很方便，IDEA中内置了一个Maven，一般不使用内置的，因为用内置的修改Maven设置不方便，使用自己安装的Maven，需要配置IDEA的Maven"></a>1.在IDEA中设置Maven，结合使用很方便，IDEA中内置了一个Maven，一般不使用内置的，因为用内置的修改Maven设置不方便，使用自己安装的Maven，需要配置IDEA的Maven</h5><ul>
<li><p>配置Maven：入口1：settings（当前工程设置）和other settings（以后工程）</p>
</li>
<li><p>配置VM Option为-DarchetypeCatalog&#x3D;internal，配置Maven下载更快（新版本不需要加）<img src="https://api2.mubu.com/v3/document_image/a73599ea-dd1a-468a-8d42-cf8f2b4439df-12278667.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><h5 id="使用Maven模板创建项目"><a href="#使用Maven模板创建项目" class="headerlink" title="使用Maven模板创建项目"></a>使用Maven模板创建项目</h5></li>
</ul>
</li>
<li><h4 id="四部分"><a href="#四部分" class="headerlink" title="四部分"></a>四部分</h4><ul>
<li>1.依赖范围：<code>scope</code><ul>
<li><p><code>scope</code>的值为<code>compile， test， provided</code> （默认为<code>compile</code>）</p>
</li>
<li><p><code>scope</code>：表示以来使用的范围，也就是在maven项目的那些阶段中起作用</p>
<ul>
<li>maven构建项目阶段，清理，编译，测试，打包，安装，部署过程（阶段）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="五部分"><a href="#五部分" class="headerlink" title="五部分"></a>五部分</h4><ul>
<li><p>maven常用操作</p>
<ul>
<li><p>maven属性设置</p>
<ul>
<li><properties> 设置maven的常用属性</li>
</ul>
</li>
<li><p>maven的全局变量</p>
<ul>
<li>自定义的属性，1.在<properties>  中自定义后通过   ${变量名}直接用</li>
</ul>
</li>
<li><p>资源插件<img src="https://api2.mubu.com/v3/document_image/2f381971-4c04-4fbc-a76f-7923bc54ea87-12278667.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis(一)学习笔记：简介</title>
    <url>/2022/03/16/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-一-：简介"><a href="#MyBatis-一-：简介" class="headerlink" title="MyBatis(一)：简介"></a>MyBatis(一)：简介</h1><p><img src="/img/MyBatis/MyBatis.png" alt="MyBatis"></p>
<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><ul>
<li>jdk 8+</li>
<li>MySQL</li>
<li>Maven</li>
<li>IDEA</li>
</ul>
<p>学习前需要掌握：</p>
<ul>
<li>JDBC</li>
<li>MySQL</li>
<li>Java基础</li>
<li>Maven</li>
<li>Junit单元测试</li>
</ul>
<p><strong>学一个东西的最初，当然得what,why,how三不走</strong></p>
<h2 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h2><p>直接上百度百科！</p>
<ul>
<li>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</li>
<li>2013年11月迁移到了Github：<a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li>
<li>Mybatis官方文档：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p>
<ul>
<li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li>
<li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li>
<li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li>
</ul>
<p><strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong></p>
<ul>
<li>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</li>
<li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</li>
</ul>
<h2 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h2><p>​    <strong>什么是持久层？</strong></p>
<ul>
<li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li>
<li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li>
<li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li>
<li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li>
</ul>
<h2 id="为什么需要Mybatis"><a href="#为什么需要Mybatis" class="headerlink" title="为什么需要Mybatis"></a>为什么需要Mybatis</h2><ul>
<li><p>Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 .</p>
</li>
<li><p>传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 .</p>
</li>
<li><p>MyBatis 是一个半自动化的<strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p>
</li>
<li><p>所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！</p>
</li>
<li><ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li>
<li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
</li>
<li><p>最重要的一点，使用的人多！公司需要！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MaBatis</category>
      </categories>
      <tags>
        <tag>MaBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis学习笔记(二)：ReslutMap</title>
    <url>/2022/03/17/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%EF%BC%9AReslutMap/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis学习笔记-二-：ReslutMap"><a href="#MyBatis学习笔记-二-：ReslutMap" class="headerlink" title="MyBatis学习笔记(二)：ReslutMap"></a>MyBatis学习笔记(二)：ReslutMap</h1><p>在开发过程中，很多时间我们无法保证实体对象的属性名与对应表的字段名相同，在执行sql映射时，可能因为字段名的不同查询错误，那么ReslutMap就应运而生了。</p>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写MyBatis工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">           <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">           sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取SqlSession连接</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSession</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//User实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> id;  <span class="comment">//id</span></span><br><span class="line">   <span class="keyword">private</span> String name;   <span class="comment">//姓名</span></span><br><span class="line">   <span class="keyword">private</span> String password;   <span class="comment">//密码和数据库不一样！</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造</span></span><br><span class="line">   <span class="comment">//set/get</span></span><br><span class="line">   <span class="comment">//toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的表字段：id，name，pwd</p>
<p><strong>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id查询用户</span></span><br><span class="line">User <span class="title function_">selectUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>映射文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">  select * from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectUserById</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> MybatisUtils.getSession();  <span class="comment">//获取SqlSession连接</span></span><br><span class="line">   <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class); <span class="comment">//获取对应的映射类</span></span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.selectUserById(<span class="number">1</span>); <span class="comment">//执行映射对应的数据库方法</span></span><br><span class="line">   System.out.println(user); </span><br><span class="line">   session.close(); <span class="comment">//别忘了关闭会话流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果：<code>User&#123;id=1, name=&#39;狂神&#39;, password=&#39;null&#39;&#125;</code></p>
<p><strong>思考一下，为什么会出现password为null的情况？</strong></p>
<p>很显然，实体类的password字段和数据库的pwd名字不同，在查询过程中，<code>select * from user where id = #&#123;id&#125;</code>相当于<code>select id,name,pwd from user where id = #&#123;id&#125;</code>来查找对应的字段，mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() （只有setPassword()）, 所以password返回null ; </p>
<p>说白了，错误的根本原因是实体类属性名和数据库对应字段名不一样。</p>
<p><strong>解决办法</strong></p>
<p><strong>方案一：</strong>给查询字段取个别名就行了(as 别名，别名要与实体类属性名一致)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">  select id,name,pwd as password from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方案二：</strong>使用结果集映射-&gt;ResultMap**[推荐]**</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- id为主键 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">  select id , name , pwd from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在实际SpringBoot中，常常使用@Table和@Colume注解来生成ResultMap映射关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;对应的数据库表名&quot;)</span> <span class="comment">//放在类前</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Colume(name = &quot;数据库字段名&quot;)</span></span><br><span class="line">Object 类属性名; <span class="comment">//类属性名 --&gt;启功默认构建 类属性名--&gt;数据库字段名的映射关系</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Id</span> <span class="comment">//标记属性为主键</span></span><br></pre></td></tr></table></figure>

<p>数据库中，不单单是只有一对一的关系，还存在一对多，多对一的情况，之后还会使用到一些高级的结果集映射，association，collection这些，重点了解映射集的概念。</p>
]]></content>
      <categories>
        <category>MaBatis</category>
      </categories>
      <tags>
        <tag>MaBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis学习笔记(三)：动态sql</title>
    <url>/2022/03/18/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)%EF%BC%9A%E5%8A%A8%E6%80%81sql/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis学习笔记-三-：动态sql"><a href="#MyBatis学习笔记-三-：动态sql" class="headerlink" title="MyBatis学习笔记(三)：动态sql"></a>MyBatis学习笔记(三)：动态sql</h1><p>什么是动态SQL：<strong>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</strong></p>
<p>动态sql是MyBatis的强大特性之一，也可以大量减少相同形式sql代码的书写，提高了开发效率。</p>
<p>主要语法分为一下几种：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">-if</span><br><span class="line">-choose(whenmotherwise)</span><br><span class="line">-trim(where,set)</span><br><span class="line">-foreach</span><br><span class="line">...</span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure>

<p>少代码就意味着少bug，sql语句一旦涉及到多表查询等操作就会变得很复杂，稍微不注意，由于细微错误导致的bug太多了，动态sql大大提高了sql语句的准确性。</p>
<p>下面就一个个单独讲解一下以上关键字的用法。</p>
<p>测试的第一步都是准备数据库，创建好数据，即创建好表，添加好字段内容。</p>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><strong>if 语句</strong></h2><p>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</p>
<p>1.编写接口类方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">List&lt;Blog&gt; <span class="title function_">queryBlogIf</span><span class="params">(Map map)</span></span><br></pre></td></tr></table></figure>

<p>2.编写映射xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">  select * from blog where</span><br><span class="line">   <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      title = #&#123;title&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">      and author = #&#123;author&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>很显然，上面的动态sql代码是存在问题的，当title为空时，sql语句变成了<code>select * from blog where and author = #&#123;author&#125;</code>很显然这是错误的语句，那么如何解决上面的问题呢?</p>
<h2 id="where-标签"><a href="#where-标签" class="headerlink" title="where 标签"></a><strong>where 标签</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">  select * from blog</span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">          title = #&#123;title&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">          and author = #&#123;author&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>where</code>会知道如果它包含了的标签有返回值的时候，自动在sql对应位置加入<code>where</code>，但是如果语句以<code>or</code>或者<code>and</code>开头的话，<code>where</code>会自动不加，就非常智能。</p>
<p>3.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryBlogIf</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">seesion</span> <span class="operator">=</span> MybatisUtils.getSession;</span><br><span class="line">    <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> seesion.getMapper(BlogMapper.class);</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt; ();</span><br><span class="line">    map.put(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;Mybatis如此简单&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;狂神说&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;Blog&gt; blogs = mapper.queryBlogIf(map);</span><br><span class="line">    System.out.println(blogs);</span><br><span class="line"></span><br><span class="line">    session.close();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了if语句，大概就可以举一反三了。</p>
<h2 id="Set-标签"><a href="#Set-标签" class="headerlink" title="Set 标签"></a>Set 标签</h2><p>同理上面的where，这是针对于更新语句的，除了标签名不同，其他用法完全相同。</p>
<h2 id="choose-语句"><a href="#choose-语句" class="headerlink" title="choose 语句"></a><strong>choose 语句</strong></h2><p>有时，我们并不是需要所有的查询条件，只想针对性的选择其中的一个或多个，choose便可解决这个问题，类似于Java中的switch语句。</p>
<p>1.编写接口类方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Blog&gt; <span class="title function_">queryBlogChoose</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure>

<p>2.编写映射xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">	select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                title = #&#123;title&#125;</span><br><span class="line">           	<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">           	<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">              	and author = #&#123;author&#125;</span><br><span class="line">           	<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            	and views = #&#123;views&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><strong>一定要理清各个标签的层级关系</strong></li>
</ul>
<h2 id="SQL-片段"><a href="#SQL-片段" class="headerlink" title="SQL 片段"></a><strong>SQL 片段</strong></h2><p>有时，可能我们会重复使用一个相同的sql代码块，那么我们可以把这个代码块提取出来，需要的之后像函数一样直接调用即可。</p>
<p>提取代码片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      title = #&#123;title&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">      and author = #&#123;author&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引用sql片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">  select * from blog</span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果refid 指定的不在本文件中，那么需要在前面加上 namespace 变成：namespace.sql片段id--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>最好是基于单表来定义sql片段</li>
<li>sql片段中不要包含where标签</li>
</ul>
<h2 id="foreach-语句"><a href="#foreach-语句" class="headerlink" title="foreach 语句"></a><strong>foreach 语句</strong></h2><p>这个用于遍历语句，用的较少，简单说一下</p>
<p>将数据库中前三个数据的id修改为1,2,3；</p>
<p>需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息</p>
<p>1.编写接口类方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Blog&gt; <span class="title function_">queryBlogForeach</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure>

<p>2.编写sql语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogForeach&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">  select * from blog</span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       collection:指定输入对象中的集合属性</span></span><br><span class="line"><span class="comment">       item:每次遍历生成的对象</span></span><br><span class="line"><span class="comment">       open:开始遍历时的拼接字符串</span></span><br><span class="line"><span class="comment">       close:结束时拼接的字符串</span></span><br><span class="line"><span class="comment">       separator:遍历对象之间需要拼接的字符串</span></span><br><span class="line"><span class="comment">       select * from blog where 1=1 and (id=1 or id=2 or id=3)</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span>  <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;and (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">          id=#&#123;id&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总的来说，动态sql就是用来简化sql代码开发的，但是在简化之前，我们还是需要清楚掌握sql的相关语法，在原sql语言的基础上，运用MyBatis提供的各种功能标签，才能事半功倍！！</p>
]]></content>
      <categories>
        <category>MaBatis</category>
      </categories>
      <tags>
        <tag>MaBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(一):介绍和基本命令</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E4%B8%80%EF%BC%89%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-一）-介绍和基本命令"><a href="#MySQL知识回顾-一）-介绍和基本命令" class="headerlink" title="MySQL知识回顾(一）: 介绍和基本命令"></a>MySQL知识回顾(一）: 介绍和基本命令</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DBMS(数据库管理系统：软件)—&gt;Sql（sql文件，sql语句）—-&gt;DB（数据库）</p>
<p>MySQL属于DBMS，其他的数据库管理系统也很多（db2,sybase..）</p>
<h2 id="数据库常用命令"><a href="#数据库常用命令" class="headerlink" title="数据库常用命令"></a>数据库常用命令</h2><h3 id="查看MySQL版本号"><a href="#查看MySQL版本号" class="headerlink" title="查看MySQL版本号"></a><strong>查看MySQL版本号</strong></h3><p><strong><code>select version();</code></strong></p>
<h3 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a><strong>查看所有数据库</strong></h3><p> <strong><code>show databases;</code></strong></p>
<p><strong>注意</strong>：<strong>以英文分号结尾语句</strong></p>
<p>mysql默认自带了4个数据库:</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/image-20220418155748240.png" alt="image-20220418155748240"></p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a><strong>创建数据库</strong></h3><p> <strong><code>create database 数据库名;</code></strong></p>
<h3 id="选择想要使用的数据库"><a href="#选择想要使用的数据库" class="headerlink" title="选择想要使用的数据库"></a><strong>选择想要使用的数据库</strong></h3><p><strong><code>use 数据库名;</code></strong></p>
<h3 id="导入sql语句数据"><a href="#导入sql语句数据" class="headerlink" title="导入sql语句数据"></a><strong>导入sql语句数据</strong></h3><p><strong><code>source sql文件的绝对路径</code></strong></p>
<h3 id="查看当前正在使用的数据库"><a href="#查看当前正在使用的数据库" class="headerlink" title="查看当前正在使用的数据库"></a><strong>查看当前正在使用的数据库</strong></h3><p><strong><code>select database();</code></strong></p>
<h3 id="查看数据库下有哪些表"><a href="#查看数据库下有哪些表" class="headerlink" title="查看数据库下有哪些表"></a><strong>查看数据库下有哪些表</strong></h3><p><strong><code>show tables;</code></strong></p>
<h3 id="查看一个表的结构"><a href="#查看一个表的结构" class="headerlink" title="查看一个表的结构"></a><strong>查看一个表的结构</strong></h3><p><strong><code>desc 表名</code></strong></p>
<p><strong>注意</strong></p>
<p><strong>命令大小写不敏感,    不见分号不执行。</strong></p>
<p>就列了一些比较常用的，后序要用啥再查呗。</p>
<h2 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h2><ul>
<li><p><strong>DQL</strong>： 数据库查询语言（凡是带有select关键字的都是查询语句）</p>
</li>
<li><p><strong>DML</strong>： 数据操作语言（凡是对表中的数据进行增删改的都是DML,主要是操作表中的数据）</p>
<ul>
<li>insert</li>
<li>update</li>
<li>delete</li>
</ul>
</li>
<li><p><strong>DDL</strong>： 数据定义语言(操作表的结构)</p>
<ul>
<li>create</li>
<li>alter</li>
<li>drop</li>
</ul>
</li>
<li><p>TCL：事务控制语言，包括：事务提交commit 和 回滚rollback</p>
</li>
<li><p>DCL：数据控制语言，例如授权grant，撤销授权revoke</p>
</li>
</ul>
<h2 id="MySQL语句执行的顺序"><a href="#MySQL语句执行的顺序" class="headerlink" title="MySQL语句执行的顺序"></a>MySQL语句执行的顺序</h2><p><strong>必须掌握</strong>:</p>
<ol>
<li>from</li>
<li>where</li>
<li>select</li>
<li>group by</li>
<li>order by</li>
<li>limit (在查询出结果了再执行)</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(三):DML，DDL</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E4%B8%89%EF%BC%89%20DML/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-三）-DML，DDL"><a href="#MySQL知识回顾-三）-DML，DDL" class="headerlink" title="MySQL知识回顾(三）: DML，DDL"></a>MySQL知识回顾(三）: DML，DDL</h1><p>基本学完了DQL，再来学学DML，比较简单，就不用做太多笔记了。</p>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>为表<strong>插入一行记录</strong></p>
<p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名 values (属性值1,属性值2,...)</span><br></pre></td></tr></table></figure>

<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><strong>修改表数据</strong></p>
<p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段1 = 值..</span><br></pre></td></tr></table></figure>

<h3 id="delete（DML语句）"><a href="#delete（DML语句）" class="headerlink" title="delete（DML语句）"></a>delete（DML语句）</h3><p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from 表名 where...</span><br></pre></td></tr></table></figure>

<p>delete语句<strong>删除数据</strong>的原理</p>
<p>表中的数据被删除了，但是这个数据在硬盘上的真实储存空间还在。</p>
<p><strong>缺点</strong>：删除效率比较低。</p>
<p><strong>优点</strong>：支持回滚，可以恢复删除了的数据。</p>
<h3 id="truncate（DDL语句）"><a href="#truncate（DDL语句）" class="headerlink" title="truncate（DDL语句）"></a>truncate（DDL语句）</h3><p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truncate table 表名</span><br></pre></td></tr></table></figure>

<p>truncate语句<strong>删除表中数据</strong>的原理</p>
<p>这种删除效率你较高，表被一次截断，物理删除</p>
<p><strong>缺点</strong>：不支持回滚，删除了无法恢复。</p>
<p><strong>优点</strong>：删除快速。</p>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>这个<strong>并不常用</strong></p>
<p>第一：在实际的开发中，需求一旦确定后，表一旦设计后，很少进行表结构的修改，因为开发过程中，修改表结构的成本会很高，修改了表，同时就需要修改大量的java代码。</p>
<p>第二：由于修改表的结构很少，所以我们不需要掌握，如果非要更改，直接使用工具比如Navicat来改就行了，更改表结构的操作也不会写在java代码中。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(九):数据库设计与实践</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E4%B9%9D%EF%BC%89%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-九）-数据库设计与实践"><a href="#MySQL知识回顾-九）-数据库设计与实践" class="headerlink" title="MySQL知识回顾(九）: 数据库设计与实践"></a>MySQL知识回顾(九）: 数据库设计与实践</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><strong>数据库设计三范式是重点内容，面试经常问</strong></p>
<h3 id="什么是设计范式？"><a href="#什么是设计范式？" class="headerlink" title="什么是设计范式？"></a><strong>什么是设计范式？</strong></h3><p><strong>设计表的依据</strong>。按照这个三范式设计的表不会出现<strong>数据冗余</strong>。</p>
<h3 id="三范式都是哪些？"><a href="#三范式都是哪些？" class="headerlink" title="三范式都是哪些？"></a>三范式都是哪些？</h3><p><strong>第一范式</strong>：<strong>任何一张表都应该有主键，并且每一个字段原子性不可再分。</strong></p>
<p><strong>第二范式</strong>：<strong>建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。</strong><br><strong>口诀：多对多？三张表，关系表两个外键。！！！背下来</strong>**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**t_student学生表：**</span><br><span class="line">sno(pk)	       sname</span><br><span class="line">-------------------</span><br><span class="line">1				张三</span><br><span class="line">2				李四</span><br><span class="line">3				王五</span><br><span class="line"></span><br><span class="line">t_teacher 讲师表</span><br><span class="line">tno(pk)		    tname</span><br><span class="line">---------------------</span><br><span class="line">1				王老师</span><br><span class="line">2				张老师</span><br><span class="line">3				李老师</span><br><span class="line"></span><br><span class="line">t_student_teacher_relation 学生讲师关系表</span><br><span class="line">id(pk)		sno(fk)		    tno(fk)</span><br><span class="line">----------------------------------</span><br><span class="line">1				1				3</span><br><span class="line">2				1				1</span><br><span class="line">3				2				2</span><br><span class="line">4				2				3</span><br><span class="line">5				3				1</span><br><span class="line">6				3				3</span><br></pre></td></tr></table></figure>

<p><strong>第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</strong><br><strong>口诀：一对多？两张表，多的表加外键。！！！背下来</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">班级t_class：</span><br><span class="line">cno(pk)			   cname</span><br><span class="line">--------------------------</span><br><span class="line">1					班级1</span><br><span class="line">2					班级2</span><br><span class="line">学生t_student</span><br><span class="line">sno(pk)			sname		classno(fk)</span><br><span class="line">---------------------------------------------</span><br><span class="line">101				张1				1</span><br><span class="line">102				张2				1</span><br><span class="line">103				张3				2</span><br><span class="line">104				张4				2</span><br><span class="line">105				张5				2</span><br></pre></td></tr></table></figure>

<p><strong>提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。</strong></p>
<h3 id="一对一怎么设计？"><a href="#一对一怎么设计？" class="headerlink" title="一对一怎么设计？"></a>一对一怎么设计？</h3><h4 id="主键共享"><a href="#主键共享" class="headerlink" title="主键共享"></a>主键共享</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t_user_login  用户登录表</span><br><span class="line">id(pk)		 username			password</span><br><span class="line">--------------------------------------</span><br><span class="line">1				zs					123</span><br><span class="line">2				ls					456</span><br><span class="line"></span><br><span class="line">t_user_detail 用户详细信息表</span><br><span class="line">id(pk+fk)	realname			tel			....</span><br><span class="line">------------------------------------------------</span><br><span class="line">1				张三				1111111111</span><br><span class="line">2				李四				1111415621</span><br></pre></td></tr></table></figure>

<h4 id="外键唯一"><a href="#外键唯一" class="headerlink" title="外键唯一"></a>外键唯一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**t_user_login  用户登录表**</span><br><span class="line">id(pk)		username			password</span><br><span class="line">----------------------------------------</span><br><span class="line">1			  zs				  123</span><br><span class="line">2			  ls			      456</span><br><span class="line">t_user_detail 用户详细信息表</span><br><span class="line">id(pk)	   realname			tel				userid(fk+unique)....</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">1				张三		1111111111		      2</span><br><span class="line">2				李四		1111415621		      1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(七):视图</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E4%B8%83%EF%BC%89%20%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-七）-视图"><a href="#MySQL知识回顾-七）-视图" class="headerlink" title="MySQL知识回顾(七）: 视图"></a>MySQL知识回顾(七）: 视图</h1><p>视图比较简单，内容不多，简单做个笔记吧emm</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>视图，view，<strong>站在不同的角度去看待同一份数据，也就是一张表。</strong></p>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p><code>create view 视图名 as select ...;</code></p>
<p><strong>注意：只有DQL语句才能以view形式创建。</strong></p>
<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><p><code>drop view 视图名;</code></p>
<h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><ul>
<li>我们可以面向视图对象的增删改查，对视图对象的增删改查，会导致原表也被操作。</li>
<li><strong>简化sql语句</strong>，可以把一个很长的select语句，就可以封装成一个视图对象，后序只用调用这个对象即可，大大减少了sql语句量，并且也<strong>易于后期的维护</strong>，只用修改视图语句就行。</li>
</ul>
<h2 id="视图的特点"><a href="#视图的特点" class="headerlink" title="视图的特点"></a>视图的特点</h2><ul>
<li><p>通过对视图的操作会影响到原表数据。</p>
</li>
<li><p>我们以后面向视图开发的时候，使用视图的时候可以像使用table一样，可以对视图进行增删改查等操作。</p>
</li>
<li><p>视图不是在内存中的，视图对象也是存储在硬盘上的，不会消失。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(二):DQL</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E4%BA%8C%EF%BC%89%20DQL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-二）-DQL"><a href="#MySQL知识回顾-二）-DQL" class="headerlink" title="MySQL知识回顾(二）: DQL"></a>MySQL知识回顾(二）: DQL</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>查询中<strong>最重要</strong>的是连接查询，多表联合起来查询</p>
<h3 id="连接查询的分类"><a href="#连接查询的分类" class="headerlink" title="连接查询的分类"></a><strong>连接查询的分类</strong></h3><ul>
<li>SQL92： 1992年的时候出现的语法</li>
<li><strong>SQL99</strong>： 1999年的时候出现的语法</li>
</ul>
<p>主要学习<strong>SQL99</strong></p>
<p><strong>根据表连接的方式分类</strong></p>
<ul>
<li><p><strong>内连接</strong></p>
<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
<li><p><strong>外连接</strong></p>
<ul>
<li>左外连接（左连接）</li>
<li>右外连接（右连接）</li>
</ul>
</li>
<li><p>全连接</p>
</li>
</ul>
<h3 id="笛卡尔积现象"><a href="#笛卡尔积现象" class="headerlink" title="笛卡尔积现象"></a>笛卡尔积现象</h3><p>两个表连接查询，采取笛卡尔积的匹配方式。</p>
<p>笛卡尔现象说明，表的连接次数越多，效率越低.</p>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><h3 id="内连接之等值连接"><a href="#内连接之等值连接" class="headerlink" title="内连接之等值连接"></a>内连接之等值连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#SQL92语法</span><br><span class="line">select 字段1,字段2 </span><br><span class="line">from 表a,表b </span><br><span class="line">where 表a.字段 = 表b.字段 and 其他查询条件;</span><br><span class="line"></span><br><span class="line">#SQL99语法: (inner) join...on...:inner可以省略，带上可读性更好</span><br><span class="line">select 字段1,字段2 </span><br><span class="line">from 表a</span><br><span class="line">(inner) join 表b </span><br><span class="line">on 表a.字段 = 表b.字段 #条件是等值关系，所以叫等值连接</span><br><span class="line">where 其他查询条件;</span><br></pre></td></tr></table></figure>

<p><strong>SQL92的缺点</strong>：结构不清晰，表的连接条件和后期进一步筛选的条件都糅杂在了一起。</p>
<h3 id="内连接之非等值连接"><a href="#内连接之非等值连接" class="headerlink" title="内连接之非等值连接"></a>内连接之非等值连接</h3><p>语法跟等值连接一样，只不过条件不是一个等值关系。</p>
<h3 id="内连接之自连接"><a href="#内连接之自连接" class="headerlink" title="内连接之自连接"></a>内连接之自连接</h3><p>一张表看成两张表，就豁然开朗了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a1.字段，a2.字段</span><br><span class="line">from 表a a1</span><br><span class="line">(inner) join 表a a2 #看成两个表就行了，其他的跟两个表连接查询方式一样</span><br><span class="line">on a1.字段 = a2.字段</span><br><span class="line">where 其他查询条件;</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#right (outer) join：outer可以省略，带上可读性更强</span><br><span class="line">select 字段1,字段2 </span><br><span class="line">from 表a</span><br><span class="line">right join 表b </span><br><span class="line">on 表a.字段 = 表b.字段 #除了查询</span><br><span class="line">where 其他查询条件;</span><br></pre></td></tr></table></figure>

<p><strong>right</strong>：表示join右边的表为主表，是为了在查询这张主表全部数据查出来的同时，捎带着关联查询一下左边的表，即查询结果主表包含了所有字段，没有跟字段匹配的左边表的数据显示为NULL。</p>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#right (outer) join</span><br><span class="line">select 字段1,字段2 </span><br><span class="line">from 表a</span><br><span class="line">left join 表b </span><br><span class="line">on 表a.字段 = 表b.字段 #除了查询</span><br><span class="line">where 其他查询条件;</span><br></pre></td></tr></table></figure>

<p>同理，<strong>left</strong>：表示join左边的表为主表，是为了在查询这张主表全部数据查出来的同时，捎带着关联查询一下右边的表，即查询结果主表包含了所有字段，没有跟字段匹配的右边表的数据显示为NULL。</p>
<p>总结</p>
<p><strong>在外连接中，两张表产生了主次关系，而内连接两张表是平等的，没有主次关系</strong>。</p>
<p>思考一下，可得出来：<strong>外连接查询出来的条数&gt;&#x3D;内连接查询出来的条数</strong></p>
<p><strong>全连接</strong>在这里就不过多记录了。要用直接百度吧emmm</p>
<h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><p>多表怎么连接查询呢？其实语法也是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ...</span><br><span class="line">from a</span><br><span class="line">join b</span><br><span class="line">on a和b的连接条件</span><br><span class="line">join c</span><br><span class="line">on a和c的连接条件</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>就是select语句里面嵌套select语句，<strong>被嵌套的select语句称为子查询</strong></p>
<p>子查询可以出现的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">...(select...)</span><br><span class="line">from</span><br><span class="line">...(select...)</span><br><span class="line">where</span><br><span class="line">...(select...)</span><br></pre></td></tr></table></figure>

<h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p>合并查询结果集合</p>
<p>其实不用Union也可以通过连接查询实现，但Union效率更高，连接一次，满足笛卡尔积翻倍时间，一看就知道效率了吧emmm，Union可以减少匹配的次数，在减少匹配次数的情况下，还可以完成两个结果集的拼接。</p>
<p>等于说Union将匹配次数的乘法变成了加法，当数据量大的时候，就可以看到明显的差别。</p>
<p>注意：</p>
<p>Union在进行结果集合并的时候，要求两个结果集的列数相同就行了，但是在Oracle里，还需要列的数据类型相同才行。</p>
<h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>很重要，用来展示查询的部分数据，在实际应用中常用作分页显示。</p>
<p>limit在查询结果最后执行，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit StartIndex,Datalength #StartIndex省略，代表从头开始找，Datalength包含StartIndex那一个元素</span><br></pre></td></tr></table></figure>

<p>分页</p>
<p>eg：每页显示3条记录</p>
<p>第1页： limit 0,3      [0,1,2]</p>
<p>第2页： limit 3,3      [3,4,5]</p>
<p>第3页： limit 6,3      [6,7,8]</p>
<p>第4页： limit 9,3      [9,10,11]</p>
<p>观察可以得到一些规律：</p>
<p>假如咱们每页显示 pageSize 条记录</p>
<p>​    *<em>第 pageNo 页为： limit (pageNo-1)<em>pageSzie ， pageSize</em></em></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(五):存储引擎</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E4%BA%94%EF%BC%89%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-五）-存储引擎"><a href="#MySQL知识回顾-五）-存储引擎" class="headerlink" title="MySQL知识回顾(五）: 存储引擎"></a>MySQL知识回顾(五）: 存储引擎</h1><h2 id="存储引擎（了解内容）"><a href="#存储引擎（了解内容）" class="headerlink" title="存储引擎（了解内容）"></a>存储引擎（<strong>了解内容</strong>）</h2><h3 id="什么是存储引擎，有什么用？"><a href="#什么是存储引擎，有什么用？" class="headerlink" title="什么是存储引擎，有什么用？"></a>什么是存储引擎，有什么用？</h3><p><strong>存储引擎</strong>，是MySQL中特有的一个术语，但其他数据库没有（Oracle有，但不叫这个名字）</p>
<p>实际上存储引擎是一个 <strong>表存储&#x2F;组织数据</strong> 的方式。</p>
<p>不同的存储引擎，表存储数据的方式不同。</p>
<h3 id="怎么给表指定存储引擎呢？"><a href="#怎么给表指定存储引擎呢？" class="headerlink" title="怎么给表指定存储引擎呢？"></a>怎么给表指定存储引擎呢？</h3><p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/image-20220418202919031.png" alt="image-20220418202919031"></p>
<p>可以在建表的时候给表指定。</p>
<ul>
<li><strong>ENGINE</strong>  来指定存储引擎，默认InnoDB</li>
<li><strong>CHARSET</strong>  来指定这张表的字符编码方式,默认utf8</li>
</ul>
<h3 id="MySQL支持哪些存储引擎"><a href="#MySQL支持哪些存储引擎" class="headerlink" title="MySQL支持哪些存储引擎"></a>MySQL支持哪些存储引擎</h3><p><strong>命令 查看</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines \G</span><br></pre></td></tr></table></figure>

<h3 id="常见的存储引擎"><a href="#常见的存储引擎" class="headerlink" title="常见的存储引擎"></a>常见的存储引擎</h3><ul>
<li><strong>MyISAM</strong><ul>
<li><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/image-20220418203936883.png" alt="image-20220418203936883"></li>
</ul>
</li>
<li><strong>InnoDB</strong><ul>
<li><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/image-20220418204116239.png" alt="image-20220418204116239"></li>
</ul>
</li>
<li><strong>MEMORY</strong><ul>
<li><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/image-20220418204340557.png" alt="image-20220418204340557"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(八):DBA常用命令</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E5%85%AB%EF%BC%89%20DBA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-八）-DBA常用命令"><a href="#MySQL知识回顾-八）-DBA常用命令" class="headerlink" title="MySQL知识回顾(八）: DBA常用命令"></a>MySQL知识回顾(八）: DBA常用命令</h1><p>因为不从事DBA工作，不做过多了解了emm。</p>
<p><strong>重点掌握数据的导出导入（数据的备份）</strong></p>
<h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><p><strong>注意：是在windows的dos命令窗口中，是在为登录mysql情况下执行。</strong></p>
<h3 id="数据库整体导出"><a href="#数据库整体导出" class="headerlink" title="数据库整体导出"></a>数据库整体导出</h3><p><code>mysqldump 数据库名&gt;文件路径/文件名.sql -u用户名 -p密码;</code></p>
<h3 id="单个表导出"><a href="#单个表导出" class="headerlink" title="单个表导出"></a>单个表导出</h3><p><code>mysqldump 数据库名 表名&gt;文件路径/文件名.sql -u用户名 -p密码;</code></p>
<h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>注意：要先登录MySQL数据库。</p>
<ol>
<li>创建数据库</li>
<li>使用数据库</li>
<li>数据导入：<code>resource 文件路径/文件名.sql </code></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(六):事务</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E5%85%AD%EF%BC%89%20%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-六）-事务"><a href="#MySQL知识回顾-六）-事务" class="headerlink" title="MySQL知识回顾(六）: 事务"></a>MySQL知识回顾(六）: 事务</h1><p><strong>事务（重点，必须理解，必须掌握）</strong></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>一个事务其实就是一个完整的业务逻辑。</strong></p>
<p>举个很简单的例子来理解吧！</p>
<ul>
<li>假设转账，从A账户向B账户转账10000</li>
<li>将A账户的钱减去10000</li>
<li>将B账户的钱加上10000</li>
</ul>
<p>以上三个行为组成一个<strong>完整的业务逻辑</strong>，就是一个事务，是一个<strong>最小的工作单元</strong>，<strong>不可再分</strong>，要么同时成功，要么<strong>同时失败，不可再分</strong>！！不能存在前面执行成功后面执行失败的情况。</p>
<h2 id="跟事务相关的DML语句"><a href="#跟事务相关的DML语句" class="headerlink" title="跟事务相关的DML语句"></a>跟事务相关的DML语句</h2><ul>
<li><p>只有DML语句才有事务这么一说，其他的语句与事务无关.</p>
</li>
<li><p>只要你的操作一旦涉及到数据的增删改，那么就一定要考虑一下安全问题.</p>
</li>
<li><p>数据安全第一.</p>
</li>
</ul>
<h2 id="事务再理解"><a href="#事务再理解" class="headerlink" title="事务再理解"></a>事务再理解</h2><p>试想一下，如果一个业务，用一句DML代码就可以搞定，事务也就失去了意义。</p>
<p>说到<strong>本质</strong>上，一个事务就是多条DML语句同时成功或者同时失败！</p>
<h2 id="事务的执行流程"><a href="#事务的执行流程" class="headerlink" title="事务的执行流程"></a>事务的执行流程</h2><p>就拿之前说的存储引擎InnoDB举例子</p>
<p><strong>InnoDB</strong>：支持事务，提供了一组用来记录事务性活动的日志文件</p>
<p>事务 为 <strong>事务开启–&gt;执行事务—&gt;事务结束</strong> 这一个过程</p>
<p>在执行事务的过程中，实际上，执行的过程都被储存到了事务性活动的日志文件中，此时并没有真正执行，等事务语句全部储存到了事务性活动的日志文件后，可以选择 <strong>提交事务</strong> 和 <strong>回滚事务</strong> 。</p>
<ul>
<li><p><strong>提交事务</strong>：清空事务性活动的日志文件，并将数据全部彻底持久化到数据库中。也就代表着，事务结束了，是一种<strong>全部成功</strong>的结束，因为<strong>他是存到日志文件最后一次性全部执行的</strong>。</p>
</li>
<li><p><strong>回滚事务</strong>：将之前所有的DML操作全部撤销，也要清空日志文件。也代表着事务结束了，是一种<strong>全部失败</strong>的结束。</p>
</li>
</ul>
<h2 id="如何提交事务和回滚事务"><a href="#如何提交事务和回滚事务" class="headerlink" title="如何提交事务和回滚事务"></a>如何提交事务和回滚事务</h2><p><strong>提交事务</strong>: <strong><code>commit;</code></strong></p>
<p><strong>回滚事务</strong>：**<code>rollback;</code>** （回滚永远只能提交到上一次提交点）</p>
<p>MySQL默认情况下是支持<strong>自动提交事务</strong>的，每次执行一条DML，自动提交一次，<strong>等于说是一个DML相当于一个事务了</strong>，实际上根本就不符合业务逻辑，因为实际上一个业务是有多条DML语句共同完成的。这么说，我们回滚也没有用了，因为上次的已经提交了，回到上一次提交的位置，就等于说是当前位置了。。这种自动提交机制实际上是不符合我们实际开发习惯的。</p>
<p><strong>那么怎么关掉自动提交机制呢？</strong></p>
<p>先执行命令： <strong><code>start transaction;</code></strong>    在执行事务即可</p>
<h2 id="事务的特性ACID"><a href="#事务的特性ACID" class="headerlink" title="事务的特性ACID"></a>事务的特性ACID</h2><ul>
<li><p><strong>A： 原子性</strong></p>
<ul>
<li>说明事务是最小的工作单元，不可再分</li>
</ul>
</li>
<li><p><strong>C： 一致性</strong></p>
<ul>
<li>所有事物要求，在一个事务当中，要么同时成功，要么同时失败</li>
</ul>
</li>
<li><p><strong>I：  隔离性</strong>     </p>
<ul>
<li>A事务和B事务之间具有一定的隔离</li>
<li>像多线程并发访问同一张表一样</li>
</ul>
</li>
<li><p><strong>D：持久性</strong></p>
<ul>
<li>事务最终结束的一个保障，事务提交，就相当于把没有保存到硬盘上的数据保存在硬盘上。</li>
</ul>
</li>
</ul>
<h2 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h2><p><strong>打个比方</strong>：A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄，这就是事物的隔离级别。</p>
<p>这道墙越厚，表示隔离的级别就越高。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><h4 id="读未提交-read-uncommited-最低"><a href="#读未提交-read-uncommited-最低" class="headerlink" title="读未提交   read uncommited    (最低)"></a><strong>读未提交   read uncommited    (最低)</strong></h4><ul>
<li><strong>定义</strong>：事务A可以读取到事务B未提交的数据，就是<strong>没有提交就能读到</strong>，想想就不太合理。</li>
<li><strong>缺点：</strong>会出现脏读现象（在数据库技术中,脏数据在临时更新（<a href="https://baike.baidu.com/item/%E8%84%8F%E8%AF%BB">脏读</a>）中产生。事务A更新了某个数据项X，但是由于某种原因，事务A出现了问题，于是要把A回滚。但是在回滚之前，另一个事务B读取了数据项X的值(A更新后)，A回滚了事务，数据项恢复了原值。事务B读取的就是数据项X的就是一个“临时”的值，就是脏数据），也就是读到脏数据。</li>
<li>这种隔离级别一般都是理论上的，也就是很少人用，大多数据库都是二档起步。</li>
</ul>
<h4 id="读已提交-read-commited"><a href="#读已提交-read-commited" class="headerlink" title="读已提交   read commited"></a><strong>读已提交   read commited</strong></h4><ul>
<li><strong>定义</strong>：事务A只能读取到事务B提交后的数据，<strong>提交之后才能读到</strong>。</li>
<li><strong>优点</strong>：解决了脏读问题。</li>
<li><strong>缺点</strong>：不可重复读取数据</li>
<li>这种隔离级别是比较真实的数据，每一次读到的数据都<strong>绝对真实</strong>，因为是提交事务后读的，但由于事务的不断提交，每次读取到的数据不一样，就称为不可重复读取。</li>
<li>Oracle默认的隔离级别</li>
</ul>
<h4 id="可重复读-repeatable-read"><a href="#可重复读-repeatable-read" class="headerlink" title="可重复读   repeatable read"></a><strong>可重复读   repeatable read</strong></h4><ul>
<li><strong>定义</strong>：事务A开启之后，不管是多久，每一次在事务A中读到的数据都是一致的。及时事务B将数据修改，并且提交，事务A读到的也不会变，提交之后也读不到，只要事务A没结束，永远读取的都是刚开始事务A时读到的数据一样，是数据的幻想，简单理解就是，事务A开始，以及对数据做了一个备份，之后读的都是备份的数据，其他事务的提交不会影响事务A期间读到的数据。</li>
<li><strong>优点</strong>：解决了不可重复读的问题。</li>
<li><strong>缺点：</strong>数据不够绝对的真实。</li>
<li>MySQL默认的隔离级别</li>
</ul>
<h4 id="序列化-x2F-串行化-serializable-（最高）"><a href="#序列化-x2F-串行化-serializable-（最高）" class="headerlink" title="序列化&#x2F;串行化   serializable  （最高）"></a><strong>序列化&#x2F;串行化   serializable  （最高）</strong></h4><ul>
<li>事务同步</li>
<li><strong>优点</strong>：解决了所有问题，每次读到的数据都是绝对真实的数据，</li>
<li><strong>缺点</strong>：这种隔离级别表示事务排队，不能并发，效率是最低的。</li>
</ul>
<h2 id="可以验证各种隔离级别"><a href="#可以验证各种隔离级别" class="headerlink" title="可以验证各种隔离级别"></a>可以验证各种隔离级别</h2><p><strong>查看隔离级别：</strong><code>select @@tx_isolation;</code></p>
<p>eg：设置全局隔离级别为<strong>读未提交</strong>：<code>set global transaction isolation level read uncommited;  </code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识回顾(四):约束和索引</title>
    <url>/2022/04/19/MySQL%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE(%E5%9B%9B%EF%BC%89%20%E7%BA%A6%E6%9D%9F%E5%92%8C%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL知识回顾-四）-约束和索引"><a href="#MySQL知识回顾-四）-约束和索引" class="headerlink" title="MySQL知识回顾(四）: 约束和索引"></a>MySQL知识回顾(四）: 约束和索引</h1><h2 id="约束（Constraint）（重点）"><a href="#约束（Constraint）（重点）" class="headerlink" title="约束（Constraint）（重点）"></a>约束（Constraint）（<strong>重点</strong>）</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表数据的<strong>完整性，有效性</strong>。</p>
<h3 id="常见的约束"><a href="#常见的约束" class="headerlink" title="常见的约束"></a>常见的约束</h3><ul>
<li>非空约束 :    <strong>not null</strong> </li>
<li>主键约束 :    <strong>primary key</strong> (简称PK)</li>
<li>外键约束 :    <strong>foreign key</strong>  (简称FK)</li>
<li>检查约束:     <strong>check</strong> （mysql不支持，Oracle支持，暂不做了解）</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>在数据库的字段上添加的，是为了提高查询效率存在的一种机制。</p>
</li>
<li><p>一张表的一个字段可以添加一个索引，当然，多个字段联合起来可以添加索引。</p>
</li>
<li><p>索引相当于一个目录，是为了缩小扫描范围而存在的一种机制。</p>
</li>
</ul>
<h3 id="MySQL查询方式"><a href="#MySQL查询方式" class="headerlink" title="MySQL查询方式"></a>MySQL查询方式</h3><ul>
<li>全表扫描，就是逐个比对</li>
<li>根据索引检索</li>
</ul>
<h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/image-20220419212802992.png" alt="image-20220419212802992"></p>
<h3 id="索引用法"><a href="#索引用法" class="headerlink" title="索引用法"></a>索引用法</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><strong>用法</strong></p>
<p><code>create index 索引名 on 表名(字段名) </code></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><strong>用法</strong></p>
<p><code>drop index 索引名 on 表名 </code></p>
<h3 id="索引失效（了解内容）"><a href="#索引失效（了解内容）" class="headerlink" title="索引失效（了解内容）"></a>索引失效（了解内容）</h3><p>1.<strong>模糊查询中以’%’开始会导致索引失效,’%’开 始不会走索引</strong></p>
<p>eg. <code>select .. from .. where xxx like &#39;%xx&#39;;</code></p>
<p><strong>2.使用or的时候会失效，除非or的两边的条件字段都有索引，所以，尽量少用or也可以起到优化查询效率，可以用Union替代之。</strong></p>
<p><strong>3.使用复合索引的时候，没有使用左侧的列查找，索引失效</strong></p>
<p>**eg.**创建索引: <code>create index 索引名 on 表名(字段名1,字段2); </code></p>
<p>​                      <code>select * from 表名 where 字段1 = xxx;</code> ：索引生效</p>
<pre><code>                  `select * from 表名 where 字段2 = xxx;` ：索引失效
</code></pre>
<p> <strong>4.索引列参加了运算，索引失效。</strong></p>
<p>eg.  <code>select * from 表名 where 索引字段 + 1 = xxx;</code> </p>
<p><strong>5.在where当中，索引列使用了函数，索引失效。</strong></p>
<p>eg.  <code>select * from 表名 where lower(索引字段) = xxx;</code> </p>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul>
<li><strong>单一索引</strong>： 一个字段添加索引。</li>
<li><strong>复合索引</strong>： 两个或两个以上字段添加索引。</li>
<li><strong>主键索引</strong>： 主键上添加索引</li>
<li><strong>唯一性索引</strong>： 具有unique约束的字段上添加索引</li>
<li>…</li>
</ul>
<p><strong>注意: 唯一性比较弱的字段上添加索引用处不大。</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2022/06/26/RabbitMQ/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><blockquote>
<p>普通的业务场景，咱们客户端发送一个请求，后端需要经过Controller–&gt;Service–&gt;Dao等一系列流水作业，是一个同步的过程，咱们需要一步步进行，当然，每一步需要耗费时间，让用户等待过多的时间一种不好的体验。</p>
</blockquote>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261309858.png" alt="image-20220626130725269"></p>
<p>那么我们优化一下：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261452973.png" alt="image-20220626145215910"></p>
<p><em><strong>这样，让不相干的业务异步执行一下，可以适当缩短时间，从之前的150ms缩短到了100ms，但好像还是挺久的，有没有什么办法可以解决呢？</strong></em></p>
<blockquote>
<p>有一些业务，比如发送<strong>验证码，邮件</strong>等，用户不需要等待后端完全完成发送后才知道，而是发送请求的那一刻，后端接收到请求后便可以直接返回给客户端一个信号（发送成功了），接下来的事，留给后端自己去做就行了，从而减少了客户的等待时间，那么，消息队列就应运而生了，咱们可以把消息写到消息队列中，其他服务主动的去消费这个队列中的信息来执行业务，<strong>客户端生产消息，服务端监听并且消费消息</strong>的过程。</p>
</blockquote>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261315070.png" alt="image-20220626131531987"></p>
<h2 id="消息队列的优点"><a href="#消息队列的优点" class="headerlink" title="消息队列的优点"></a>消息队列的优点</h2><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><blockquote>
<p>传统的业务中，一个系统跟另一个系统之间通过调用函数等方式来互相交互，耦合度很高。</p>
</blockquote>
<p>举个例子：服务A调用了服务B的一个方法，但是，某一天，服务B的这个方法发生了迭代，传参变化了，咱们是不是还得下线一下服务A把对应的调用方法参数变化一下再重新上线呢？损失了时间和维护成本。</p>
<p><strong>消息队列</strong>就可以很好的解决这个问题，服务A可以把调用的消息发送到消息队列，也就只是发送一下”<strong>我需要调用服务B的方法</strong>“，并不需要像之前那样严格的调用方法，服务B的特定方法<strong>监听</strong>到了消息，就会主动调用自己的方法了，那么服务B的迭代就跟A没有强耦合了，因为添加了消息中间件。这就是解耦合的思想。</p>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><blockquote>
<p>在一些高峰期，服务器某时刻可能突然承受很大的并发导致服务器崩溃甚至宕机，那么消息队列可以很好的缓解高并发带来的服务器压力过大。</p>
</blockquote>
<p>高并发量到来时，这些请求会优先储存到消息队列中，然后服务器会根据自己的能力来在队列中读取这些请求并处理而不是一口气接收了所有请求，起到了一个哼好的缓冲作用。</p>
<h2 id="两个重要概念"><a href="#两个重要概念" class="headerlink" title="两个重要概念"></a>两个重要概念</h2><ul>
<li><p><strong>消息代理（message broker）</strong>：<strong>消息生产者</strong>发送消息后，优先发送到<strong>消息代理</strong>，消息代理再通过<strong>交换机</strong>（Exchange）发送到对应<strong>绑定</strong>（Binding）的<strong>队列</strong>（Queue）。</p>
</li>
<li><p><strong>目的地（destination）</strong>：消息传递到指定目的地。(目的地分为两种形式)</p>
<ul>
<li><p><strong>队列</strong>：<strong>点对点消息通信</strong>:</p>
<ul>
<li><p><strong>消息发送者</strong>发送消息，消息代理将其放入一个队列中，消息接收者从队列中获 </p>
<p>取消息内容，消息读取后被移出队列。</p>
<p><strong>消息只有唯一的发送者和接受者，但并不是说只能有一个接收者</strong></p>
</li>
</ul>
</li>
<li><p><strong>主题</strong>：<strong>发布（subscribe）&#x2F;订阅（subscribe）消息通信</strong>:</p>
<ul>
<li><p><strong>发送者</strong>（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个 </p>
<p>主题，那么就会在消息到达时同时收到消息。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JMS和AMQP"><a href="#JMS和AMQP" class="headerlink" title="JMS和AMQP"></a>JMS和AMQP</h2><ul>
<li><p><strong>JMS</strong>（Java Message Service):<strong>JAVA消息服务</strong>： 基于<strong>JVM</strong>消息代理的规范。ActiveMQ、HornetMQ是JMS实现.</p>
</li>
<li><p><strong>AMQP</strong>（Advanced Message Queuing Protocol） <strong>高级消息队列协议</strong>，也是一个<strong>消息代理的规范</strong>，<strong>兼容JMS</strong>,RabbitMQ是AMQP的实现.</p>
</li>
</ul>
<p>两者的对比如下表：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261335305.png" alt="image-20220626133526175"></p>
<p>Spring提供了对JMS和AMQP的支持，很方便，SpringBoot也包含了对两者的自动配置。</p>
<h2 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p><strong>RabbitMQ</strong>是一个由<strong>erlang</strong>开发的<strong>AMQP</strong>(Advanved Message Queue Protocol)的开源实现。</p>
</blockquote>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li><p><strong>Message</strong>：<strong>消息</strong>，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成， </p>
<p>这些属性包括<strong>routing-key</strong>（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可 </p>
<p>能需要持久性存储）等。 </p>
</li>
<li><p><strong>Publisher</strong>：<strong>消息的生产者</strong>，就是向消息代理发送消息的客户端应用程序。</p>
</li>
<li><p><strong>Exchange</strong>：<strong>交换器</strong>，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>Exchange有4种类型：<strong>direct(默认)，fanout, topic, 和headers</strong>，不同类型的Exchange转发消息的策略有所区别。</p>
</li>
<li><p><strong>Queue</strong>：<strong>消息队列</strong>，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直 在队列里面，等待消费者连接到这个队列将其取走。</p>
</li>
<li><p><strong>Binding</strong>：<strong>绑定</strong>，用于<strong>消息队列和交换器</strong>之间的关联。一个绑定就是基于<strong>路由键</strong>（routing-key）将交换器和消息队列连接起来的路由规则，所以可以将交 换器理解成一个由绑定构成的路由表。<br>Exchange 和Queue的绑定可以是多对多的关系。</p>
</li>
<li><p><strong>Connection</strong>：网络<strong>连接</strong>，比如一个TCP连接。</p>
</li>
<li><p><strong>Channel</strong>：<strong>信道</strong>，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道 发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都 是非常昂贵的开销，所以引入了信道的概念，以复用<strong>一条 TCP 连接</strong>。</p>
</li>
</ul>
<p>​    注意：<strong>一条</strong>连接中开辟<strong>多条</strong>信道来交互消息。</p>
<ul>
<li><p><strong>Consumer</strong>：消息的<strong>消费者</strong>，表示一个从消息队列中取得消息的客户端应用程序。</p>
</li>
<li><p><strong>Virtual Host</strong>：<strong>虚拟主机</strong>，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加 密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥 有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时 指定，RabbitMQ 默认的 vhost 是 &#x2F; 。</p>
</li>
<li><p><strong>Broker</strong>：表示消息队列<strong>服务器实体</strong>。（消息代理）</p>
<p>关系图：</p>
</li>
</ul>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261346957.png" alt="image-20220626134630894"></p>
<h3 id="Docker启动RabbitMQ"><a href="#Docker启动RabbitMQ" class="headerlink" title="Docker启动RabbitMQ"></a>Docker启动RabbitMQ</h3><blockquote>
<p>直接在<strong>Docker Hub</strong>上找到对应的<strong>RabbitMQ</strong>镜像拉取，十分方便。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d </span><br><span class="line">--name rabbitmq </span><br><span class="line">-p 5671:5671 </span><br><span class="line">-p 5672:5672 </span><br><span class="line">-p 4369:4369 </span><br><span class="line">-p 25672:25672 </span><br><span class="line">-p 15671:15671 </span><br><span class="line">-p 15672:15672 </span><br><span class="line">rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>端口说明：</p>
<ul>
<li>4369, 25672 (Erlang发现&amp;集群端口)</li>
<li>5672, 5671 (AMQP端口)</li>
<li>15672 (web管理后台端口)</li>
<li>61613, 61614 (STOMP协议端口)</li>
<li>1883, 8883 (MQTT协议端口)</li>
</ul>
<p>拉去后直接访问<strong>15672</strong>端口，也就是后台管理端口，就可以看到RabbitMQ的<strong>后台管理页面</strong>了。</p>
<h3 id="AMQP的消息路由"><a href="#AMQP的消息路由" class="headerlink" title="AMQP的消息路由"></a>AMQP的消息路由</h3><blockquote>
<p><strong>AMQP</strong>中增加了<strong>Exchange</strong>和<strong>Binding</strong>的角色。生产者把消息发布到Exchange上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到哪个队列。</p>
</blockquote>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261352115.png" alt="image-20220626135226999"></p>
<h3 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h3><blockquote>
<p><strong>Exchange</strong>分发消息时根据类型的不同<strong>分发策略</strong>有区别，目前共四种类型：<strong>direct、fanout、topic、headers</strong> 。headers 匹配 AMQP 消息的 header 而不是路由键，headers交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了。</p>
</blockquote>
<p>下面由四个图，就可以很清楚看出来区别了：</p>
<ul>
<li><strong>Direct</strong>：消息中的路由键（<strong>routing key</strong>）如果和Binding中的<strong>binding key</strong>一致， 交换器 就将消息发到对应的队列中。路由键与队 列名完全匹配，如果一个队列绑定到交换机要求<strong>路由键</strong>为“dog”，则<strong>只</strong>转发routing key标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是<strong>完全匹配、单播</strong>的模式。</li>
</ul>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261355893.png" alt="image-20220626135515829"></p>
<ul>
<li><p><strong>Fanout</strong>：每个发到 <strong>fanout</strong> 类型交换器的消息都 会分到所有绑定的队列上去。fanout 交 换器不处理路由键，只是简单的将队列 绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内 的主机都获得了一份复制的消息。</p>
<p><strong>注意：因为Fanout实际上不需要处理路由键匹配的问题，那么它转发消息是最快的。</strong></p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261357527.png" alt="image-20220626135717458"></p>
</li>
<li><p><strong>Topic</strong>：topic 交换器通过模式匹配分配消息的 路由键属性，将路由键和某个模式进行<br>匹配，此时队列需要绑定到一个模式上。 它将<strong>路由键和绑定键的字符串切分成单词</strong>，这些单词之间用<strong>点</strong>隔开。它同样也会识别两个通配符：<strong>符号“#”和符号“”。#匹配0个或多个单词，“*”只匹配一个单词。</strong></p>
</li>
</ul>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261359392.png" alt="image-20220626135906324"></p>
<h3 id="SpringBoot测试RabbitMQ"><a href="#SpringBoot测试RabbitMQ" class="headerlink" title="SpringBoot测试RabbitMQ"></a>SpringBoot测试RabbitMQ</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">自己的主机ip地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h4><blockquote>
<p>因为发送的消息如果是<strong>对象</strong>，会使用默认JDK序列化机制，也就是发送的类需要实现serelizable，序列化成流数据，存储起来读取不太容易，我们就需要自己配置一个序列化器，让他转化成<strong>Json</strong>类型数据传输。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向容器中添加一个消息转换器，就会使用咱们的</span></span><br><span class="line"><span class="comment">     * 配置自己的消息转换器（object-&gt;json）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="EnableRabbit"><a href="#EnableRabbit" class="headerlink" title="@EnableRabbit"></a>@EnableRabbit</h4><blockquote>
<p>开启RabbitMQ的作用。</p>
</blockquote>
<h4 id="重要的组件"><a href="#重要的组件" class="headerlink" title="重要的组件"></a>重要的组件</h4><ul>
<li><p><strong>AmqpAdmin</strong>：<strong>管理组件</strong>（包括创建删除交换机，绑定，队列等）。</p>
</li>
<li><p><strong>RabbitTemplate</strong>：<strong>消息发送</strong>处理组件。</p>
</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="创建交换机"><a href="#创建交换机" class="headerlink" title="创建交换机"></a>创建交换机</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.使用AmqpAdmin创建一个Direct类型的交换机</span></span><br><span class="line">    <span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;hello-java-exchange&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    amqpAdmin.declareExchange(directExchange);</span><br><span class="line">    log.info(<span class="string">&quot;exchange[&#123;&#125;]创建成功&quot;</span>,<span class="string">&quot;hello-java-exchange&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261412850.png" alt="image-20220626141216050"></p>
<h5 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;hello-java-queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    amqpAdmin.declareQueue(queue);</span><br><span class="line">    log.info(<span class="string">&quot;exchange[&#123;&#125;]创建成功&quot;</span>,<span class="string">&quot;hello-java-queue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261412092.png" alt="image-20220626141249016"></p>
<h5 id="创建绑定"><a href="#创建绑定" class="headerlink" title="创建绑定"></a>创建绑定</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBinding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;hello-java-queue&quot;</span>,  <span class="comment">//绑定的队列名字</span></span><br><span class="line">            Binding.DestinationType.QUEUE,             <span class="comment">//被绑定的对象：可以是队列或者交换机</span></span><br><span class="line">            <span class="string">&quot;hello-java-exchange&quot;</span>, <span class="comment">//绑定的交换机名字</span></span><br><span class="line">            <span class="string">&quot;hello.java&quot;</span>,          <span class="comment">//绑定的路由键</span></span><br><span class="line">            <span class="literal">null</span>);                 <span class="comment">//队列中的初始参数</span></span><br><span class="line">    amqpAdmin.declareBinding(binding);</span><br><span class="line">    log.info(<span class="string">&quot;binding[&#123;&#125;]创建成功&quot;</span>,<span class="string">&quot;hello-java-binding&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261413407.png" alt="image-20220626141313366"></p>
<h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sendMessageTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 发送消息,如果发送的是对象，会采用序列化机制，需是实现serelizable</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello world--&quot;</span>+i;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;hello-java-exchange&quot;</span>, <span class="comment">//发送给的交换机</span></span><br><span class="line">                                      <span class="string">&quot;hello.java&quot;</span>,   <span class="comment">//使用的路由键</span></span><br><span class="line">                                      msg);</span><br><span class="line">        log.info(<span class="string">&quot;消息发送完成&#123;&#125;&quot;</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送后就可以在队列中看到发送到的消息。</p>
<h5 id="消费者监听消息"><a href="#消费者监听消息" class="headerlink" title="消费者监听消息"></a>消费者监听消息</h5><h6 id="RabbitListener"><a href="#RabbitListener" class="headerlink" title="@RabbitListener"></a>@RabbitListener</h6><blockquote>
<p>可以用在<strong>类+方法</strong>上，<strong>但一般用在类上</strong>，说明要监听哪个队列的消息。</p>
</blockquote>
<h6 id="RabbitHandler"><a href="#RabbitHandler" class="headerlink" title="@RabbitHandler"></a>@RabbitHandler</h6><blockquote>
<p>只能用在<strong>方法上</strong>，<strong>重载</strong>接收不同的消息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;orderItemService&quot;)</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;hello-java-queue&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItemServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderItemDao, OrderItemEntity&gt; <span class="keyword">implements</span> <span class="title class_">OrderItemService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * queues：声明要监听的queue</span></span><br><span class="line"><span class="comment">     * 参数可以写成一下类型</span></span><br><span class="line"><span class="comment">     * 1.Message message:原生消息信息：头+体</span></span><br><span class="line"><span class="comment">     * 2.消息体：String content：泛型</span></span><br><span class="line"><span class="comment">     * 3.Channel channel: 当前传输数据的通道</span></span><br><span class="line"><span class="comment">     * Queue: 可以很多人都来监听，但最后只能有一个人收到，收到后Queue消息删除</span></span><br><span class="line"><span class="comment">     * 场景：</span></span><br><span class="line"><span class="comment">     *    1） 订单服务启动多个，同一个消息只能被一个客户端收到</span></span><br><span class="line"><span class="comment">     *    2） 只能有一个消息接收处理完才能处理下一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(Message message, String content, Channel channel)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+message+<span class="string">&quot;---&gt;内容：&quot;</span>+content);</span><br><span class="line">        <span class="comment">//获取消息体</span></span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="comment">//获取消息头</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> message.getMessageProperties();</span><br><span class="line">        System.out.println(<span class="string">&quot;消息处理完成--&gt;&quot;</span>+content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消息确认机制-可靠抵达"><a href="#消息确认机制-可靠抵达" class="headerlink" title="消息确认机制-可靠抵达"></a>消息确认机制-可靠抵达</h4><blockquote>
<p>当<strong>生产者产生消息并发送给消息队列后，消息先到达Broker中的交换机，交换机再通过绑定传递个队列，队列再交互到相应的服务来处理</strong>，那么如何确认消息在这一系列传递中是顺利进行而没有丢失呢？我们就引入了<strong>消息确认机制</strong>。</p>
</blockquote>
<p><strong>生产者端</strong>：我们有两个回调：</p>
<ul>
<li><strong>confirmCallback</strong>：确认模式，就是消息<strong>顺利到达</strong>交换机后的回调。</li>
<li><strong>returnBack</strong>：退回模式，就是消息<strong>未能顺利</strong>到达queue的回调。（顺利就不会回调）</li>
</ul>
<p>消费者端：</p>
<ul>
<li><p><strong>ack机制</strong>：就是消费者是否接收到消息并顺利处理的回调。</p>
<p><strong>注意：RabbitMQ中默认的ack模式是当消息被消费者接收后，相应队列中的消息会从Ready状态转化为Unacked状态，当消息处理成功后，队列中的消息会被自动清除。</strong>但是自动的ack有一个<strong>弊端</strong>：当接收消息的消费者端在处理消息的过程中途宕机，队列中处理的和未处理的所有消息都会被一并清除。</p>
</li>
</ul>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202206261422190.png" alt="image-20220626142232136"></p>
<h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.226</span><span class="number">.130</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span>   <span class="comment">#开启消息抵达broker确认</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span>  <span class="comment">#开启消息抵达队列确认</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span>  <span class="comment">#只要消息抵达队列,以异步方式优先回调这returnConFirm</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment">#手动ack消息，而不是我们之前说的自动ack</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义配置-1"><a href="#自定义配置-1" class="headerlink" title="自定义配置"></a>自定义配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置自己的消息传唤器（object-&gt;json）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制RabbitTemplate</span></span><br><span class="line"><span class="comment">     * 1.服务器收到消息就回调ConfirmCallback</span></span><br><span class="line"><span class="comment">     *   1)publisher-confirm-type: correlated</span></span><br><span class="line"><span class="comment">     *   2)设置确认回调</span></span><br><span class="line"><span class="comment">     * 2.消息抵达队列的回调  ReturnCallback</span></span><br><span class="line"><span class="comment">     *   1)    publisher-returns: true  #开启消息抵达队列确认</span></span><br><span class="line"><span class="comment">     *         template.mandatory: true #只要消息抵达队列,以异步方式优先回调这returnConFirm</span></span><br><span class="line"><span class="comment">     *   2)配置</span></span><br><span class="line"><span class="comment">     * 3.消费端确认(保证每个消息被正常消费,此时才可以broker删除消息)  acknowledge-mode: manual #手动ack消息</span></span><br><span class="line"><span class="comment">     *   1)默认是自动确认的,只要消息接收到,客户端会自动确认,服务端就会移除消息</span></span><br><span class="line"><span class="comment">     *      问题:收到了对应queue中的消息,自动回复给服务器ack,但只有一个消息处理成功宕机,其他消息都会被删除丢失</span></span><br><span class="line"><span class="comment">     *      解决办法:手动确认(消费者货物不丢):只要我们没有明确告诉MQ货物被签收,我们就没有ack,消息一直是unacked状态,即使Consumer宕机,</span></span><br><span class="line"><span class="comment">     *      消息也不会丢失,会重新变为Ready,下一次有新的Consumer连接进来就发给他</span></span><br><span class="line"><span class="comment">     *   2)如何签收:channel.basicAck(deliveryTag, false);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//注解解释：对象MyRabbitConfig初始化对象完成后调用这个方法,定制我们的template</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 只要消息抵达broker,就返回true</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> correlationData: 当前消息的唯一关联数据(消息的唯一id)</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> ack 消息是否成功收到</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> cause 失败的原因</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;confirm...correlationData[&quot;</span>+correlationData+<span class="string">&quot;]==&gt;ack[&quot;</span>+ack+<span class="string">&quot;]==&gt;cause[&quot;</span>+cause+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置消息抵达队列的确认回调</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *只有抵达失败:才回调</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> returnedMessage 回复的消息封装</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">                System.out.println(returnedMessage.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="手动ACK"><a href="#手动ACK" class="headerlink" title="手动ACK"></a>手动ACK</h5><blockquote>
<p>我们需要使用channel.basicAck来手动”收货”。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;hello-java-queue&quot;&#125;)</span>   <span class="comment">//监听hello-java-queue队列中的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(Message message, String content, Channel channel)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+message+<span class="string">&quot;---&gt;内容：&quot;</span>+content);</span><br><span class="line">    <span class="comment">//获取消息体</span></span><br><span class="line">    <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">    <span class="comment">//获取消息头</span></span><br><span class="line">    <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> message.getMessageProperties();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;消息处理完成--&gt;&quot;</span>+content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//channel内自增</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//签收获取,非批量模式，手动ack</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(deliveryTag %<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//收货 </span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;==签收了货物:&quot;</span>+deliveryTag);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//退货</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * b: 是否批量退货</span></span><br><span class="line"><span class="comment">             * b1: 是否返回服务器重新入队,即时生效</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;==没有签收货物:&quot;</span>+deliveryTag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//网络中断</span></span><br><span class="line">        log.error(<span class="string">&quot;网络中断了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实咱们的消息队列机制，很像<strong>淘宝购物</strong>，物品经过商家传递到指定的物流公司，物流公司再通过快递员发放，快递员执行发放成功，咱们收到了货物后，就可以选择确认收货。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>消息队列的引入，能够在以后开发的业务中使用，以提高服务的吞吐量，提高处理性能。</p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Redis</title>
    <url>/2022/03/13/SpringBoot%E6%95%B4%E5%90%88Redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、<strong>缓存</strong>和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="comment">//可以通过自定义redisTemplate来替换掉自动配置中的redisTemplate</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory 		         redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">//默认的redisTemplate没有啥过多的设置，redis对象都是需要序列化的,不然可能会乱码</span></span><br><span class="line">		<span class="comment">//两个泛型都是Object, Object，所以用的时候需要强制转化</span></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">//String是redis最常用的一个类型，所以单独提取一个bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory 	                 redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整合并测试一下"><a href="#整合并测试一下" class="headerlink" title="整合并测试一下"></a>整合并测试一下</h2><h3 id="导入maven依赖"><a href="#导入maven依赖" class="headerlink" title="导入maven依赖"></a>导入maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置连接"><a href="#配置连接" class="headerlink" title="配置连接"></a>配置连接</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置redis</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">post:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;jh&quot;</span>,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;jh&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于序列化问题"><a href="#关于序列化问题" class="headerlink" title="关于序列化问题"></a>关于序列化问题</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">jh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jh&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//将User类序列化为Json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(jh);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>,s);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 直接传对象，没有序列化，会序列化报错</span></span><br><span class="line"><span class="comment">        redisTemplate.opsForValue().set(&quot;user&quot;,jh);</span></span><br><span class="line"><span class="comment">        String user = redisTemplate.opsForValue().get(&quot;user&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(user);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="追溯源码"><a href="#追溯源码" class="headerlink" title="追溯源码"></a>追溯源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RedisTemplate.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (defaultSerializer == <span class="literal">null</span>) &#123;</span><br><span class="line">	defaultSerializer = <span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>(</span><br><span class="line">		classLoader != <span class="literal">null</span> ? classLoader : <span class="built_in">this</span>.getClass().getClassLoader()</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写配置类"><a href="#编写配置类" class="headerlink" title="编写配置类"></a>编写配置类</h3><p>默认序列化方式是jdk方式，导致key和value可能会出现乱码，那么，我们需要自定义一个序列化方式，集重新编写Redis配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RedisCong.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的配置类</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">//配置具体的序列化方式</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化配置</span></span><br><span class="line">        <span class="comment">//利用json解析任意对象</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> 		                     <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用 ObjectMapper对序列化进行转义</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写工具类"><a href="#编写工具类" class="headerlink" title="编写工具类"></a>编写工具类</h3><p>同样，为了简化开发，如果每次操作都需要调用redisTemplate底下的api接口来操作，太过于复杂，编写自己的Redis工具类, 在开发时即取即用就行了，非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RedisUtil.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">key</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Shiro</title>
    <url>/2022/02/18/SpringBoot%E6%95%B4%E5%90%88Shiro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot整合Shiro"><a href="#SpringBoot整合Shiro" class="headerlink" title="SpringBoot整合Shiro"></a>SpringBoot整合Shiro</h1><p>Shiro作为一个非常良好的安全认证授权框架，经常整合在SpringBoot项目中，写项目单纯会写，但没有深入了解Shiro的实现原理，回头学习了一下，想在此总结一下。</p>
<h2 id="三大对象"><a href="#三大对象" class="headerlink" title="三大对象"></a>三大对象</h2><p>一提到Shiro，三大对象的思想一定要刻在脑子里：</p>
<ul>
<li><p><strong>Subject</strong></p>
</li>
<li><p><strong>SecurityMenager</strong></p>
</li>
<li><p><strong>Realm</strong></p>
</li>
</ul>
<p>先解释一下这三个类：</p>
<ol>
<li><strong>Subject</strong>：当前所要进行<strong>认证授权的对象</strong>，这个类主要在与前端交互的时候使用。</li>
<li><strong>SecurityMenager</strong>：<strong>安全管理器</strong>，管理Realm。</li>
<li><strong>Realm</strong>：域，<strong>这也是Shiro最复杂的一个类</strong>，Realm 充当了 Shiro 与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro 会从应用配置的 Realm 中查找用户及其权限信息。从这个意义上讲，Realm 实质上是一个安全相关的 DAO：<strong>它封装了数据源的连接细节</strong>（在后面会提到），并在需要时将相关数据提供给 Shiro 。当配置 Shiro时，<strong>你必须至少指定一个 Realm ，用于认证和（或）授权</strong>。配置多个 Realm 是可以的，但是至少需要一个。Shiro 内置了可以连接大量安全数据源（又名目录）的 Realm，如 LDAP、关系数据库（JDBC）、类似 INI 的文本配置资源以及属性文件等。如果缺省的 Realm 不能满足需求，你还可以插入代表自定义数据源的自己的 Realm 实现。</li>
</ol>
<h2 id="细说Realm"><a href="#细说Realm" class="headerlink" title="细说Realm"></a>细说Realm</h2><p>Realm能做的工作主要有以下几个方面：</p>
<ul>
<li><strong>身份验证</strong>（getAuthenticationInfo 方法）验证账户和密码，并返回相关信息</li>
<li><strong>权限获取</strong>（getAuthorizationInfo 方法） 获取指定身份的权限，并返回相关信息</li>
<li><strong>令牌支持</strong>（supports方法）判断该令牌（Token）是否被支持</li>
</ul>
<p>令牌有很多种类型，例如：HostAuthenticationToken（主机验证令牌），UsernamePasswordToken（账户密码验证令牌）</p>
<p>这里主来说明一下关于前两点验证方面的逻辑，因为令牌一般用的都是 UsernamePasswordToken，哪怕用 HostAuthenticationToken，也没必要细讲，这个函数很少用到。</p>
<h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="编写自定义Realm"><a href="#编写自定义Realm" class="headerlink" title="编写自定义Realm"></a>编写自定义Realm</h3><p>上面介绍有说，Realm是需要自己编写的，继承AuthorizingRealm类，重写认证和授权方法是关键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的Realm需要继承AuthorizingRealm类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//授权  Authorization</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;授权-&gt;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给用户授予一些权限</span></span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        <span class="comment">//实际开发中，并不是这种固定死的统一授权，而是查数据库对应角色的权限并交付给相应用户的，是动态的，这里写死了，只是方便展示，没有跟数据库交互。</span></span><br><span class="line">        info.addStringPermission(<span class="string">&quot;user:add&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到当前这个对象(此处只是演示，这行代码在这没有实际作用)</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记住是返回info，返回null就会授权失败</span></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//认证  Authentication</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证-&gt;Authentication&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户名，密码应该通过token获取用户名动态从数据库中取,此处先伪数据演示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">userToken</span> <span class="operator">=</span> (UsernamePasswordToken) token;</span><br><span class="line">        <span class="keyword">if</span>(!userToken.getUsername().equals(name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//抛出用户名不存在异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//密码认证，shiro帮我们已经做了！！</span></span><br><span class="line">       <span class="comment">//SimpleAuthenticationInfo(Object principal：用户的相关信息可以存在这里，比如用户名等, Object credentials：密码, String realmName)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(<span class="string">&quot;&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写配置类"><a href="#编写配置类" class="headerlink" title="编写配置类"></a>编写配置类</h3><p>编写分三个步骤：</p>
<ol>
<li>加入自定义的<strong>Realm</strong>。</li>
<li>将自定义的Realm交给<strong>SecurityMenager</strong>管理。</li>
<li><strong>核心将</strong>，前两个步骤主要是为第3步服务，将<strong>SecurityMenager</strong>交给Shiro工厂，并配置相应的拦截机制和其他Shiro配置，主要的工作都在这一步完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//步骤三</span></span><br><span class="line">    <span class="comment">//ShiroFilterFactoryBean</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroFilterFactoryBean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;SecurityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置安全管理器</span></span><br><span class="line">        bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加shiro的内置过滤器</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            anon：无需认证就能访问</span></span><br><span class="line"><span class="comment">            authc：必须认证了才能访问</span></span><br><span class="line"><span class="comment">            user： 必须拥有 记住我 功能才能用</span></span><br><span class="line"><span class="comment">            perms：拥有对某个资源的权限才能访问</span></span><br><span class="line"><span class="comment">            role：拥有某个角色权限才能访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截</span></span><br><span class="line">        Map&lt;String, String&gt; filterMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/*&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//授权，正常情况下，没有授权会跳转到未授权页面</span></span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/add&quot;</span>,<span class="string">&quot;perms[user:add]&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置拦截器</span></span><br><span class="line">        bean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置登录的请求（编写的相应请求细节不过多介绍了，基本操作）</span></span><br><span class="line">        bean.setLoginUrl(<span class="string">&quot;/toLogin&quot;</span>); </span><br><span class="line">        <span class="comment">//设置未授权的请求，即跳转相应的未授权页面</span></span><br><span class="line">        bean.setUnauthorizedUrl(<span class="string">&quot;/noauth&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//步骤二</span></span><br><span class="line">    <span class="comment">//DefaultWebSecurityManager</span></span><br><span class="line">    <span class="meta">@Bean(&quot;SecurityManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(<span class="meta">@Qualifier(&quot;userRealm&quot;)</span> UserRealm userRealm)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">SecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关联咱们的Realm</span></span><br><span class="line">        SecurityManager.setRealm(userRealm);</span><br><span class="line">        <span class="keyword">return</span> SecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//步骤一</span></span><br><span class="line">    <span class="comment">//创建 Realm 对象，需要自定义</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserRealm <span class="title function_">userRealm</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRealm</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h3><p>之所以觉得shiro有点难理解是因为我们表层完全看不到当前用户<code>Subject</code>跟<code>Realm</code>是怎么实现交互的，底层实现了很多，下面贴一个<strong>Controller请求</strong>，来看看是怎么实现登录认证并实现相应授权的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, Model model)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取当前的用户</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装用户的登录数据，UsernamePasswordToken令牌</span></span><br><span class="line">    <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重点！！！！！！</span></span><br><span class="line">        <span class="comment">//getAuthenticationInfo 执行时机</span></span><br><span class="line">        <span class="comment">//执行登录方法，如果没有异常，则说明ok了</span></span><br><span class="line">        subject.login(token); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123; <span class="comment">//用户名不存在</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;用户名不存在！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>; <span class="comment">//登录失败，返回login页</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IncorrectCredentialsException e)</span><br><span class="line">    &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;密码错误！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>; <span class="comment">//密码错误，返回login页</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点：</p>
<p><code>subject.login(token)</code>：login方法看着非常简单，但背后已经帮我们调转到我们自定义的Realm中执行了<code>getAuthenticationInfo</code>方法。</p>
<p><code>filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;)</code>执行了授权后，请求<code>/user/add</code>时也会帮我们调转到我们自定义的Realm中执行了<code>getAuthorizationInfo</code>方法，获取相应授权信息，来判断当前用户是否具有访问相应页面的权限，若没有权限，变会跳转到之前所说的为授权页面。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>开发中，整合Shiro的步骤是固定的，按照上面的步骤来，从简单到复杂的进行开发，才能提高开发效率哦！！</p>
]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot整合相关数据库</title>
    <url>/2022/02/24/SpringBoot%E6%95%B4%E5%90%88%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Springboot整合相关数据库"><a href="#Springboot整合相关数据库" class="headerlink" title="Springboot整合相关数据库"></a>Springboot整合相关数据库</h1><h2 id="1-整合原生JDBC"><a href="#1-整合原生JDBC" class="headerlink" title="1.整合原生JDBC"></a>1.整合原生JDBC</h2><h3 id="1-创建boot项目时勾选JDBC的相关配置"><a href="#1-创建boot项目时勾选JDBC的相关配置" class="headerlink" title="1.创建boot项目时勾选JDBC的相关配置"></a>1.创建boot项目时勾选JDBC的相关配置</h3><p><img src="/img/springboot/JDBC.png" alt="JDBC"></p>
<p>添加了相关配置后，maven自动导入了jdbc和mysql的相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//pom.xml    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置自己的数据库</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//application.yml</span></span><br><span class="line">    <span class="attr">spring:</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">yourUsername</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">yourPassword</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">yourURL</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>

<p><code>driver-class-name</code>分为<code>com.mysql.cj.jdbc.Driver</code>和<code>com.mysql.jdbc.Driver</code>，建议使用第一个，支持较新版本的JDBC.</p>
<p><strong>注意：url需要配置要配置时区，否则可能会报错。</strong></p>
<h3 id="3-测试数据库"><a href="#3-测试数据库" class="headerlink" title="3.测试数据库"></a>3.测试数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Test</span></span><br><span class="line">	<span class="comment">//注入数据源</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看默认的数据源</span></span><br><span class="line">        System.out.println(dataSource.getClass());</span><br><span class="line">        <span class="comment">//获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="comment">//关闭数据库</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>JDBC的默认数据源是<code>hikari</code>，该数据源是<strong>最快</strong>的数据源。</p>
<p><strong>SpringBoot</strong>良好了封装JDBC成为了<strong>JdbcTemplate</strong>，使得数据库的操作变得异常简单，增删改查，一行代码就搞定了！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据库的所有信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sql&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">userList</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from collect_info&quot;</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list_maps = jdbcTemplate.queryForList(sql);</span><br><span class="line">        <span class="keyword">return</span> list_maps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-整合Druid"><a href="#2-整合Druid" class="headerlink" title="2.整合Druid"></a>2.整合Druid</h2><p><strong>Druid也是JDBC的一种数据源，内置监测日志，拦截器等强大的功能。</strong></p>
<h3 id="1-导入相关依赖："><a href="#1-导入相关依赖：" class="headerlink" title="1.导入相关依赖："></a>1.导入相关依赖：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-配置数据源的相关属性"><a href="#2-配置数据源的相关属性" class="headerlink" title="2.配置数据源的相关属性"></a>2.配置数据源的相关属性</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yourUsername</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourPassword</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">yourURL</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#druid 数据源专有配置</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span></span><br><span class="line">    <span class="comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span></span><br><span class="line">    <span class="comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat,wall,log4j</span></span><br><span class="line">    <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：过滤器配置了log4j后必须导入相应的依赖， 否则会报错哦！</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-自定义配置类"><a href="#3-自定义配置类" class="headerlink" title="3.自定义配置类"></a>3.自定义配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将配置属性绑定到对应的前缀下，才能被相应的前缀接管</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//数据源配置联调绑定</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">druidDataSource</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  后台监控</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">a</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注册一个servlet进容器中:ServletRegistrationBean</span></span><br><span class="line">        ServletRegistrationBean&lt;StatViewServlet&gt; bean = <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>&lt;&gt;(<span class="keyword">new</span> 		  <span class="title class_">StatViewServlet</span>(), <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, String&gt;  initParmeters= <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录的key是固定的</span></span><br><span class="line">        initParmeters.put(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        initParmeters.put(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        initParmeters.put(<span class="string">&quot;allow&quot;</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//默认所有人可以访问</span></span><br><span class="line">        <span class="comment">//后台需要有人登录，账号密码配置</span></span><br><span class="line">        bean.setInitParameters(initParmeters);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SpringBoot</strong>内置了Servlet容器（Tomcat），不需要再过于繁琐的配置Web.xml来定制自己的Servlet，在SpringBoot中，只需要调用<code>ServletRegistrationBean()</code>方法，将自己的Servlet对应到相应的mapping即可，最后通过<code>@Bean</code>z注解注入到容器使用，更加提高了开发效率。</p>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p><strong>访问<code>&#39;/druid&#39;</code>：</strong></p>
<p><img src="/img/springboot/Druid1.png" alt="Druid1"></p>
<p>重定向到login页面，登录自己绑定的账号密码进入到druid后台。</p>
<p><strong>监测日志功能：</strong></p>
<p><img src="/img/springboot/Druid.png" alt="Druid"></p>
<h2 id="3-整合mybatis和mybatis-plus"><a href="#3-整合mybatis和mybatis-plus" class="headerlink" title="3.整合mybatis和mybatis-plus"></a><strong>3.整合mybatis和mybatis-plus</strong></h2><h6 id="https-www-yuque-com-atguigu-springboot-aob431"><a href="#https-www-yuque-com-atguigu-springboot-aob431" class="headerlink" title="https://www.yuque.com/atguigu/springboot/aob431"></a><a href="https://www.yuque.com/atguigu/springboot/aob431">https://www.yuque.com/atguigu/springboot/aob431</a></h6><p><strong>mybatis-plus官网：<a href="https://baomidou.com/pages/b7dae0/#%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B">https://baomidou.com/pages/b7dae0/#%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B</a></strong></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p><strong>SpringBoot大大提高了开发效率，这也是一种趋势，同时简单的背后也意味这深封装，这需要不断提高我们的源码阅读能力，才能跟上迭代的速度！！！</strong></p>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动配置(一)</title>
    <url>/2022/01/22/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE(%E4%B8%80)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot自动配置-一-："><a href="#SpringBoot自动配置-一-：" class="headerlink" title="SpringBoot自动配置(一)："></a>SpringBoot自动配置(一)：</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a><strong>pom.xml</strong></h2><ul>
<li>springboot-boot-dependencies: 核心依赖在父工程中</li>
<li>我们在写或者引入一些springboot依赖的时候，不需要指定版本，因为这些版本已经在版本仓库中，默认就有版本号了</li>
</ul>
<h2 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a><strong>启动器</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>主程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class HelloworldApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(HelloworldApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>&#96;&#96;&#96;<br>@SpringBootConfiguration<br>@Configuration: Spring配置类<br>@Component: 说明这是一个Spring组件<br>@EnableAutoConfiguration：自动配置<br>@AutoConfigurationPackage： 自动配置包<br>@Import({Registrar.class})： d<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 静态资源的读取默认路径</span><br><span class="line"></span><br><span class="line">1.在springboot，我们可以使用以下方式处理静态资源</span><br><span class="line"></span><br><span class="line">- webjars</span><br><span class="line">- public， static， /,  resources,   **localhost**:8080/**</span><br><span class="line"></span><br><span class="line">2.优先级： resources &gt; static(默认) &gt; public</span><br><span class="line"></span><br><span class="line">也可以自定义静态资源路径 ： </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>spring.mvc.static-path-pattern: </p>
<pre><code>


</code></pre>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot利用JSCH实现远程服务器的文件传输</title>
    <url>/2022/02/28/Springboot%E5%88%A9%E7%94%A8JSCH%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Springboot利用JSCH实现远程服务器的交互"><a href="#Springboot利用JSCH实现远程服务器的交互" class="headerlink" title="Springboot利用JSCH实现远程服务器的交互"></a>Springboot利用JSCH实现远程服务器的交互</h1><h2 id="JSCH简介"><a href="#JSCH简介" class="headerlink" title="JSCH简介"></a><a href="https://so.csdn.net/so/search?q=JSCH&spm=1001.2101.3001.7020">JSCH</a>简介</h2><p>JSch 是SSH2的一个纯<a href="https://so.csdn.net/so/search?q=Java&spm=1001.2101.3001.7020">Java</a>实现。它允许你连接到一个sshd 服务器，使用端口转发，X11转发，文件传输等等。你可以将它的功能集成到你自己的 程序中。同时该项目也提供一个J2ME版本用来在手机上直连SSHD服务器。</p>
<p>大概步骤如下：添加依赖—&gt;远程连接主机—&gt;建立功能通道—-&gt;通过对应的API接口实现交互</p>
<h2 id="JSCH依赖-版本更新较快-可前往maven中央仓库加载项目最新版http-mvnrepository-com"><a href="#JSCH依赖-版本更新较快-可前往maven中央仓库加载项目最新版http-mvnrepository-com" class="headerlink" title="JSCH依赖(版本更新较快,可前往maven中央仓库加载项目最新版http://mvnrepository.com )"></a>JSCH依赖(版本更新较快,可前往maven中央仓库加载项目最新版<a href="http://mvnrepository.com/">http://mvnrepository.com</a> )</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.jcraft&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;jsch&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;<span class="number">0.1</span><span class="number">.55</span>&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="连接远程主机"><a href="#连接远程主机" class="headerlink" title="连接远程主机"></a>连接远程主机</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> *</span><br><span class="line"> * @param ip       远程主机IP地址</span><br><span class="line"> * @param port     远程主机端口</span><br><span class="line"> * @param username 远程主机登陆用户名</span><br><span class="line"> * @param password 远程主机登陆密码</span><br><span class="line"> * @throws JSchException JSch异常</span><br><span class="line"> */</span><br><span class="line">public void init(String ip, Integer port, String username, String password) throws JSchException &#123;</span><br><span class="line">    JSch jsch = new JSch();</span><br><span class="line">    session = jsch.getSession(username, ip, port);</span><br><span class="line">    session.setPassword(password);</span><br><span class="line">    Properties sshConfig = new Properties();</span><br><span class="line">    sshConfig.put(&quot;StrictHostKeyChecking&quot;, strictHostKeyChecking);</span><br><span class="line">    session.setConfig(sshConfig);</span><br><span class="line">    session.connect(timeout);</span><br><span class="line">    log.info(&quot;Session connected!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用时可直接调用下面的方法</span><br><span class="line">public void init(String ip, String username, String password) throws JSchException &#123;</span><br><span class="line">    init(ip, 22, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ChannelExec使用说明（远程Shell命令的执行）"><a href="#ChannelExec使用说明（远程Shell命令的执行）" class="headerlink" title="ChannelExec使用说明（远程Shell命令的执行）"></a>ChannelExec使用说明（远程Shell命令的执行）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接多次执行命令，执行命令完毕后需要执行close()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command 需要执行的指令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 没有执行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execCmd</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 打开执行shell指令的通道</span></span><br><span class="line">        channel = session.openChannel(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">        channelExec = (ChannelExec) channel;</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="literal">null</span> || channel == <span class="literal">null</span> || channelExec == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;execCmd command - &gt; &#123;&#125;&quot;</span>, command);</span><br><span class="line">        channelExec.setCommand(command);</span><br><span class="line">        channel.setInputStream(<span class="literal">null</span>);</span><br><span class="line">        channelExec.setErrStream(System.err);</span><br><span class="line">        channel.connect();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> channelExec.getInputStream();</span><br><span class="line">             <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in, StandardCharsets.UTF_8);</span><br><span class="line">             <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr)) &#123;</span><br><span class="line">            String buffer;</span><br><span class="line">            <span class="keyword">while</span> ((buffer = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;\n&quot;</span>).append(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;execCmd result - &gt; &#123;&#125;&quot;</span>, sb);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行命令关闭连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command 需要执行的指令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 没有执行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execCmdAndClose</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> execCmd(command);</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelExec != <span class="literal">null</span> &amp;&amp; channelExec.isConnected()) &#123;</span><br><span class="line">            channelExec.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isConnected()) &#123;</span><br><span class="line">            channel.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; session.isConnected()) &#123;</span><br><span class="line">            session.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ChannelSftp使用说明-远程文件上传与传输"><a href="#ChannelSftp使用说明-远程文件上传与传输" class="headerlink" title="ChannelSftp使用说明 (远程文件上传与传输)"></a>ChannelSftp使用说明 (远程文件上传与传输)</h3><h4 id="ChannelSftp简介"><a href="#ChannelSftp简介" class="headerlink" title="ChannelSftp简介"></a>ChannelSftp简介</h4><p>ChannelSftp类是JSch实现<code>SFTP</code>核心类，它包含了所有<code>SFTP</code>的方法，如：</p>
<ul>
<li><p><code>put()： 文件上传</code></p>
</li>
<li><p><code>get()： 文件下载</code></p>
</li>
<li><p><code>cd()： 进入指定目录</code></p>
</li>
<li><p><code>ls()： 得到指定目录下的文件列表</code></p>
</li>
<li><p><code>rename()： 重命名指定文件或目录</code></p>
</li>
<li><p><code>rm()： 删除指定文件</code></p>
</li>
<li><p><code>mkdir()： 创建目录</code></p>
</li>
<li><p><code>rmdir()： 删除目录</code></p>
</li>
</ul>
<h4 id="JSch支持三种文件传输模式"><a href="#JSch支持三种文件传输模式" class="headerlink" title="JSch支持三种文件传输模式"></a>JSch支持三种文件传输模式</h4><table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>OVERWRITE</td>
<td>**<code>完全覆盖模式</code>**：这是JSch的默认文件传输模式，即如果目标文件已经存在立刻，传输的文件会覆盖源文件</td>
</tr>
<tr>
<td>RESUME</td>
<td>**<code>恢复模式</code>**：即如果文件已经传输了一部分，但是由于其他原因导致了传输中断，如果下次继续传输，则会从上传传输中断的地方开始</td>
</tr>
<tr>
<td>APPEND</td>
<td>**<code>追加模式</code>**：如果目标文件已经存在，传输的文件只会继续往后追加而不会覆盖。</td>
</tr>
</tbody></table>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>文件上传选择put方法，重载方法很多，我觉得记住主要的前几个常用的即可，现查现用。该表一共罗列了12个put方法供大家参考。</p>
<p><strong>不用背，大概了解一下即可</strong>，传参有印象，后序即查即用。</p>
<table>
<thead>
<tr>
<th align="center"><strong>方法</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public void put(String src, String dst)</code></td>
<td align="center">将本地文件名为src的文件上传到目标服务器，目标文件名为dst，若dst为目录，则目标文件名将与src文件名相同。采用默认的传输模式：OVERWRITE</td>
</tr>
<tr>
<td align="center"><code>public void put(String src, String dst, int mode)</code></td>
<td align="center">将本地文件名为src的文件上传到目标服务器，目标文件名为dst，若dst为目录，则目标文件名将与src文件名相同。指定文件传输模式为mode（mode可选值为：ChannelSftp.OVERWRITE，ChannelSftp.RESUME，ChannelSftp.APPEND</td>
</tr>
<tr>
<td align="center"><code>public void put(String src, String dst, SftpProgressMonitor monitor)</code></td>
<td align="center">将本地文件名为src的文件上传到目标服务器，目标文件名为dst，若dst为目录，则目标文件名将与src文件名相同。采用默认的传输模式：OVERWRITE,并使用实现了SftpProgressMonitor接口的monitor对象来监控文件传输的进度。</td>
</tr>
<tr>
<td align="center"><code>public void put(String src, String dst,SftpProgressMonitor monitor, int mode)</code></td>
<td align="center">将本地文件名为src的文件上传到目标服务器，目标文件名为dst，若dst为目录，则目标文件名将与src文件名相同。指定传输模式为mode，并使用实现了SftpProgressMonitor接口的monitor对象来监控文件传输的进度。</td>
</tr>
<tr>
<td align="center"><code>public void put(InputStream src, String dst)</code></td>
<td align="center">将本地的input stream对象src上传到目标服务器，目标文件名为dst，dst不能为目录。采用默认的传输模式：OVERWRITE</td>
</tr>
<tr>
<td align="center"><code>public void put(InputStream src, String dst, int mode)</code></td>
<td align="center">将本地的input stream对象src上传到目标服务器，目标文件名为dst，dst不能为目录。指定文件传输模式为mode</td>
</tr>
<tr>
<td align="center"><code>public void put(InputStream src, String dst, SftpProgressMonitor monitor)</code></td>
<td align="center">将本地的input stream对象src上传到目标服务器，目标文件名为dst，dst不能为目录。采用默认的传输模式：OVERWRITE，并使用实现了SftpProgressMonitor接口的monitor对象来监控传输的进度。</td>
</tr>
<tr>
<td align="center"><code>public void put(InputStream src, String dst,SftpProgressMonitor monitor, int mode)</code></td>
<td align="center">将本地的input stream对象src上传到目标服务器，目标文件名为dst，dst不能为目录。指定文件传输模式为mode，并使用实现了SftpProgressMonitor接口的monitor对象来监控传输的进度。</td>
</tr>
<tr>
<td align="center"><code>public OutputStream put(String dst)</code></td>
<td align="center">该方法返回一个输出流，可以向该输出流中写入数据，最终将数据传输到目标服务器，目标文件名为dst，dst不能为目录。采用默认的传输模式：OVERWRITE</td>
</tr>
<tr>
<td align="center"><code>public OutputStream put(String dst, final int mode)</code></td>
<td align="center">该方法返回一个输出流，可以向该输出流中写入数据，最终将数据传输到目标服务器，目标文件名为dst，dst不能为目录。指定文件传输模式为mode</td>
</tr>
<tr>
<td align="center"><code>public OutputStream put(String dst, final SftpProgressMonitor monitor, final int mode)</code></td>
<td align="center">该方法返回一个输出流，可以向该输出流中写入数据，最终将数据传输到目标服务器，目标文件名为dst，dst不能为目录。指定文件传输模式为mode，并使用实现了SftpProgressMonitor接口的monitor对象来监控传输的进度。</td>
</tr>
<tr>
<td align="center"><code>public OutputStream put(String dst, final SftpProgressMonitor monitor, final int mode, long offset)</code></td>
<td align="center">该方法返回一个输出流，可以向该输出流中写入数据，最终将数据传输到目标服务器，目标文件名为dst，dst不能为目录。指定文件传输模式为mode，并使用实现了SftpProgressMonitor接口的monitor对象来监控传输的进度。offset指定了一个偏移量，从输出流偏移offset开始写入数据。<br/></td>
</tr>
</tbody></table>
<p>文件上传功能代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst 目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 上传文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAndClose</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        putAndClose(src, dst, ChannelSftp.OVERWRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src  源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst  目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode 上传模式 默认为ChannelSftp.OVERWRITE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 上传文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAndClose</span><span class="params">(String src, String dst, <span class="type">int</span> mode)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        log.info(<span class="string">&quot;Upload File &#123;&#125; -&gt; &#123;&#125;&quot;</span>, src, dst);</span><br><span class="line">        channelSftp.put(src, dst, mode);</span><br><span class="line">        log.info(<span class="string">&quot;Upload File Success!&quot;</span>);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件上传并监控上传进度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst 目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 上传文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putMonitorAndClose</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        putMonitorAndClose(src, dst, ChannelSftp.OVERWRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件上传并监控上传进度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src  源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst  目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode 上传模式 默认为ChannelSftp.OVERWRITE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 上传文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putMonitorAndClose</span><span class="params">(String src, String dst, <span class="type">int</span> mode)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        <span class="type">UploadMonitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadMonitor</span>(<span class="keyword">new</span> <span class="title class_">File</span>(src).length());</span><br><span class="line">        log.info(<span class="string">&quot;Upload File &#123;&#125; -&gt; &#123;&#125;&quot;</span>, src, dst);</span><br><span class="line">        channelSftp.put(src, dst, monitor, mode);</span><br><span class="line">        log.info(<span class="string">&quot;Upload File Success!&quot;</span>);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelSftp != <span class="literal">null</span> &amp;&amp; channelSftp.isConnected()) &#123;</span><br><span class="line">            channelSftp.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isConnected()) &#123;</span><br><span class="line">            channel.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; session.isConnected()) &#123;</span><br><span class="line">            session.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initChannelSftp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        channel = session.openChannel(<span class="string">&quot;sftp&quot;</span>);</span><br><span class="line">        channel.connect(); <span class="comment">// 建立SFTP通道的连接</span></span><br><span class="line">        channelSftp = (ChannelSftp) channel;</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="literal">null</span> || channel == <span class="literal">null</span> || channelSftp == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>同理文件上传,文件下载选择get方法，同样有9个重载方法如下:</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>publicvoid get(String src, String dst)</code></td>
<td>将目标服务器上文件名为src的文件下载到本地，本地文件名为dst。若dst为目录，则下载到本地的文件名将与src文件名相同。（注：src必须是文件，不能为目录），采用默认的传输模式：OVERWRITE</td>
</tr>
<tr>
<td><code>publicvoid get(String src, String dst, SftpProgressMonitor monitor)</code></td>
<td>将目标服务器上文件名为src的文件下载到本地，本地文件名为dst。若dst为目录，则下载到本地的文件名将与src文件名相同。（注：src必须是文件，不能为目录），采用默认的传输模式：OVERWRITE</td>
</tr>
<tr>
<td><code>publicvoid get(String src, String dst,SftpProgressMonitor monitor, int mode)</code></td>
<td>将目标服务器上文件名为src的文件下载到本地，本地文件名为dst。若dst为目录，则下载到本地的文件名将与src文件名相同。（注：src必须是文件，不能为目录）指定文件传输模式为mode（mode可选值为：ChannelSftp.OVERWRITE，ChannelSftp.RESUME，ChannelSftp.APPEND），并使用实现了SftpProgressMonitor接口的monitor对象来监控文件的传输进度。</td>
</tr>
<tr>
<td><code>publicvoid get(String src, OutputStream dst)</code></td>
<td>将目标服务器上文件名为src的文件下载到本地，下载的数据写入到输出流对象dst（如：文件输出流）。采用默认的传输模式：OVERWRITE</td>
</tr>
<tr>
<td><code>publicvoid get(String src, OutputStream dst, SftpProgressMonitor monitor)</code></td>
<td>将目标服务器上文件名为src的文件下载到本地，下载的数据写入到输出流对象dst（如：文件输出流）。采用默认的传输模式：OVERWRITE，并使用实现了SftpProgressMonitor接口的monitor对象来监控文件的传输进度。</td>
</tr>
<tr>
<td><code>publicvoid get(String src, OutputStream dst, SftpProgressMonitor monitor, int mode, long skip)</code></td>
<td>将目标服务器上文件名为src的文件下载到本地，下载的数据写入到输出流对象dst（如：文件输出流）。指定文件传输模式为mode并使用实现了SftpProgressMonitor接口的monitor对象来监控文件的传输进度。skip指定了一个跳读量，即下载时从src文件跳过skip字节的数据。（一般不推荐使用该参数，默认设为0）</td>
</tr>
<tr>
<td><code>public InputStream get(String src)</code></td>
<td>该方法返回一个输入流，该输入流含有目标服务器上文件名为src的文件数据。可以从该输入流中读取数据，最终将数据传输到本地（如：读取数据后将数据写入到本地的文件中）（注：该方法不支持多种文件传输模式，如何读取与保存数据由应用程序自己确定）</td>
</tr>
<tr>
<td><code>public InputStream get(String src, SftpProgressMonitor monitor)</code></td>
<td>该方法返回一个输入流，该输入流含有目标服务器上文件名为src的文件数据。可以从该输入流中读取数据，最终将数据传输到本地（如：读取数据后将数据写入到本地的文件中）并使用实现了SftpProgressMonitor接口的monitor对象来监控文件的传输进度。（注：该方法不支持多种文件传输模式，如何读取与保存数据由应用程序自己确定）</td>
</tr>
<tr>
<td><code>public InputStream get(String src, final SftpProgressMonitor monitor, finallong skip)</code></td>
<td>该方法返回一个输入流，该输入流含有目标服务器上文件名为src的文件数据。可以从该输入流中读取数据，最终将数据传输到本地（如：读取数据后将数据写入到本地的文件中）并使用实现了SftpProgressMonitor接口的monitor对象来监控文件的传输进度。（注：该方法不支持多种文件传输模式，如何读取与保存数据由应用程序自己确定）skip指定了一个跳读量，即下载时从src文件跳过skip字节的数据。（一般不推荐使用该参数，默认设为0）</td>
</tr>
</tbody></table>
<p>文件下载功能代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件下载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 源文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst 目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 下载文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndClose</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        log.info(<span class="string">&quot;Download File &#123;&#125; -&gt; &#123;&#125;&quot;</span>, src, dst);</span><br><span class="line">        channelSftp.get(src, dst);</span><br><span class="line">        log.info(<span class="string">&quot;Download File Success!&quot;</span>);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMonitorAndClose</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        <span class="type">FileProgressMonitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileProgressMonitor</span>(<span class="keyword">new</span> <span class="title class_">File</span>(src).length());</span><br><span class="line">        log.info(<span class="string">&quot;Download File &#123;&#125; -&gt; &#123;&#125;&quot;</span>, src, dst);</span><br><span class="line">        channelSftp.get(src, dst, monitor);</span><br><span class="line">        log.info(<span class="string">&quot;Download File Success!&quot;</span>);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ChannelShell使用说明"><a href="#ChannelShell使用说明" class="headerlink" title="ChannelShell使用说明"></a>ChannelShell使用说明</h3><h4 id="shell代码"><a href="#shell代码" class="headerlink" title="shell代码"></a>shell代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行复杂shell命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmds 多条命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 连接异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execCmdByShell</span><span class="params">(String... cmds)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> execCmdByShell(Arrays.asList(cmds));</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行复杂shell命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmds 多条命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 连接异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execCmdByShell</span><span class="params">(List&lt;String&gt; cmds)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        initChannelShell();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> channelShell.getInputStream();</span><br><span class="line">        channelShell.setPty(<span class="literal">true</span>);</span><br><span class="line">        channelShell.connect();</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> channelShell.getOutputStream();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream);</span><br><span class="line">        <span class="keyword">for</span> (String cmd : cmds) &#123;</span><br><span class="line">            printWriter.println(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        printWriter.flush();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (inputStream.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inputStream.read(tmp, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(tmp, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (s.contains(<span class="string">&quot;--More--&quot;</span>)) &#123;</span><br><span class="line">                    outputStream.write((<span class="string">&quot; &quot;</span>).getBytes());</span><br><span class="line">                    outputStream.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channelShell.isClosed()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;exit-status:&quot;</span> + channelShell.getExitStatus());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initChannelShell</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 打开执行shell指令的通道</span></span><br><span class="line">        channel = session.openChannel(<span class="string">&quot;shell&quot;</span>);</span><br><span class="line">        channelShell = (ChannelShell) channel;</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="literal">null</span> || channel == <span class="literal">null</span> || channelShell == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通过递归下载整个文件夹"><a href="#通过递归下载整个文件夹" class="headerlink" title="通过递归下载整个文件夹"></a>通过递归下载整个文件夹</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载文件夹</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 下载目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 保存目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SftpException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveFolderDownload</span><span class="params">(String sourcePath, String destinationPath)</span> <span class="keyword">throws</span> SftpException &#123;</span><br><span class="line">        Vector&lt;ChannelSftp.LsEntry&gt; fileAndFolderList = channelSftp.ls(sourcePath); <span class="comment">// Let list of folder content</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Iterate through list of folder content</span></span><br><span class="line">        <span class="keyword">for</span> (ChannelSftp.LsEntry item : fileAndFolderList) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!item.getAttrs().isDir()) &#123; <span class="comment">// Check if it is a file (not a directory).</span></span><br><span class="line">                <span class="keyword">if</span> (!(<span class="keyword">new</span> <span class="title class_">File</span>(destinationPath + PATHSEPARATOR + item.getFilename())).exists()</span><br><span class="line">                        || (item.getAttrs().getMTime() &gt; Long</span><br><span class="line">                                .valueOf(<span class="keyword">new</span> <span class="title class_">File</span>(destinationPath + PATHSEPARATOR + item.getFilename()).lastModified()</span><br><span class="line">                                        / (<span class="type">long</span>) <span class="number">1000</span>)</span><br><span class="line">                                .intValue())) &#123; <span class="comment">// Download only if changed later.</span></span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">File</span>(destinationPath + PATHSEPARATOR + item.getFilename());</span><br><span class="line">                    channelSftp.get(sourcePath + PATHSEPARATOR + item.getFilename(),</span><br><span class="line">                            destinationPath + PATHSEPARATOR + item.getFilename()); <span class="comment">// Download file from source (source filename, destination filename).</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(<span class="string">&quot;.&quot;</span>.equals(item.getFilename()) || <span class="string">&quot;..&quot;</span>.equals(item.getFilename()))) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">File</span>(destinationPath + PATHSEPARATOR + item.getFilename()).mkdirs(); <span class="comment">// Empty folder copy.</span></span><br><span class="line">                recursiveFolderDownload(sourcePath + PATHSEPARATOR + item.getFilename(),</span><br><span class="line">                        destinationPath + PATHSEPARATOR + item.getFilename()); <span class="comment">// Enter found folder on server to read its contents and create locally.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整工具类"><a href="#完整工具类" class="headerlink" title="完整工具类"></a>完整工具类</h3><p>工具类就是将上述功能进行了整合.</p>
<p>若是采用springboot构建的项目,该工具类放在<code>Bean</code>目录下即可.</p>
<p><code>ShellUtil.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">strictHostKeyChecking</span> <span class="operator">=</span> <span class="string">&quot;no&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelExec channelExec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelSftp channelSftp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelShell channelShell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">PATHSEPARATOR</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip       远程主机IP地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port     远程主机端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 远程主机登陆用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 远程主机登陆密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException JSch异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String ip, Integer port, String username, String password)</span> <span class="keyword">throws</span> JSchException &#123;</span><br><span class="line">        <span class="type">JSch</span> <span class="variable">jsch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSch</span>();</span><br><span class="line">        session = jsch.getSession(username, ip, port);</span><br><span class="line">        session.setPassword(password);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">sshConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        sshConfig.put(<span class="string">&quot;StrictHostKeyChecking&quot;</span>, strictHostKeyChecking);</span><br><span class="line">        session.setConfig(sshConfig);</span><br><span class="line">        session.connect(timeout);</span><br><span class="line">        log.info(<span class="string">&quot;Session connected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String ip, String username, String password)</span> <span class="keyword">throws</span> JSchException &#123;</span><br><span class="line">        init(ip, <span class="number">22</span>, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接多次执行命令，执行命令完毕后需要执行close()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command 需要执行的指令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 没有执行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execCmd</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelExec();</span><br><span class="line">        log.info(<span class="string">&quot;execCmd command - &gt; &#123;&#125;&quot;</span>, command);</span><br><span class="line">        channelExec.setCommand(command);</span><br><span class="line">        channel.setInputStream(<span class="literal">null</span>);</span><br><span class="line">        channelExec.setErrStream(System.err);</span><br><span class="line">        channel.connect();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> channelExec.getInputStream();</span><br><span class="line">             <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in, StandardCharsets.UTF_8);</span><br><span class="line">             <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr)) &#123;</span><br><span class="line">            String buffer;</span><br><span class="line">            <span class="keyword">while</span> ((buffer = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;\n&quot;</span>).append(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;execCmd result - &gt; &#123;&#125;&quot;</span>, sb);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行命令关闭连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command 需要执行的指令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 没有执行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execCmdAndClose</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> execCmd(command);</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行复杂shell命令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmds 多条命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 连接异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execCmdByShell</span><span class="params">(String... cmds)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> execCmdByShell(Arrays.asList(cmds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行复杂shell命令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmds 多条命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 连接异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execCmdByShell</span><span class="params">(List&lt;String&gt; cmds)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        initChannelShell();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> channelShell.getInputStream();</span><br><span class="line">        channelShell.setPty(<span class="literal">true</span>);</span><br><span class="line">        channelShell.connect();</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> channelShell.getOutputStream();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream);</span><br><span class="line">        <span class="keyword">for</span> (String cmd : cmds) &#123;</span><br><span class="line">            printWriter.println(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        printWriter.flush();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (inputStream.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inputStream.read(tmp, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(tmp, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (s.contains(<span class="string">&quot;--More--&quot;</span>)) &#123;</span><br><span class="line">                    outputStream.write((<span class="string">&quot; &quot;</span>).getBytes());</span><br><span class="line">                    outputStream.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channelShell.isClosed()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;exit-status:&quot;</span> + channelShell.getExitStatus());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst 目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 上传文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAndClose</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        putAndClose(src, dst, ChannelSftp.OVERWRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src  源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst  目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode 上传模式 默认为ChannelSftp.OVERWRITE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 上传文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAndClose</span><span class="params">(String src, String dst, <span class="type">int</span> mode)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        put(src, dst, mode);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        put(src, dst, ChannelSftp.OVERWRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String src, String dst, <span class="type">int</span> mode)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        log.info(<span class="string">&quot;Upload File &#123;&#125; -&gt; &#123;&#125;&quot;</span>, src, dst);</span><br><span class="line">        channelSftp.put(src, dst, mode);</span><br><span class="line">        log.info(<span class="string">&quot;Upload File Success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件上传并监控上传进度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst 目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 上传文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putMonitorAndClose</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        putMonitorAndClose(src, dst, ChannelSftp.OVERWRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件上传并监控上传进度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src  源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst  目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode 上传模式 默认为ChannelSftp.OVERWRITE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 上传文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putMonitorAndClose</span><span class="params">(String src, String dst, <span class="type">int</span> mode)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        <span class="type">FileProgressMonitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileProgressMonitor</span>(<span class="keyword">new</span> <span class="title class_">File</span>(src).length());</span><br><span class="line">        log.info(<span class="string">&quot;Upload File &#123;&#125; -&gt; &#123;&#125;&quot;</span>, src, dst);</span><br><span class="line">        channelSftp.put(src, dst, monitor, mode);</span><br><span class="line">        log.info(<span class="string">&quot;Upload File Success!&quot;</span>);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件下载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 源文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst 目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 下载文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndClose</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        get(src,dst);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        log.info(<span class="string">&quot;Download File &#123;&#125; -&gt; &#123;&#125;&quot;</span>, src, dst);</span><br><span class="line">        channelSftp.get(src, dst);</span><br><span class="line">        log.info(<span class="string">&quot;Download File Success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SFTP文件下载并监控下载进度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 源文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst 目的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 下载文件失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMonitorAndClose</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        <span class="type">FileProgressMonitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileProgressMonitor</span>(<span class="keyword">new</span> <span class="title class_">File</span>(src).length());</span><br><span class="line">        log.info(<span class="string">&quot;Download File &#123;&#125; -&gt; &#123;&#125;&quot;</span>, src, dst);</span><br><span class="line">        channelSftp.get(src, dst, monitor);</span><br><span class="line">        log.info(<span class="string">&quot;Download File Success!&quot;</span>);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定目录文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 删除路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 远程主机连接异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        channelSftp.rm(path);</span><br><span class="line">        log.info(<span class="string">&quot;Delete File &#123;&#125;&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定目录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 删除路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 远程主机连接异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDir</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        initChannelSftp();</span><br><span class="line">        channelSftp.rmdir(path);</span><br><span class="line">        log.info(<span class="string">&quot;Delete Dir &#123;&#125; &quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelSftp != <span class="literal">null</span> &amp;&amp; channelSftp.isConnected()) &#123;</span><br><span class="line">            channelSftp.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (channelExec != <span class="literal">null</span> &amp;&amp; channelExec.isConnected()) &#123;</span><br><span class="line">            channelExec.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isConnected()) &#123;</span><br><span class="line">            channel.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; session.isConnected()) &#123;</span><br><span class="line">            session.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannelSftp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        channel = session.openChannel(<span class="string">&quot;sftp&quot;</span>);</span><br><span class="line">        channel.connect(); <span class="comment">// 建立SFTP通道的连接</span></span><br><span class="line">        channelSftp = (ChannelSftp) channel;</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="literal">null</span> || channel == <span class="literal">null</span> || channelSftp == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initChannelExec</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 打开执行shell指令的通道</span></span><br><span class="line">        channel = session.openChannel(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">        channelExec = (ChannelExec) channel;</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="literal">null</span> || channel == <span class="literal">null</span> || channelExec == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initChannelShell</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 打开执行shell指令的通道</span></span><br><span class="line">        channel = session.openChannel(<span class="string">&quot;shell&quot;</span>);</span><br><span class="line">        channelShell = (ChannelShell) channel;</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="literal">null</span> || channel == <span class="literal">null</span> || channelShell == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;请先执行init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载文件夹</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 下载目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 保存目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SftpException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursiveFolderDownload</span><span class="params">(String sourcePath, String destinationPath)</span> <span class="keyword">throws</span> SftpException &#123;</span><br><span class="line">        Vector&lt;ChannelSftp.LsEntry&gt; fileAndFolderList = channelSftp.ls(sourcePath); <span class="comment">// Let list of folder content</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Iterate through list of folder content</span></span><br><span class="line">        <span class="keyword">for</span> (ChannelSftp.LsEntry item : fileAndFolderList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!item.getAttrs().isDir()) &#123; <span class="comment">// Check if it is a file (not a directory).</span></span><br><span class="line">                <span class="keyword">if</span> (!(<span class="keyword">new</span> <span class="title class_">File</span>(destinationPath + PATHSEPARATOR + item.getFilename())).exists()</span><br><span class="line">                        || (item.getAttrs().getMTime() &gt; Long</span><br><span class="line">                        .valueOf(<span class="keyword">new</span> <span class="title class_">File</span>(destinationPath + PATHSEPARATOR + item.getFilename()).lastModified()</span><br><span class="line">                                / (<span class="type">long</span>) <span class="number">1000</span>)</span><br><span class="line">                        .intValue())) &#123; <span class="comment">// Download only if changed later.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">File</span>(destinationPath + PATHSEPARATOR + item.getFilename());</span><br><span class="line">                    channelSftp.get(sourcePath + PATHSEPARATOR + item.getFilename(),</span><br><span class="line">                            destinationPath + PATHSEPARATOR + item.getFilename()); <span class="comment">// Download file from source (source filename, destination filename).</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(<span class="string">&quot;.&quot;</span>.equals(item.getFilename()) || <span class="string">&quot;..&quot;</span>.equals(item.getFilename()))) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">File</span>(destinationPath + PATHSEPARATOR + item.getFilename()).mkdirs(); <span class="comment">// Empty folder copy.</span></span><br><span class="line">                recursiveFolderDownload(sourcePath + PATHSEPARATOR + item.getFilename(),</span><br><span class="line">                        destinationPath + PATHSEPARATOR + item.getFilename()); <span class="comment">// Enter found folder on server to read its contents and create locally.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileProgressMonitor.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileProgressMonitor</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> <span class="keyword">implements</span> <span class="title class_">SftpProgressMonitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> transfered;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> fileSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isScheduled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileProgressMonitor</span><span class="params">(<span class="type">long</span> fileSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fileSize = fileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnd()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Transfering is in progress.&quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">transfered</span> <span class="operator">=</span> getTransfered();</span><br><span class="line">            <span class="comment">// 判断当前已传输数据大小是否等于文件总大小</span></span><br><span class="line">            <span class="keyword">if</span> (transfered != fileSize) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Current transfered: &#123;&#125; bytes&quot;</span>, transfered);</span><br><span class="line">                sendProgressMessage(transfered);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前已传输数据大小等于文件总大小，说明已完成，设置end</span></span><br><span class="line">                log.info(<span class="string">&quot;File transfering is done.&quot;</span>);</span><br><span class="line">                setEnd(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Transfering done. Cancel timer.&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果传输结束，停止timer记时器</span></span><br><span class="line">            stop();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现了SftpProgressMonitor接口的count方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">count</span><span class="params">(<span class="type">long</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEnd()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isScheduled) &#123;</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        add(count);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现了SftpProgressMonitor接口的end方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        setEnd(<span class="literal">true</span>);</span><br><span class="line">        log.info(<span class="string">&quot;transfering end. time -&gt;&#123;&#125; s&quot;</span>, (System.currentTimeMillis() - startTime) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> op, String src, String dest, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Try to stop progress monitor.&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isShutdown</span> <span class="operator">=</span> executorService.isShutdown();</span><br><span class="line">        <span class="keyword">if</span> (!isShutdown) &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;Progress monitor stoped.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Try to start progress monitor.&quot;</span>);</span><br><span class="line">        executorService = <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//1秒钟后开始执行，每2杪钟执行一次</span></span><br><span class="line">        executorService.scheduleWithFixedDelay(<span class="built_in">this</span>, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        isScheduled = <span class="literal">true</span>;</span><br><span class="line">        log.info(<span class="string">&quot;Progress monitor started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印progress信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transfered</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendProgressMessage</span><span class="params">(<span class="type">long</span> transfered)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileSize != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> ((<span class="type">double</span>) transfered * <span class="number">100</span>) / (<span class="type">double</span>) fileSize;</span><br><span class="line">            <span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;Sending progress message: &#123;&#125; %&quot;</span>, df.format(d));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Sending progress message: &#123;&#125;&quot;</span>, transfered);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> count)</span> &#123;</span><br><span class="line">        transfered = transfered + count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">getTransfered</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> transfered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setTransfered</span><span class="params">(<span class="type">long</span> transfered)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transfered = transfered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setEnd</span><span class="params">(<span class="type">boolean</span> isEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isEnd = isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring重点小总结</title>
    <url>/2022/03/16/Spring%E9%87%8D%E7%82%B9%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring重点小总结"><a href="#Spring重点小总结" class="headerlink" title="Spring重点小总结"></a>Spring重点小总结</h1><p>学完SpringBoot,再回头来看了看Spring，有了些新的理解，记录一下自己的学习笔记！！</p>
<h2 id="IOC理解"><a href="#IOC理解" class="headerlink" title="IOC理解"></a>IOC理解</h2><p>他是一种<strong>设计思想</strong>，而不是一种技术。</p>
<p>核心是将<strong>业务选择</strong>交到了<strong>用户</strong>手中，用户想使用什么样的方法完成业务就用什么样的方法，自己轻松配置一下即可。IOC使程序的耦合性大大降低了。最明显的体现就是业务层调用相应Dao层的灵活性，不用再自动注入一个特定的Dao来完成业务，只需要指定一个抽象的Dao，至于什么样的Dao，交给Setter构造器配置就行了，程序员只需要注重业务代码的编写即可。</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>Spring 容器在初始化一个 Bean 的实例时，同时会指定该实例的作用域。Spring3 为 Bean 定义了五种作用域，具体如下。</p>
<ul>
<li><h4 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h4></li>
</ul>
<p><strong>单例模式</strong>，使用 singleton 定义的 Bean 在 Spring 容器中只有一个实例，这也是 Bean 默认的作用域。</p>
<ul>
<li><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4></li>
</ul>
<p><strong>原型模式</strong>，每次通过 Spring 容器获取 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例。</p>
<ul>
<li><h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4></li>
</ul>
<p>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Request 内有效。</p>
<ul>
<li><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4></li>
</ul>
<p>在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效。</p>
<ul>
<li><h4 id="global-Session"><a href="#global-Session" class="headerlink" title="global Session"></a>global Session</h4></li>
</ul>
<p>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。该作用域仅在使用 portlet context 时有效。</p>
<p>在上述五种作用域中，singleton 和 prototype 是最常用的两种，接下来将对这两种作用域进行详细讲解。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>主要掌握两个类（都是反射包下的）</p>
<ul>
<li>Proxy: 代理类，提供了创建动态代理类和实例的<strong>静态方法</strong>?</li>
<li>InvocationHandler: 是由代理实例<strong>调用处理程序</strong>实现的接口。每一个代理实例都有一个关联的<strong>调用处理程序</strong>，当在代理实例上调用方法时，方法调用将被编码并分派到对应调用处理程序<strong>invoke方法</strong>说通俗一点，定义了指定代理实例的InvocationHandler，就等于说其对应的一系列方法被invoke接管了，invoke就是处理代理实例对应代理的接口所定义的一系列方法?</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">//处理代理实例上的方法并返回相应结果</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>invoke</strong>方法<strong>三个参数</strong>?</p>
<ul>
<li><code>Object Proxy</code>:  该方法的代理实例</li>
<li><code>Method method</code>：就是你要代理这个实例里面的哪个方法</li>
<li><code>Object[] args</code>：给对应方法里的执行参数</li>
</ul>
<p>动态代理类模板如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRent</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成得到代理类</span></span><br><span class="line">    <span class="keyword">public</span>  Object <span class="title function_">getProxy</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建一个代理类</span></span><br><span class="line">        <span class="comment">//第一个参数：定义代理类的类加载器</span></span><br><span class="line">        <span class="comment">//第二个参数：代理类实现的接口列表</span></span><br><span class="line">        <span class="comment">//第三个参数：将方法调用分派到的调用处理程序</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理代理实例并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//动态代理的本质就是使用反射机制实现的！！</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个类是通用的，只用改变被代理的类即可。</p>
<h2 id="Spring实现Aop"><a href="#Spring实现Aop" class="headerlink" title="Spring实现Aop"></a>Spring实现Aop</h2><p>需要导入一个依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<p>代理是代理的抽象接口，而不是对应的实现类，因为你想，如果代理类，可以说就没有意义了。</p>
<p>包括了<strong>三种方式</strong>：</p>
<ol>
<li>重写自带的方法前，后的接口方法，并配置xml文件。</li>
<li>也可以自定义自己的切片方法，并配置xml文件。</li>
<li>最简单的一种，使用注解实现。</li>
</ol>
<p>虽然方法不同，但<strong>原理都是相同</strong>的：</p>
<p><strong>定义切片–&gt;说明切片的切入点–&gt;切片在方法前后执行哪些方法。</strong></p>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><h3 id="回顾事务"><a href="#回顾事务" class="headerlink" title="回顾事务"></a>回顾事务</h3><ul>
<li>把一组业务当成一个业务来做，要么都成功，要么都失败</li>
<li>事务在项目开发中，十分的重要，涉及到数据一致性问题</li>
<li>确保完整性和一致性</li>
</ul>
<h3 id="事务ACID-原则"><a href="#事务ACID-原则" class="headerlink" title="事务ACID 原则"></a>事务ACID 原则</h3><ul>
<li><p>A： 原子性</p>
</li>
<li><p>C:    一致性</p>
</li>
<li><p>I： 隔离性: 多个业务可能操作同一个资源，防止数据损坏</p>
</li>
<li><p>D：持久性：事务一旦提交，无论系统发生什么问题，结果都不会被影响，被持久化到存储器中</p>
</li>
</ul>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><ul>
<li>声明式事务：AOP 横切进去一个事务，不改变原有的代码</li>
<li>编程式事务：需要在代码中编写事务来进行事务管理</li>
</ul>
<h1 id="总结一句话"><a href="#总结一句话" class="headerlink" title="总结一句话"></a>总结一句话</h1><p>Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot集成使用Swagger</title>
    <url>/2022/02/21/Swagger/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h1><p>号称世界上最流行的API框架</p>
<p>Restful Api 文档在线自动生成器 &#x3D;&gt; API 文档 与API 定义同步更新</p>
<p>直接运行，在线测试API</p>
<p>支持多种语言 （如：Java，PHP等）</p>
<p><strong>官网</strong>：<a href="https://swagger.io/">https://swagger.io/</a></p>
<h1 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h1><p>SpringBoot集成Swagger &#x3D;&gt; springfox，两个jar包</p>
<p>Springfox-&gt;swagger2</p>
<p>swagger-&gt;springmvc</p>
<h3 id="使用Swagger"><a href="#使用Swagger" class="headerlink" title="使用Swagger"></a>使用Swagger</h3><p><strong>要求：</strong></p>
<p>jdk 1.8 + 否则swagger2无法运行</p>
<p><strong>springboot2.6以上需要加入这个配置：</strong></p>
<p><code>spring.mvc.pathmatch.matching-strategy=ant_path_matcher</code></p>
<p><strong>步骤：</strong></p>
<p>1、新建一个SpringBoot-web项目</p>
<p>2、添加Maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;   </span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;/groupId&gt;   </span><br><span class="line">	&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;   </span><br><span class="line">	&lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;   </span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;/groupId&gt;   </span><br><span class="line">	&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;   </span><br><span class="line">	&lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、编写HelloController，测试确保运行成功！</p>
<p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration //配置类</span><br><span class="line">@EnableSwagger2// 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p>
<h1 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h1><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean //配置docket以配置Swagger具体参数</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、可以通过apiInfo()属性配置文档信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置文档信息</span><br><span class="line">private ApiInfo apiInfo() &#123;</span><br><span class="line">   Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);</span><br><span class="line">   return new ApiInfo(</span><br><span class="line">           &quot;Swagger学习&quot;, // 标题</span><br><span class="line">           &quot;学习演示如何配置Swagger&quot;, // 描述</span><br><span class="line">           &quot;v1.0&quot;, // 版本</span><br><span class="line">           &quot;http://terms.service.url/组织链接&quot;, // 组织链接</span><br><span class="line">           contact, // 联系人信息</span><br><span class="line">           &quot;Apach 2.0 许可&quot;, // 许可</span><br><span class="line">           &quot;许可链接&quot;, // 许可连接</span><br><span class="line">           new ArrayList&lt;&gt;()// 扩展</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、Docket 实例关联上 apiInfo()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> 看下效果；</p>
<h1 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h1><p>1、构建Docket时通过select()方法配置怎么扫描接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.swagger.controller&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any() // 扫描所有，项目中的所有接口都会被扫描到</span><br><span class="line">none() // 不扫描接口</span><br><span class="line">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span><br><span class="line">withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span><br><span class="line">withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">basePackage(final String basePackage) // 根据包路径扫描接口</span><br></pre></td></tr></table></figure>

<p>4、除此之外，我们还可以配置接口扫描过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、这里的可选值还有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any() // 任何请求都扫描</span><br><span class="line">none() // 任何请求都不扫描</span><br><span class="line">regex(final String pathRegex) // 通过正则表达式控制</span><br><span class="line">ant(final String antPattern) // 通过ant()控制</span><br></pre></td></tr></table></figure>

<h1 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h1><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket(Environment environment) &#123;</span><br><span class="line">   // 设置要显示swagger的环境</span><br><span class="line">   Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);</span><br><span class="line">   // 判断当前是否处于该环境</span><br><span class="line">   // 通过 enable() 接收此参数判断是否要显示</span><br><span class="line">   boolean b = environment.acceptsProfiles(of);</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h1><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2022/03/10/kuangstudy5c5353a7-942a-4949-b2ba-a44841cc9442.png" alt="img"><br>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket(Environment environment) &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">      .groupName(&quot;hello&quot;) // 配置分组</span><br><span class="line">       // 省略配置....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、重启项目查看分组</p>
<p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket1</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket2</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket3</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、重启项目查看即可</p>
<h1 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h1><p>1、新建一个实体类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">   @ApiModelProperty(&quot;用户名&quot;)</span><br><span class="line">   public String username;</span><br><span class="line">   @ApiModelProperty(&quot;密码&quot;)</span><br><span class="line">   public String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>](https:<span class="comment">//github.com/RequestMapping)(“/getUser”)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、重启查看测试<br><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2022/03/10/kuangstudy34aa674f-d072-4aa8-aedf-e248aff6a0a3.png" alt="img"><br>注：并不是因为<a href="https://github.com/ApiModel">@ApiModel</a>这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而<a href="https://github.com/ApiModel">@ApiModel</a>和<a href="https://github.com/ApiModelProperty">@ApiModelProperty</a>这两个注解只是为实体添加注释的。</p>
<p><a href="https://github.com/ApiModel">@ApiModel</a>为类添加注释</p>
<p><a href="https://github.com/ApiModelProperty">@ApiModelProperty</a>为类属性添加注释</p>
<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：<br><code>[@Api](https://github.com/Api)(tags = “xxx模块说明”)</code>作用在模块类上<br><code>[@ApiOperation](https://github.com/ApiOperation)(“xxx接口说明”) </code>作用在接口方法上<br><code>[@ApiModel](https://github.com/ApiModel)(“xxxPOJO说明”) </code>作用在模型类上：如VO、BO<br><code>[@ApiModelProperty](https://github.com/ApiModelProperty)(value = “xxx属性说明”,hidden = true)</code>作用在类方法和属性上，hidden设置为true可以隐藏该属性**<br><code>[@ApiParam](https://github.com/ApiParam)(“xxx参数说明”) </code>作用在参数、方法和字段上，类似<a href="https://github.com/ApiModelProperty">@ApiModelProperty</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;狂神的接口&quot;)</span><br><span class="line">@PostMapping(&quot;/kuang&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;</span><br><span class="line">   return username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h1 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、默认的   访问 http://localhost:8080/swagger-ui.html</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">2、bootstrap-ui  访问 http://localhost:8080/doc.html</span><br><span class="line"><span class="comment">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">3、Layui-ui   访问 http://localhost:8080/docs.html</span><br><span class="line"><span class="comment">&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.caspar-chen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-ui-layer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">4、mg-ui   访问 http://localhost:8080/document.html</span><br><span class="line"><span class="comment">&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zyplayer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-mg-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity笔记</title>
    <url>/2022/03/13/SpringSecurity/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringSecurity笔记"><a href="#SpringSecurity笔记" class="headerlink" title="SpringSecurity笔记"></a>SpringSecurity笔记</h1><p>本质就是内置了一条过滤器链，通过FilterChainProxy调度。</p>
<p><strong>其中重点关注两个过滤器</strong></p>
<ul>
<li><p><code>UsernamePasswordAuthenticationFilter</code>：负责登录认证</p>
</li>
<li><p><code>FilterSecurityInterceptor</code>：负责权限授权</p>
</li>
</ul>
<p>Authentication: 一般放在上下文SecurityContext中，储存认证信息，代表当前认证用户，而上下文（context）又由SecurityContextHolder管理。</p>
<p>SecurityContextHolder类似ThreadLocal，保证上下文对象一样，一个线程只储存一个对象，就不用每个方法都多传一个对象参数了，方便了不少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br></pre></td></tr></table></figure>



<p><em><strong>调用链路：SecurityContextHolder—-&gt;SecurityContext—-&gt;Authentication</strong></em></p>
<p>咱们主要做的工作就是对过滤器的扩展，因为有些过滤器的功能并不是我们想要的，我们只需要自定义一个配置类，并继承<code>WebSecurityConfigurerAdapter</code>即定制化配置了。</p>
<p>登录认证分为Session和JWT方式，后一种一般用在前后端分离项目的单点登录场景中。</p>
<p><strong>SpringSecurity的三大核心组件：</strong></p>
<ul>
<li><p><strong>Authentication</strong>：储存了认证信息，即当前登录用户的信息，代表了当前登录用户。</p>
</li>
<li><p><strong>SecurityContext</strong>:  上下文对象，用来获取Authentication。</p>
</li>
<li><p><strong>SecurityContextHolder</strong>： 上下文管理对象，用来在程序中可以在任何地方获取SecurityContext。</p>
</li>
</ul>
<p><strong>再对Authentication进行刨析</strong></p>
<p>Authentication中包含有三个认证信息：</p>
<ul>
<li><strong>Principle</strong>： 用户信息，没有认证时一般就是<strong>用户名</strong>，认证后一般就是<strong>用户对象</strong>。</li>
<li><strong>Credentials</strong>： 用户凭证， 一般是<strong>密码</strong>。</li>
<li><strong>Authorities</strong>： 用户权限</li>
</ul>
<p>懂得了Authentication是怎么获取的后，接下来就是认证工作了。</p>
<p>在不使用SpringSecurity时，咱们的认证流程一般是这样的，其实就是登录流程：</p>
<p><strong>通过用户名查到用户数据–&gt;判断账号密码是否正确—&gt;正确就将用户信息存在1上下文中（Redis）—-&gt;若上下文能找到这个用户，说明该用户已经登录了</strong></p>
<p>其实使用SpringSecurity的认证流程也是如此：</p>
<p>将用户认证信息放在上下文中，随处可取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(用户名, 用户密码, 用户的权限集合);</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authentication);</span><br></pre></td></tr></table></figure>

<p>但咱们的认证流程不可能就这么简单吧，密码啥的都还没判断呢就直接放在上下文了，这不是等于没有认证吗？？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用service层执行判断业务逻辑</span></span><br><span class="line"><span class="keyword">if</span> (!userService.login(用户名, 用户密码)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;账号密码错误&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 账号密码正确了才将认证信息放到上下文中（用户权限需要再从数据库中获取，后面再说，这里省略）</span></span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(用户名, 用户密码, 用户的权限集合);</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authentication);</span><br></pre></td></tr></table></figure>

<p>那么我们调用service层业务处理判断用户的信息即可，这样才算是一个完整的认证流程，只是一些组件变化了而已。</p>
<p>这里查询用户验证用户的一系列信息都是我们在service层自己编写的，其实，SpringSecurity在这一块也提供了组件(AuthenticationManager)供我们使用。</p>
<p><strong>AuthenticationManager认证方式</strong></p>
<p>AuthenticationManager: 就是提供的执行身份认证的组件。只需要调用他的Authenticate方法即可完成认证了。</p>
<p>可以Debug，其实SpringSecurity的默认认证方式就是在UsernamePasswordAuthenticationFilter这个过滤器中调用了AuthenticationManager来完成认证逻辑。</p>
<p><strong>流程：</strong></p>
<p>1.用户传递账号密码过来， 登录接口掉用AuthenticationManager</p>
<p>2.根据用户名查询出用户数据：即UserDetailService查询出UserDetails</p>
<p>3.将校验通过的认证信息存到上下文中：即将UserDetails存入Authentication，Authentication存入SecurityContext</p>
<p>4.如果认证失败，交给AuthenticationEntryPoint处理</p>
<p>要定制逻辑，只需要编写自己的UserDetailService，PasswordEncoder然后添加到SpringSecurity配置中，如下</p>
<p>自定义UserServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>, UserDetailsService &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 从数据库中查询出用户实体对象</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByUsername(username);</span><br><span class="line">        <span class="comment">// 若没查询到一定要抛出该异常，这样才能被Spring Security的错误处理器处理</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;没有找到该用户&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这代表查询到了实体对象，那就返回我们自定义的UserDetail对象（这里权限暂时放个空集合，后面我会讲解）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDetail</span>(user, Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 关闭csrf和frameOptions，如果不关闭会影响前端请求接口（这里不展开细讲了，感兴趣的自行了解）</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        http.headers().frameOptions().disable();</span><br><span class="line">        <span class="comment">// 开启跨域以便前端调用接口</span></span><br><span class="line">        http.cors();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是配置的关键，决定哪些接口开启防护，哪些接口绕过防护</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">            	<span class="comment">// 注意这里，是允许前端跨域联调的一个必要配置</span></span><br><span class="line">                .requestMatchers(CorsUtils::isPreFlightRequest).permitAll()</span><br><span class="line">                <span class="comment">// 指定某些接口不需要通过验证即可访问。登陆、注册接口肯定是不需要认证的</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/API/login&quot;</span>, <span class="string">&quot;/API/register&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 这里意思是其它所有接口需要认证才能访问</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                <span class="comment">// 指定认证错误处理器</span></span><br><span class="line">                .and().exceptionHandling().authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">MyEntryPoint</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定制化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 指定UserDetailService和加密器</span></span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他逻辑跟普通认证逻辑一样，只不过重新写了SpringSecurity默认的一些组件并配置进去了，后面调用他们进行认证就行了。</p>
<p>详细的可以看这篇博客：<a href="https://juejin.cn/post/6900721218207350791">https://juejin.cn/post/6900721218207350791</a></p>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动配置(二)</title>
    <url>/2022/01/22/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE(%E4%BA%8C)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot自动配置-二"><a href="#SpringBoot自动配置-二" class="headerlink" title="SpringBoot自动配置(二)"></a>SpringBoot自动配置(二)</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><blockquote>
<p>友情提示：因为本文是分享 Spring Boot 自动配置的原理，所以需要胖友有使用过 Spring Boot 的经验。如果还没使用过的胖友，不用慌，先跳转到<a href="http://www.iocoder.cn/Spring-Boot/SpringMVC/?self">《芋道 Spring Boot SpringMVC 入门》</a>文章，将前两节阅读完，感受下 Spring Boot 的魅力。</p>
</blockquote>
<p>Spring Boot 自动配置，顾名思义，是希望能够自动配置，将我们从配置的苦海中解脱出来。那么既然要自动配置，它需要解三个问题：</p>
<ul>
<li>满足什么样的<strong>条件</strong>？</li>
<li>创建<strong>哪些</strong> Bean？</li>
<li>创建的 Bean 的<strong>属性</strong>？</li>
</ul>
<p>我们来举个示例，对照下这三个问题。在我们引入 <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web"><code>spring-boot-starter-web</code></a> 依赖，会创建一个 8080 端口的内嵌 Tomcat，同时可以通过 <code>application.yaml</code> 配置文件中的 <code>server.port</code> 配置项自定义端口。那么这三个问题的答案如下：</p>
<blockquote>
<p>友情提示：为了更易懂，这里的答案暂时是表象的，不绝对精准。</p>
</blockquote>
<ul>
<li>满足什么样的<strong>条件</strong>？因为我们引入了 <code>spring-boot-starter-web</code> 依赖。</li>
<li>创建<strong>哪些</strong> Bean？创建了一个内嵌的 Tomcat Bean，并进行启动。</li>
<li>创建的 Bean 的<strong>属性</strong>？通过 <code>application.yaml</code> 配置文件的 <code>server.port</code> 配置项，定义 Tomcat Bean 的启动端口属性，并且默认值为 8080。</li>
</ul>
<p>壮着胆子，我们来看看 Spring Boot 提供的 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/embedded/EmbeddedWebServerFactoryCustomizerAutoConfiguration.java">EmbeddedWebServerFactoryCustomizerAutoConfiguration</a> 类，负责创建内嵌的 Tomcat、Jetty 等等 Web 服务器的配置类。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// &lt;1.1&gt;</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">// &lt;2.1&gt;</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span> <span class="comment">// &lt;3.1&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">EmbeddedWebServerFactoryCustomizerAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Tomcat is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Configuration</span> <span class="comment">// &lt;1.2&gt;</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(&#123; Tomcat.class, UpgradeProtocol.class &#125;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TomcatWebServerFactoryCustomizerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> TomcatWebServerFactoryCustomizer <span class="title function_">tomcatWebServerFactoryCustomizer</span><span class="params">(</span></span><br><span class="line"><span class="params">				Environment environment, ServerProperties serverProperties)</span> &#123;</span><br><span class="line">			<span class="comment">// &lt;3.2&gt;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatWebServerFactoryCustomizer</span>(environment, serverProperties);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Jetty is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Configuration</span> <span class="comment">// &lt;1.3&gt;</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(&#123; Server.class, Loader.class, WebAppContext.class &#125;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JettyWebServerFactoryCustomizerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> JettyWebServerFactoryCustomizer <span class="title function_">jettyWebServerFactoryCustomizer</span><span class="params">(</span></span><br><span class="line"><span class="params">				Environment environment, ServerProperties serverProperties)</span> &#123;</span><br><span class="line">			 <span class="comment">// &lt;3.3&gt;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JettyWebServerFactoryCustomizer</span>(environment, serverProperties);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Undertow is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// ... 省略 UndertowWebServerFactoryCustomizerConfiguration 代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Netty is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// ... 省略 NettyWebServerFactoryCustomizerConfiguration 代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开始看代码之前，我们先来简单科普下 <a href="https://docs.spring.io/spring-javaconfig/docs/1.0.0.M4/reference/html/">Spring JavaConfig</a> 的小知识。在 Spring3.0 开始，Spring 提供了 JavaConfig 的方式，允许我们使用 Java 代码的方式，进行 Spring Bean 的创建。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">object</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Obejct</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过在<strong>类</strong>上添加 <a href="https://docs.spring.io/spring-javaconfig/docs/1.0.0.M4/reference/html/ch02.html#d0e270"><code>@Configuration</code></a> 注解，声明这是一个 Spring 配置类。</li>
<li>通过在<strong>方法</strong>上添加 <a href="https://docs.spring.io/spring-javaconfig/docs/1.0.0.M4/reference/html/ch02s02.html"><code>@Bean</code></a> 注解，声明该方法创建一个 Spring Bean。</li>
</ul>
<p>OK，现在我们在回过头看看 EmbeddedWebServerFactoryCustomizerAutoConfiguration 的代码，我们分成三块内容来讲，刚好解决我们上面说的三个问题：</p>
<ul>
<li>① 配置类</li>
<li>② 条件注解</li>
<li>③ 配置属性</li>
</ul>
<p><strong>① 配置类</strong></p>
<p><code>&lt;1.1&gt;</code> 处，在类上添加了 <code>@Configuration</code> 注解，声明这是一个<strong>配置类</strong>。因为它的目的是自动配置，所以类名以 AutoConfiguration 作为后缀。</p>
<p><code>&lt;1.2&gt;</code>、<code>&lt;1.3&gt;</code> 处，分别是用于初始化 Tomcat、Jetty 相关 Bean 的配置类。</p>
<ul>
<li>TomcatWebServerFactoryCustomizerConfiguration 配置类，负责创建 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/embedded/TomcatWebServerFactoryCustomizer.java">TomcatWebServerFactoryCustomizer</a> Bean，从而初始化内嵌的 Tomcat 并进行启动。</li>
<li>JettyWebServerFactoryCustomizer 配置类，负责创建 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/embedded/JettyWebServerFactoryCustomizer.java">JettyWebServerFactoryCustomizer</a> Bean，从而初始化内嵌的 Jetty 并进行启动。</li>
</ul>
<p><strong>如此，我们可以得到结论一，通过 <code>@Configuration</code> 注解的配置类，可以解决“创建哪些 Bean”的问题。</strong></p>
<p>实际上，Spring Boot 的 <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure">spring-boot-autoconfigure</a> 项目，提供了大量框架的自动配置类，稍后我们在<a href="http://www.iocoder.cn/Spring-Boot/autoconfigure/?github#">「2. 自动配置类」</a>小节详细展开。</p>
<p><strong>② 条件注解</strong></p>
<p><code>&lt;2&gt;</code> 处，在类上添加了 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionalOnWebApplication.java"><code>@ConditionalOnWebApplication</code></a> <strong>条件注解</strong>，表示当前配置类需要在当前项目是 Web 项目的条件下，才能生效。在 Spring Boot 项目中，会将项目类型分成 Web 项目（使用 SpringMVC 或者 WebFlux）和非 Web 项目。这样我们就很容易理解，为什么 EmbeddedWebServerFactoryCustomizerAutoConfiguration 配置类会要求在项目类型是 Web 项目，只有 Web 项目才有必要创建内嵌的 Web 服务器呀。</p>
<p><code>&lt;2.1&gt;</code>、<code>&lt;2.2&gt;</code> 处，在类上添加了 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionalOnClass.java"><code>@ConditionalOnClass</code></a> <strong>条件注解</strong>，表示当前配置类需要在当前项目有指定类的条件下，才能生效。</p>
<ul>
<li>TomcatWebServerFactoryCustomizerConfiguration 配置类，需要有 <a href="https://mvnrepository.com/search?q=tomcat-embed-core"><code>tomcat-embed-core</code></a> 依赖提供的 Tomcat、UpgradeProtocol 依赖类，才能创建内嵌的 Tomcat 服务器。</li>
<li>JettyWebServerFactoryCustomizer 配置类，需要有 <a href="https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-server"><code>jetty-server</code></a> 依赖提供的 Server、Loader、WebAppContext 类，才能创建内嵌的 Jetty 服务器。</li>
</ul>
<p><strong>如此，我们可以得到结论二，通过条件注解，可以解决“满足什么样的条件？”的问题。</strong></p>
<p>实际上，Spring Boot 的 <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition"><code>condition</code></a> 包下，提供了大量的条件注解，稍后我们在<a href="http://www.iocoder.cn/Spring-Boot/autoconfigure/?github#">「2. 条件注解」</a>小节详细展开。</p>
<p><strong>③ 配置属性</strong></p>
<p><code>&lt;3.1&gt;</code> 处，使用 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/EnableConfigurationProperties.java"><code>@EnableConfigurationProperties</code></a> 注解，让 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java">ServerProperties</a> <strong>配置属性类</strong>生效。在 Spring Boot 定义了 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationProperties.java"><code>@ConfigurationProperties</code></a> 注解，用于声明配置属性类，将指定前缀的配置项批量注入到该类中。例如 ServerProperties 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerProperties</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">EmbeddedServletContainerCustomizer</span>, EnvironmentAware, Ordered &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Server HTTP port.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Context path of the application.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String contextPath;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ... 省略其它属性</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>@ConfigurationProperties</code> 注解，声明将 <code>server</code> 前缀的配置项，设置到 ServerProperties 配置属性类中。</li>
</ul>
<p><code>&lt;3.2&gt;</code>、<code>&lt;3.3&gt;</code> 处，在创建 TomcatWebServerFactoryCustomizer 和 JettyWebServerFactoryCustomizer 对象时，都会将 ServerProperties 传入其中，作为后续创建的 Web 服务器的配置。也就是说，我们通过修改在配置文件的配置项，就可以自定义 Web 服务器的配置。</p>
<p><strong>如此，我们可以得到结论三，通过配置属性，可以解决“创建的 Bean 的属性？”的问题。</strong></p>
<hr>
<p>🐶 至此，我们已经比较清晰的理解 Spring Boot 是怎么解决我们上面提出的三个问题，但是这样还是无法实现自动配置。例如说，我们引入的 <code>spring-boot-starter-web</code> 等依赖，Spring Boot 是怎么知道要扫码哪些配置类的。下面，继续我们的旅途，继续抽丝剥茧。</p>
<h1 id="2-自动配置类"><a href="#2-自动配置类" class="headerlink" title="2. 自动配置类"></a>2. 自动配置类</h1><p>在 Spring Boot 的 <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure">spring-boot-autoconfigure</a> 项目，提供了大量框架的自动配置，如下图所示：![<code>spring-boot-autoconfigure</code>](第二章-Spring  Boot自动配置原理.assets&#x2F;01.png)</p>
<p>在我们通过 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/SpringApplication.java#L1218-L1227"><code>SpringApplication#run(Class primarySource, String... args)</code></a> 方法，启动 Spring Boot 应用的时候，有个非常重要的组件 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/support/SpringFactoriesLoader.java">SpringFactoriesLoader</a> 类，会读取 <code>META-INF</code> 目录下的 <code>spring.factories</code> 文件，获得<strong>每个框架定义的需要自动配置的配置类</strong>。</p>
<p>我们以 <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure">spring-boot-autoconfigure</a> 项目的 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories">Spring Boot <code>spring.factories</code></a> 文件来举个例子，如下图所示：![<code>spring.factories</code>](第二章-Spring  Boot自动配置原理.assets&#x2F;02.png)</p>
<p>如此，原先 <code>@Configuration</code> 注解的配置类，就<strong>升级</strong>成类自动配置类。这样，Spring Boot 在获取到需要自动配置的配置类后，就可以自动创建相应的 Bean，完成自动配置的功能。</p>
<blockquote>
<p>旁白君：这里其实还有一个非常有意思的话题，作为拓展知识，胖友可以后续去看看。实际上，我们可以把 <code>spring.factories</code> 理解成 Spring Boot 自己的 SPI 机制。感兴趣的胖友，可以看看如下的文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/Fight/SPI-mechanism-in-Spring-Boot/?self">《Spring Boot 的 SPI 机制》</a></li>
<li><a href="http://www.iocoder.cn/Fight/xuma/spi/?self">《Java 的 SPI 机制》</a></li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/dev/SPI.html">《Dubbo 的 SPI 机制》</a></li>
</ul>
<p>实际上，自动配置只是 Spring Boot 基于 <code>spring.factories</code> 的一个拓展点 EnableAutoConfiguration。我们从上图中，还可以看到如下的拓展点：</p>
<ul>
<li>ApplicationContextInitializer</li>
<li>ApplicationListener</li>
<li>AutoConfigurationImportListener</li>
<li>AutoConfigurationImportFilter</li>
<li>FailureAnalyzer</li>
<li>TemplateAvailabilityProvider</li>
</ul>
</blockquote>
<p>因为 spring-boot-autoconfigure 项目提供的是它选择的主流框架的自动配置，所以其它框架需要自己实现。例如说，Dubbo 通过 <a href="https://github.com/apache/dubbo-spring-boot-project">dubbo-spring-boot-project</a> 项目，提供 Dubbo 的自动配置。如下图所示：![Dubbo <code>spring.factories</code>](第二章-Spring  Boot自动配置原理.assets&#x2F;03.png)</p>
<h1 id="3-条件注解"><a href="#3-条件注解" class="headerlink" title="3. 条件注解"></a>3. 条件注解</h1><p>条件注解并不是 Spring Boot 所独有，而是在 Spring3.1 版本时，为了满足不同环境注册不同的 Bean ，引入了 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/Profile.java"><code>@Profile</code></a> 注解。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&quot;DEV&quot;)</span><br><span class="line">    public DataSource devDataSource() &#123;</span><br><span class="line">        // ... 单机 MySQL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&quot;PROD&quot;)</span><br><span class="line">    public DataSource prodDataSource() &#123;</span><br><span class="line">        // ... 集群 MySQL</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在测试环境下，我们注册单机 MySQL 的 DataSource Bean。</li>
<li>在生产环境下，我们注册集群 MySQL 的 DataSource Bean。</li>
</ul>
<p>在 Spring4 版本时，提供了 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/Conditional.java"><code>@Conditional</code></a> 注解，用于声明在配置类或者创建 Bean 的方法上，表示需要满足指定条件才能生效。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TestConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Conditional(XXXCondition.class)</span><br><span class="line">    public Object xxxObject() &#123;</span><br><span class="line">        return new Object();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，XXXCondition 需要我们自己实现 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/Condition.java">Condition</a> 接口，提供具体的条件实现。</li>
</ul>
<p>显然，Spring4 提交的 <code>@Conditional</code> 注解非常不方便，需要我们自己去拓展。因此，Spring Boot 进一步增强，提供了常用的条件注解：</p>
<ul>
<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li>
<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>
<li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li>
<li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
<li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li>
<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li>
<li><code>@ConditionalOnWebApplication</code>：当前项目是 Web项 目的条件下</li>
</ul>
<h1 id="4-配置属性"><a href="#4-配置属性" class="headerlink" title="4. 配置属性"></a>4. 配置属性</h1><p>Spring Boot 约定读取 <code>application.yaml</code>、<code>application.properties</code> 等配置文件，从而实现创建 Bean 的自定义属性配置，甚至可以搭配 <code>@ConditionalOnProperty</code> 注解来取消 Bean 的创建。</p>
<p>咳咳咳，貌似这个小节没有太多可以分享的内容，更多胖友可以阅读<a href="http://www.iocoder.cn/Spring-Boot/config-file/?self">《芋道 Spring Boot 配置文件入门》</a>文章。</p>
<h1 id="5-内置-Starter"><a href="#5-内置-Starter" class="headerlink" title="5. 内置 Starter"></a>5. 内置 Starter</h1><p>我们在使用 Spring Boot 时，并不会直接引入 <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-autoconfigure"><code>spring-boot-autoconfigure</code></a> 依赖，而是使用 Spring Boot 内置提供的 Starter 依赖。例如说，我们想要使用 SpringMVC 时，引入的是 <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web"><code>spring-boot-starter-web</code></a> 依赖。这是为什么呢？</p>
<p>因为 Spring Boot 提供的自动配置类，基本都有 <code>@ConditionalOnClass</code> 条件注解，判断我们项目中存在指定的类，才会创建对应的 Bean。而拥有指定类的前提，一般是需要我们引入对应框架的依赖。</p>
<p>因此，在我们引入 <code>spring-boot-starter-web</code> 依赖时，它会帮我们自动引入相关依赖，从而保证自动配置类能够生效，创建对应的 Bean。如下图所示：![<code>spring-boot-starter-web</code>](第二章-Spring  Boot自动配置原理.assets&#x2F;11-20200907070313426.png)</p>
<p>Spring Boot 内置了非常多的 Starter，方便我们引入不同框架，并实现自动配置。如下图所示：![Spring Boot Starter](第二章-Spring  Boot自动配置原理.assets&#x2F;12-20200907070313269.png)</p>
<h1 id="6-自定义-Starter"><a href="#6-自定义-Starter" class="headerlink" title="6. 自定义 Starter"></a>6. 自定义 Starter</h1><p>在一些场景下，我们需要自己实现自定义 Starter 来达到自动配置的目的。例如说：</p>
<ul>
<li>三方框架并没有提供 Starter，比如说 <a href="https://github.com/swagger-api">Swagger</a>、<a href="https://github.com/xuxueli/xxl-job">XXL-JOB</a> 等。</li>
<li>Spring Boot 内置的 Starter 无法满足自己的需求，比如说 <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc"><code>spring-boot-starter-jdbc</code></a> 不提供多数据源的配置。</li>
<li>随着项目越来越大，想要提供适合自己团队的 Starter 来方便配置项目，比如说永辉彩食鲜 <a href="https://gitee.com/yhcsx/csx-bsf-all">csx-bsf-all</a> 项目。</li>
</ul>
<p>下面，我们一起来实现一个自定义 Starter，实现一个 Java 内置 <a href="https://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpServer.html">HttpServer</a> 服务器的自动化配置。最终项目如下图所示：![最终项目](第二章-Spring  Boot自动配置原理.assets&#x2F;21.png)</p>
<p>在开始示例之前，我们要了解下 Spring Boot Starter 的<strong>命名规则</strong>，显得我们更加专业（装逼）。命名规则如下：</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">命名规则</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Spring Boot 内置</strong> Starter</td>
<td align="left"><code>spring-boot-starter-&#123;框架&#125;</code></td>
<td align="left"><code>spring-boot-starter-web</code></td>
</tr>
<tr>
<td align="left">框架 <strong>自定义</strong> Starter</td>
<td align="left"><code>&#123;框架&#125;-spring-boot-starter</code></td>
<td align="left"><a href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter"><code>mybatis-spring-boot-starter</code></a></td>
</tr>
<tr>
<td align="left">公司 <strong>自定义</strong> Starter</td>
<td align="left"><code>&#123;公司&#125;-spring-boot-starter-&#123;框架&#125;</code></td>
<td align="left">暂无，艿艿自己的想法哈</td>
</tr>
</tbody></table>
<h2 id="6-1-yunai-server-spring-boot-starter-项目"><a href="#6-1-yunai-server-spring-boot-starter-项目" class="headerlink" title="6.1 yunai-server-spring-boot-starter 项目"></a>6.1 yunai-server-spring-boot-starter 项目</h2><p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-47/yunai-server-spring-boot-starter">yunai-server-spring-boot-starter</a> 项目，实现一个 Java 内置 HttpServer 服务器的自动化配置。考虑到示例比较简单，我们就不像 Spring Boot 拆分成 <code>spring-boot-autoconfigure</code> 和 <code>spring-boot-starter-&#123;框架&#125;</code> 两个项目。</p>
<h3 id="6-1-1-引入依赖"><a href="#6-1-1-引入依赖" class="headerlink" title="6.1.1 引入依赖"></a>6.1.1 引入依赖</h3><p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/yunai-server-spring-boot-starter/pom.xml"><code>pom.xml</code></a> 文件中，引入相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lab-47<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.iocoder.springboot.labs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yunai-server-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入 Spring Boot Starter 基础库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-1-2-YunaiServerProperties"><a href="#6-1-2-YunaiServerProperties" class="headerlink" title="6.1.2 YunaiServerProperties"></a>6.1.2 YunaiServerProperties</h3><p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/yunai-server-spring-boot-starter/src/main/java/cn/iocoder/springboot/lab47/yunaiserver/autoconfigure/"><code>cn.iocoder.springboot.lab47.yunaiserver.autoconfigure</code></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/yunai-server-spring-boot-starter/src/main/java/cn/iocoder/springboot/lab47/yunaiserver/autoconfigure/YunaiServerProperties.java">YunaiServerProperties</a> 配置属性类，读取 <code>yunai.server</code> 前缀的配置项。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;yunai.server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YunaiServerProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DEFAULT_PORT</span> <span class="operator">=</span> <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">port</span> <span class="operator">=</span> DEFAULT_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getDefaultPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_PORT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> YunaiServerProperties <span class="title function_">setPort</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-3-YunaiServerAutoConfiguration"><a href="#6-1-3-YunaiServerAutoConfiguration" class="headerlink" title="6.1.3 YunaiServerAutoConfiguration"></a>6.1.3 YunaiServerAutoConfiguration</h3><p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/yunai-server-spring-boot-starter/src/main/java/cn/iocoder/springboot/lab47/yunaiserver/autoconfigure/"><code>cn.iocoder.springboot.lab47.yunaiserver.autoconfigure</code></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/yunai-server-spring-boot-starter/src/main/java/cn/iocoder/springboot/lab47/yunaiserver/autoconfigure/YunaiServerAutoConfiguration.java">YunaiServerAutoConfiguration</a> 自动配置类，在项目中存在 <code>com.sun.net.httpserver.HttpServer</code> 类时，创建 HttpServer Bean，并启动该服务器。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 声明配置类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(YunaiServerProperties.class)</span> <span class="comment">// 使 YunaiServerProperties 配置属性类生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YunaiServerAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(YunaiServerAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 声明创建 Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(HttpServer.class)</span> <span class="comment">// 需要项目中存在 com.sun.net.httpserver.HttpServer 类。该类为 JDK 自带，所以一定成立。</span></span><br><span class="line">    <span class="keyword">public</span> HttpServer <span class="title function_">httpServer</span><span class="params">(YunaiServerProperties serverProperties)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建 HttpServer 对象，并启动</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(serverProperties.getPort()), <span class="number">0</span>);</span><br><span class="line">        server.start();</span><br><span class="line">        logger.info(<span class="string">&quot;[httpServer][启动服务器成功，端口为:&#123;&#125;]&quot;</span>, serverProperties.getPort());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码比较简单，胖友看看艿艿在代码上添加的注释哟。</li>
</ul>
<h3 id="6-1-4-spring-factories"><a href="#6-1-4-spring-factories" class="headerlink" title="6.1.4 spring.factories"></a>6.1.4 spring.factories</h3><p>在 <code>resources</code> 目录下创建，创建 <code>META-INF</code> 目录，然后在该目录下创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/yunai-server-spring-boot-starter/src/main/resources/META-INF/spring.factories"><code>spring.factories</code></a> 文件，添加自动化配置类为 YunaiServerAutoConfiguration。内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">cn.iocoder.springboot.lab47.yunaiserver.autoconfigure.YunaiServerAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>至此，我们已经完成了一个自定义的 Starter。下面，我们在<a href="http://www.iocoder.cn/Spring-Boot/autoconfigure/?github#">「6.2 lab-47-demo 项目」</a>中引入，然后进行测试。</p>
<h2 id="6-2-lab-47-demo-项目"><a href="#6-2-lab-47-demo-项目" class="headerlink" title="6.2 lab-47-demo 项目"></a>6.2 lab-47-demo 项目</h2><p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/lab-47-demo/pom.xml">lab-47-demo</a> 项目，引入我们自定义 Starter。</p>
<h3 id="6-2-1-引入依赖"><a href="#6-2-1-引入依赖" class="headerlink" title="6.2.1 引入依赖"></a>6.2.1 引入依赖</h3><p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/lab-47-demo/pom.xml"><code>pom.xml</code></a> 文件中，引入相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lab-47<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.iocoder.springboot.labs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lab-47-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入自定义 Starter --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.iocoder.springboot.labs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yunai-server-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-2-配置文件"><a href="#6-2-2-配置文件" class="headerlink" title="6.2.2 配置文件"></a>6.2.2 配置文件</h3><p>在 <code>resource</code> 目录下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/lab-47-demo/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件，设置 <code>yunai.server.port</code> 配置项来自定义 HttpServer 端口。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">yunai:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8888</span> <span class="comment"># 自定义 HttpServer 端口</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-3-DemoApplication"><a href="#6-2-3-DemoApplication" class="headerlink" title="6.2.3 DemoApplication"></a>6.2.3 DemoApplication</h3><p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/lab-47-demo/src/main/java/cn/iocoder/springboot/lab47/demo/DemoApplication.java"><code>DemoApplication.java</code></a> 类，配置 <code>@SpringBootApplication</code> 注解即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-简单测试"><a href="#6-2-4-简单测试" class="headerlink" title="6.2.4 简单测试"></a>6.2.4 简单测试</h3><p>执行 <code>DemoApplication#main(String[] args)</code> 方法，启动 Spring Boot 应用。打印日志如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020-02-02 13:03:12.156  INFO 76469 --- [           main] c.i.s.lab47.demo.DemoApplication         : Starting DemoApplication on MacBook-Pro-8 with PID 76469 (/Users/yunai/Java/SpringBoot-Labs/lab-47/lab-47-demo/target/classes started by yunai <span class="keyword">in</span> /Users/yunai/Java/SpringBoot-Labs)</span><br><span class="line">2020-02-02 13:03:12.158  INFO 76469 --- [           main] c.i.s.lab47.demo.DemoApplication         : No active profile <span class="built_in">set</span>, falling back to default profiles: default</span><br><span class="line">2020-02-02 13:03:12.873  INFO 76469 --- [           main] c.i.s.l.y.a.YunaiServerAutoConfiguration : [httpServer][启动服务器成功，端口为:8888]</span><br><span class="line">2020-02-02 13:03:12.927  INFO 76469 --- [           main] c.i.s.lab47.demo.DemoApplication         : Started DemoApplication <span class="keyword">in</span> 1.053 seconds (JVM running <span class="keyword">for</span> 1.47)</span><br></pre></td></tr></table></figure>

<ul>
<li>YunaiServerAutoConfiguration 成功自动配置 HttpServer Bean，并启动该服务器在 8888 端口。</li>
</ul>
<p>此时，我们使用浏览器访问 <a href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a> 地址，返回结果为 404 Not Found。因为我们没有给 HttpServer 相应的 Handler。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>至此，我们已经完成了 Spring Boot 自动配置的原理学习。如果有不理解的地方，请给艿艿留言哟。</p>
<p>在理解 Spring Boot 自动配置的原理的过程中，我们会发现，无论是配置类，还是条件注解也好，实际 Spring 原本都已经进行提供。甚至说，SpringFactoriesLoader 竟然也是 Spring 提供的。所以，Spring Boot 是在 Spring 的基础之上，实现了一套 Boot 启动机制。</p>
<p>Spring 的核心之一是 IOC，负责管理 Bean 的生命周期。而 Spring Boot 则是对 Java 应用的生命周期的管理。</p>
<ul>
<li>在 Spring 的年代，我们都是使用 Tomcat 外部容器来实现 Java 应用的运行，Spring 只是其中的一个组件。</li>
<li>在 Spring Boot 的年代，我们使用 Spring Boot 来管理 Java 应用的运行，内嵌的 Tomcat 反而成为其中的一个组件。</li>
</ul>
<p>😈 另外，在推荐如下的文章，方便胖友进一步对 Spring Boot 有深入理解：</p>
<ul>
<li><a href="http://www.iocoder.cn/Fight/Give-you-a-list-of-Spring-Boot-knowledge/?self">《给你一份 Spring Boot 知识清单》</a></li>
<li><a href="http://www.iocoder.ccn/Fight/Details-the-Spring-Boot-automatic-configuration-mechanism/?self">《详解 Spring Boot 自动配置机制》</a></li>
</ul>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习语义分割理论与实战指南</title>
    <url>/2022/02/25/deepLearningSemanticSegmentation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深度学习语义分割理论与实战指南"><a href="#深度学习语义分割理论与实战指南" class="headerlink" title="深度学习语义分割理论与实战指南"></a><strong>深度学习语义分割理论与实战指南</strong></h1><h1 id="A-Theory-and-Practical-Guide-to-Deep-Learning-Semantic-Segmentation"><a href="#A-Theory-and-Practical-Guide-to-Deep-Learning-Semantic-Segmentation" class="headerlink" title="A Theory and Practical Guide to Deep Learning Semantic Segmentation"></a>A Theory and Practical Guide to Deep Learning Semantic Segmentation</h1></center>

<center>


<p><strong>v1.0 louwill</strong><br><br><strong>Machine Learning Lab</strong></p>
</center>

<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/qrcode.jpg"
    width = "300" height = "300">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig0. Machine Learning Lab</div>
</center>



<br>
<br>
<br>

<div style="text-align: justify">



<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>图像分类、目标检测和图像分割是基于深度学习的计算机视觉三大核心任务。三大任务之间明显存在着一种递进的层级关系，图像分类聚焦于整张图像，目标检测定位于图像具体区域，而图像分割则是细化到每一个像素。基于深度学习的图像分割具体包括语义分割、实例分割和全景分割。语义分割的目的是要给每个像素赋予一个语义标签。语义分割在自动驾驶、场景解析、卫星遥感图像和医学影像等领域都有着广泛的应用前景。本文作为基于PyTorch的语义分割技术手册，对语义分割的基本技术框架、主要网络模型和技术方法提供一个实战性指导和参考。</p>
<h2 id="1-语义分割概述"><a href="#1-语义分割概述" class="headerlink" title="1. 语义分割概述"></a>1. 语义分割概述</h2><p>图像分割主要包括语义分割（Semantic Segmentation）和实例分割（Instance Segmentation）。那语义分割和实例分割具体都是什么含义？二者又有什么区别和联系？语义分割是对图像中的每个像素都划分出对应的类别，即实现像素级别的分类；而类的具体对象，即为实例，那么实例分割不但要进行像素级别的分类，还需在具体的类别基础上区别开不同的个体。例如，图像有多个人甲、乙、丙，那边他们的语义分割结果都是人，而实例分割结果却是不同的对象。另外，为了同时实现实例分割与不可数类别的语义分割，相关研究又提出了全景分割（Panoptic Segmentation）的概念。语义分割、实例分割和全景分割具体如图1（b）、（c）和（d）图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic__1.png"
    width = "400" height = "300">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig1. Image Segmentation</div>
</center>

<br>
在开始图像分割的学习和尝试之前，我们必须明确语义分割的任务描述，即搞清楚语义分割的输入输出都是什么。输入是一张原始的RGB图像或者单通道图像，但是输出不再是简单的分类类别或者目标定位，而是带有各个像素类别标签的与输入同分辨率的分割图像。简单来说，我们的输入输出都是图像，而且是同样大小的图像。如图2所示。

<center>
    <img 
    src="https://www.jeremyjordan.me/content/images/2018/05/Screen-Shot-2018-05-17-at-9.02.15-PM.png"
    width = "500" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig2. Pixel Representation</div>
</center>

<br>
类似于处理分类标签数据，对预测分类目标采用像素上的one-hot编码，即为每个分类类别创建一个输出的通道。如图3所示。

<center>
    <img 
    src="https://www.jeremyjordan.me/content/images/2018/05/Screen-Shot-2018-05-16-at-9.36.00-PM.png"
    width = "500" height = "250">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig3. Pixel One-hot</div>
</center>

<br>
图4是将分割图添加到原始图像上的叠加效果。这里需要明确一下mask的概念，在图像处理中我们将其译为掩码，如Mask R-CNN中的Mask。Mask可以理解为我们将预测结果叠加到单个通道时得到的该分类所在区域。

<center>
    <img 
    src="https://www.jeremyjordan.me/content/images/2018/05/Screen-Shot-2018-05-16-at-9.36.38-PM.png"
    width = "500" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig4. Pixel labeling</div>
</center>

<br>
所以，语义分割的任务就是输入图像经过深度学习算法处理得到带有语义标签的同样尺寸的输出图像。

<h2 id="2-关键技术组件"><a href="#2-关键技术组件" class="headerlink" title="2. 关键技术组件"></a>2. 关键技术组件</h2><p>在语义分割发展早期，为了能够让深度学习进行像素级的分类任务，在分类任务的基础上对CNN做了一些修改，将分类网络中浓缩语义表征的全连接层去掉，提出用全卷积网络（Fully Convolutional Networks）来处理语义分割问题。然后U-Net的提出，奠定了编解码结构的U形网络深度学习语义分割中的总统山地位。这里我们对语义分割的关键技术组件进行分开描述，编码器、解码器和Skip Connection属于分割网络的核心结构组件，空洞卷积（Dilate Conv）是独立于U形结构的第二大核心设计。条件随机场（CRF）和马尔科夫随机场（MRF）则是用于优化神经网络分割后的细节处理。深监督作为一种常用的结构设计Trick，在分割网络中也有广泛应用。除此之外，则是针对于语义分割的通用技术点。</p>
<h3 id="2-1-编码器与分类网络"><a href="#2-1-编码器与分类网络" class="headerlink" title="2.1 编码器与分类网络"></a>2.1 编码器与分类网络</h3><p>编码器对于分割网络来说就是进行特征提取和语义信息浓缩的过程，这对熟悉各种分类网络的我们来说并不陌生。编码器通过卷积和池化的组合不断对图像进行下采样，得到的特征图空间尺寸也会越来越小，但会更加具备语义分辨性。这也是大多数分类网络的通用模式，不断卷积池化使得特征图越来越小，然后配上几层全连接网络即可进行分类判别。常用的分类网络包括AlexNet、VGG、ResNet、Inception、DenseNet和MobileNet等等。<br><br></p>
<p>既然之前有那么多优秀的SOTA网络用来做特征提取，所以很多时候分割网络的编码器并不需要我们write from scratch，时刻要有迁移学习的敏感度，直接用现成分类网络的卷积层部分作为编码器进行特征提取和信息浓缩，往往要比从头开始训练一个编码器要快很多。<br></br></p>
<p>比如我们以VGG16作为SegNet编码器的预训练模型，以PyTorch为例，来看编码器的写法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegNet</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, classes</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        vgg16 = models.vgg16(pretrained=<span class="literal">True</span>)</span><br><span class="line">        features = vgg16.features</span><br><span class="line">        self.enc1 = features[<span class="number">0</span>: <span class="number">4</span>]</span><br><span class="line">        self.enc2 = features[<span class="number">5</span>: <span class="number">9</span>]</span><br><span class="line">        self.enc3 = features[<span class="number">10</span>: <span class="number">16</span>]</span><br><span class="line">        self.enc4 = features[<span class="number">17</span>: <span class="number">23</span>]</span><br><span class="line">        self.enc5 = features[<span class="number">24</span>: -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>在上述代码中，可以看到我们将vgg16的31个层分作5个编码模块，每个编码模块的基本结构如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span>): Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>))      </span><br><span class="line">(<span class="number">1</span>): ReLU(inplace=<span class="literal">True</span>)                                          </span><br><span class="line">(<span class="number">2</span>): Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>))     </span><br><span class="line">(<span class="number">3</span>): ReLU(inplace=<span class="literal">True</span>)                                          </span><br><span class="line">(<span class="number">4</span>): MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, ceil_mode=<span class="literal">False</span>)   </span><br></pre></td></tr></table></figure>


<h3 id="2-2-解码器与上采样"><a href="#2-2-解码器与上采样" class="headerlink" title="2.2 解码器与上采样"></a>2.2 解码器与上采样</h3><p>编码器不断将输入不断进行下采样达到信息浓缩，而解码器则负责上采样来恢复输入尺寸。解码器中除了一些卷积方法用为辅助之外，最关键的还是一些上采样方法，主要包括双线性插值、转置卷积和反池化。</p>
<h4 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h4><p>插值法（Interpolation）是一种经典的数值分析方法，一些经典插值大家或多或少都有听到过，比如线性插值、三次样条插值和拉格朗日插值法等。在说双线性插值前我们先来了解一下什么是线性插值（Linear interpolation）。线性插值法是指使用连接两个已知量的直线来确定在这两个已知量之间的一个未知量的值的方法。如下图所示：</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_2.png"
    width = "400" height = "250">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig5. Linear Interpolation</div>
</center>


<br>

<p>已知直线上两点坐标分别为$(x_1,y_1)$和$(x_2,y_2)$，现在想要通过线性插值法来得到某一点$x$在直线上的值。基本就是一个初中数学题，这里就不做过多展开，点$x$在直线上的值$y$可以表示为：</p>
<center>


<p>$y&#x3D;\frac{x_2-x}{x_2-x_1}y_2+\frac{x-x_1}{x_2-x_1}y_1$</p>
</center>

<p>再来看双线性插值。线性插值用到两个点来确定插值，双线性插值则需要四个点。在图像上采样中，双线性插值利用四个点的像素值来确定要插值的一个像素值，其本质上还是分别在$x$和$y$方向上分别进行两次线性插值。如下图所示，我们来看具体做法。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_3.png"
    width = "400" height = "250">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig6. Bilinear Interpolation</div>
</center>

<br>

<p>图中$Q_{11}-Q_{22}$四个黄色的点是已知数据点，红色点$P$是待插值点。假设$Q_{11}$为$(x_1,y_1)$，$Q_{12}$为$(x_1,y_2)$，$Q_{21}$为$(x_2,y_1)$，$Q_{22}$为$(x_2,y_2)$。我们先在$x$轴方向上进行线性插值，先求得$R_1$和$R_2$的插值。根据线性插值公式，有：</p>
<center>


<p>$f(R_1)&#x3D;\frac{x_2-x}{x_2-x_1}f(Q_{11})+\frac{x-x_1}{x_2-x_1}f(Q_{21})$<br>$f(R_2)&#x3D;\frac{x_2-x}{x_2-x_1}f(Q_{12})+\frac{x-x_1}{x_2-x_1}f(Q_{22})$</p>
</center>

<p>得到$R_1$和$R_2$点坐标之后，便可继续在$y$轴方向进行线性插值。可得目标点$P$的插值为：</p>
<center>


<p>$f(P)&#x3D;\frac{y_2-y}{y_2-y_1}f(R_1)+\frac{y-y_1}{y_2-y_1}f(R_2)$</p>
</center>

<p>双线性插值在众多经典的语义分割网络中都有用到，比如说奠定语义分割编解码框架的FCN网络。假设将$3\times6$的图像通过双线性插值变为$6\times12$的图像，如下图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_4.jpg"
    width = "500" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig7. Bilinear Interpolation Example</div>
</center>

<br>
 双线性插值的优点是速度非常快，计算量小，但缺点就是效果不是特别理想。
 </br>

<h4 id="转置卷积"><a href="#转置卷积" class="headerlink" title="转置卷积"></a>转置卷积</h4><p>转置卷积（Transposed Convolution）也叫解卷积（Deconvolution），有些人也将其称为反卷积，但这个叫法并不太准确。大家都知道，在常规卷积时，我们每次得到的卷积特征图尺寸是越来越小的。但在图像分割等领域，我们是需要逐步恢复输入时的尺寸的。如果把常规卷积时的特征图不断变小叫做下采样，那么通过转置卷积来恢复分辨率的操作可以称作上采样。</p>
<p>本质上来说，转置卷积跟常规卷积并无区别。不同之处在于先按照一定的比例进行padding来扩大输入尺寸，然后把常规卷积中的卷积核进行转置，再按常规卷积方法进行卷积就是转置卷积。假设输入图像矩阵为$X$，卷积核矩阵为$C$，常规卷积的输出为$Y$，则有：</p>
<center>


<p>$Y&#x3D;CX$</p>
</center>

<p>两边同时乘以卷积核的转置$C^T$，这个公式便是转置卷积的输入输出计算。</p>
<center>


<p>$X&#x3D;C^TY$</p>
</center>

<p>假设输入大小为$4\times4$，滤波器大小为$3\times3$，常规卷积下输出为$2\times2$，为了演示转置卷积，我们将滤波器矩阵进行稀疏化处理为$4\times16$，将输入矩阵进行拉平为$16\times1$，相应输出结果也会拉平为$4\times1$，图示如下：</p>
<center>
    <img 
    src="https://miro.medium.com/max/2307/1*9ngOwG-uHaJO8Od0ePB-fQ.jpeg"
    width = "380" height = "310">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig8. Matrix of Convolution</div>
</center>


<p>然后按照转置卷积的做法我们把卷积核矩阵进行转置，按照$X&#x3D;C^TY$进行验证：</p>
<center>
    <img 
    src="https://miro.medium.com/max/2350/1*zfIgQ6uyowDUhkMBBKh4bg.png"
    width = "350" height = "300">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig9. Matrix of Transpose Convolution</div>
</center>



<h4 id="反池化"><a href="#反池化" class="headerlink" title="反池化"></a>反池化</h4><p>反池化（Unpooling）可以理解为池化的逆操作，相较于前两种上采样方法，反池化用的并不是特别多。其简要原理如下，在池化时记录下对应kernel中的坐标，在反池化时将一个元素根据kernel进行放大，根据之前的坐标将元素填写进去，其他位置补位为0即可。</p>
<h3 id="2-3-Skip-Connection"><a href="#2-3-Skip-Connection" class="headerlink" title="2.3 Skip Connection"></a>2.3 Skip Connection</h3><p>跳跃连接本身是在ResNet中率先提出，用于学习一个恒等式和残差结构，后面在DenseNet、FCN和U-Net等网络中广泛使用。最典型的就是U-Net的跳跃连接，在每个编码和解码层之间各添加一个跳跃连接，每一次下采样都会有一个跳跃连接与对应的上采样进行级联，这种不同尺度的特征融合对上采样恢复像素大有帮助。</p>
<h3 id="2-4-Dilate-Conv与多尺度"><a href="#2-4-Dilate-Conv与多尺度" class="headerlink" title="2.4 Dilate Conv与多尺度"></a>2.4 Dilate Conv与多尺度</h3><p>空洞卷积（Dilated&#x2F;Atrous Convolution）也叫扩张卷积或者膨胀卷积，字面意思上来说就是在卷积核中插入空洞，起到扩大感受野的作用。空洞卷积的直接做法是在常规卷积核中填充0，用来扩大感受野，且进行计算时，空洞卷积中实际只有非零的元素起了作用。假设以一个变量a来衡量空洞卷积的扩张系数，则加入空洞之后的实际卷积核尺寸与原始卷积核尺寸之间的关系：</p>
<center>


<p>$K&#x3D;k+(k-1)(a-1)$</p>
</center>

<p>其中$k$为原始卷积核大小，$a$为卷积扩张率（dilation rate），$K$为经过扩展后实际卷积核大小。除此之外，空洞卷积的卷积方式跟常规卷积一样。当$a&#x3D;1$时，空洞卷积就退化为常规卷积。$a&#x3D;1,2,4$时，空洞卷积示意图如下：</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_9.png"
    width = "600" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig10. Dialate Convolution</div>
</center>


<div style="text-align: justify">


<p>当$a&#x3D;1$，原始卷积核size为$3\times3$，就是常规卷积。$a&#x3D;2$时，加入空洞之后的卷积核$size&#x3D;3+(3-1)\times(2-1)&#x3D;5$，对应的感受野可计算为$2^{(a+2)}-1&#x3D;7$。$a&#x3D;3$时，卷积核size可以变化到$3+(3-1)(4-1)&#x3D;9$，感受野则增长到$2^{(a+2)}-1&#x3D;15$。对比不加空洞卷积的情况，在stride为1的情况下3层3x3卷积的叠加，第三层输出特征图对应的感受野也只有$1+(3-1)\times3&#x3D;7$。所以，空洞卷积的一个重要作用就是增大感受野。</p>
<p>在语义分割的发展历程中，增大感受野是一个非常重要的设计。早期FCN提出以全卷积方式来处理像素级别的分割任务时，包括后来奠定语义分割baseline地位的U-Net，网络结构中存在大量的池化层来进行下采样，大量使用池化层的结果就是损失掉了一些信息，在解码上采样重建分辨率的时候肯定会有影响。特别是对于多目标、小物体的语义分割问题，以U-Net为代表的分割模型一直存在着精度瓶颈的问题。而基于增大感受野的动机背景下就提出了以空洞卷积为重大创新的deeplab系列分割网络，我们在深度学习语义分割模型中会对deeplab进行详述，这里不做过多展开。</p>
<p>对于语义分割而言，空洞卷积主要有三个作用：</p>
<ul>
<li><p>第一是扩大感受野，具体前面已经说的比较多了，这里不做重复。但需要明确一点，池化也可以扩大感受野，但空间分辨率降低了，相比之下，空洞卷积可以在扩大感受野的同时不丢失分辨率，且保持像素的相对空间位置不变。简单而言就是空洞卷积可以同时控制感受野和分辨率。</p>
</li>
<li><p>第二就是获取多尺度上下文信息。当多个带有不同dilation rate的空洞卷积核叠加时，不同的感受野会带来多尺度信息，这对于分割任务是非常重要的。</p>
</li>
<li><p>第三就是可以降低计算量，不需要引入额外的参数，如上图空洞卷积示意图所示，实际卷积时只有带有红点的元素真正进行计算。</p>
</div></li>
</ul>
<h3 id="2-5-后处理技术"><a href="#2-5-后处理技术" class="headerlink" title="2.5 后处理技术"></a>2.5 后处理技术</h3><div style="text-align: justify">
早期语义分割模型效果较为粗糙，在没有更好的特征提取模型的情况下，研究者们便在神经网络模型的粗糙结果进行后处理（Post-Processing），主要方法就是一些常用的概率图模型，比如说条件随机场（Conditional Random Field,CRF）和马尔可夫随机场（Markov Random Field,MRF）。


<p>CRF是一种经典的概率图模型，简单而言就是给定一组输入序列的条件下，求另一组输出序列的条件概率分布模型，CRF在自然语言处理领域有着广泛应用。CRF在语义分割后处理中用法的基本思路如下：对于FCN或者其他分割网络的粗粒度分割结果而言，每个像素点$i$具有对应的类别标签$x_i$和观测值$y_i$，以每个像素为节点，以像素与像素之间的关系作为边即可构建一个CRF模型。在这个CRF模型中，我们通过观测变量$y_i$来预测像素$i$对应的标签值$x_i$。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_11.jpg"
    width = "250" height = "180">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig11. CRF</div>
</center>


<p>以上做法也叫DenseCRF，具体细节可参考论文：<br><a href="https://papers.nips.cc/paper/4296-efficient-inference-in-fully-connected-crfs-with-gaussian-edge-potentials.pdf">Efficient Inference in Fully Connected CRFs with Gaussian Edge Potentials</a>，除此之外还有CRFasRNN，采用平均场近似的方式将CRF方法融入到神经网络过程中，本质上是对DenseCRF的一种优化。</p>
<p>另一种后处理概率图模型是MRF，MRF与CRF较为类似，只是对CRF的二元势函数做了调整，其优点在于可以使用平均场来构造CNN网络，并且推理过程可以一次性搞定。MRF在Deep Parsing Network(DPN)中有详细描述，相关细节可参考论文<a href="https://arxiv.org/pdf/1509.02634.pdf">Semantic Image Segmentation via Deep Parsing Network</a>。</p>
<p>语义分割发展前期，在分割网络模型的结果上加上CRF和MRF等后处理技术形成了早期的语义分割技术框架：</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_10.jpg"
    width = "500" height = "250">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig12. Framework of Semantic Segmentation with CRF/MRF</div>
</center>


<p>但从Deeplab v3开始，主流的语义分割网络就不再热衷于后处理技术了。一个典型的观点认为神经网络分割效果不好才会用后处理技术，这说明在分割网络本身上还有很大的提升空间。一是CRF本身不太容易训练，二来语义分割任务的端到端趋势。后来语义分割领域的SOTA网络也确实证明了这一点。尽管如此，CRF等后处理技术作为语义分割发展历程上的一个重要方法，我们有必要在此进行说明。从另一方面看，深度学习和概率图的结合虽然并不是那么顺利，但相信未来依旧会大有前景。</p>
</div>

<h3 id="2-6-深监督"><a href="#2-6-深监督" class="headerlink" title="2.6 深监督"></a>2.6 深监督</h3><p>所谓深监督（Deep Supervision），就是在深度神经网络的某些中间隐藏层加了一个辅助的分类器作为一种网络分支来对主干网络进行监督的技巧，用来解决深度神经网络训练梯度消失和收敛速度过慢等问题。</p>
<p>带有深监督的一个8层深度卷积网络结构如下图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_5.png"
    width = "600" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig13. Deep Supervision Example</div>
</center>

<br>

<p>可以看到，图中在第四个卷积块之后添加了一个监督分类器作为分支。<code>Conv4</code>输出的特征图除了随着主网络进入<code>Conv5</code>之外，也作为输入进入了分支分类器。如图所示，该分支分类器包括一个卷积块、两个带有<code>Dropout</code>和<code>ReLu</code>的全连接块和一个纯全连接块。带有深监督的卷积模块例子如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1DeepSup</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_class=<span class="number">150</span>, fc_dim=<span class="number">2048</span>, use_softmax=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(C1DeepSup, self).__init__()</span><br><span class="line">        self.use_softmax = use_softmax</span><br><span class="line">        self.cbr = conv3x3_bn_relu(fc_dim, fc_dim // <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        self.cbr_deepsup = conv3x3_bn_relu(fc_dim // <span class="number">2</span>, fc_dim // <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 最后一层卷积</span></span><br><span class="line">        self.conv_last = nn.Conv2d(fc_dim // <span class="number">4</span>, num_class, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        self.conv_last_deepsup = nn.Conv2d(fc_dim // <span class="number">4</span>, num_class, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向计算流程</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, conv_out, segSize=<span class="literal">None</span></span>):</span><br><span class="line">        conv5 = conv_out[-<span class="number">1</span>]</span><br><span class="line">        x = self.cbr(conv5)</span><br><span class="line">        x = self.conv_last(x)</span><br><span class="line">        <span class="comment"># is True during inference</span></span><br><span class="line">        <span class="keyword">if</span> self.use_softmax:  </span><br><span class="line">            x = nn.functional.interpolate(</span><br><span class="line">                x, size=segSize, mode=<span class="string">&#x27;bilinear&#x27;</span>, align_corners=<span class="literal">False</span>)</span><br><span class="line">            x = nn.functional.softmax(x, dim=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="comment"># 深监督模块</span></span><br><span class="line">        conv4 = conv_out[-<span class="number">2</span>]</span><br><span class="line">        _ = self.cbr_deepsup(conv4)</span><br><span class="line">        _ = self.conv_last_deepsup(_)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 主干卷积网络softmax输出</span></span><br><span class="line">        x = nn.functional.log_softmax(x, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 深监督分支网络softmax输出</span></span><br><span class="line">        _ = nn.functional.log_softmax(_, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (x, _)</span><br></pre></td></tr></table></figure>

<h3 id="2-7-通用技术"><a href="#2-7-通用技术" class="headerlink" title="2.7 通用技术"></a>2.7 通用技术</h3><p>通用技术主要是指深度学习流程中会用到的基本模块，比如说损失函数的选取以及采用哪种精度衡量指标。其他的像优化器的选取，学习率的控制等，这里限于篇幅进行省略。</p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>常用的分类损失均可用作语义分割的损失函数。最常用的就是交叉熵损失函数，如果只是前景分割，则可以使用二分类的交叉熵损失（Binary CrossEntropy Loss, BCE loss），对于目标物体较小的情况我们可以使用Dice损失，对于目标物体类别不均衡的情况可以使用加权的交叉熵损失（Weighted CrossEntropy Loss, WCE Loss），另外也可以尝试多种损失函数的组合。</p>
<h4 id="精度描述"><a href="#精度描述" class="headerlink" title="精度描述"></a>精度描述</h4><p>语义分割作为经典的图像分割问题，其本质上还是一种图像像素分类。既然是分类，我们就可以使用常见的分类评价指标来评估模型好坏。语义分割常见的评价指标包括像素准确率（Pixel Accuracy）、平均像素准确率（Mean Pixel Accuracy）、平均交并比（Mean IoU）、频权交并比（FWIoU）和Dice系数（Dice Coeffcient）等。</p>
<p><strong>像素准确率(PA)。</strong> 像素准确率跟分类中的准确率含义一样，即所有分类正确的像素数占全部像素的比例。PA的计算公式如下：</p>
<center>


<p>$PA&#x3D;\frac{\sum_{i&#x3D;0}^{n}p_{ii}}{\sum_{i&#x3D;0}^{n}\sum_{j&#x3D;0}^{n}p_{ij}}$</p>
</center>

<p><strong>平均像素准确率(MPA)。</strong> 平均像素准确率其实更应该叫平均像素精确率，是指分别计算每个类别分类正确的像素数占所有预测为该类别像素数比例的平均值。所以，从定义上看，这是精确率(Precision)的定义，MPA的计算公式如下：</p>
<center>


<p>$MPA&#x3D;\frac{1}{n+1}\sum_{i&#x3D;0}^{n}\frac{p_{ii}}{\sum_{j&#x3D;0}^{n}p_{ij}}$</p>
</center>

<p><strong>平均交并比(MIoU)。</strong> 交并比（Intersection over Union）的定义很简单，将标签图像和预测图像看成是两个集合，计算两个集合的交集和并集的比值。而平均交并比则是将所有类的IoU取平均。 MIoU的计算公式如下：</p>
<center>


<p>$MIoU&#x3D;\frac{1}{n+1}\sum_{i&#x3D;0}^{n}\frac{p_{ii}}{\sum_{j&#x3D;0}^{n}p_{ij}+\sum_{j&#x3D;0}^{n}p_{ji}-p_{ii}}$</p>
</center>

<p><strong>频权交并比(FWIoU)。</strong> 频权交并比顾名思义，就是以每一类别的频率为权重和其IoU加权计算出来的结果。FWIoU的设计思想很明确，语义分割很多时候会面临图像中各目标类别不平衡的情况，对各类别IoU直接求平均不是很合理，所以考虑各类别的权重就非常重要了。FWIoU的计算公式如下：</p>
<center>


<p>$FWIoU&#x3D;\frac{1}{\sum_{i&#x3D;0}^{n}\sum_{j&#x3D;0}^{n}p_{ij}}\sum_{i&#x3D;0}^{n}\frac{\sum_{j&#x3D;0}^{n}p_{ij}p_{ii}}{\sum_{j&#x3D;0}^{n}p_{ij}+\sum_{j&#x3D;0}^{n}p_{ji}-p_{ii}}$</p>
</center>

<p><strong>Dice系数。</strong> Dice系数是一种度量两个集合相似性的函数，是语义分割中最常用的评价指标之一。Dice系数定义为两倍的交集除以像素和，跟IoU有点类似，其计算公式如下：</p>
<center>


<p>$dice&#x3D;\frac{2|X\cap{Y}|}{|X|+|Y|}$</p>
</center>

<p>dice本质上跟分类指标中的F1-Score类似。作为最常用的分割指标之一，这里给出PyTorch的实现方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dice_coef</span>(<span class="params">pred, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Dice = (2*|X &amp; Y|)/ (|X|+ |Y|)</span></span><br><span class="line"><span class="string">         =  2*sum(|A*B|)/(sum(A^2)+sum(B^2))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    smooth = <span class="number">1.</span></span><br><span class="line">    m1 = pred.view(-<span class="number">1</span>).<span class="built_in">float</span>()</span><br><span class="line">    m2 = target.view(-<span class="number">1</span>).<span class="built_in">float</span>()</span><br><span class="line">    intersection = (m1 * m2).<span class="built_in">sum</span>().<span class="built_in">float</span>()</span><br><span class="line">    dice = (<span class="number">2.</span> * intersection + smooth) / (torch.<span class="built_in">sum</span>(m1*m1) + torch.<span class="built_in">sum</span>(m2*m2) + smooth)</span><br><span class="line">    <span class="keyword">return</span> dice</span><br></pre></td></tr></table></figure>

<h2 id="3-数据Pipeline"><a href="#3-数据Pipeline" class="headerlink" title="3. 数据Pipeline"></a>3. 数据Pipeline</h2><p>这里主要说一下PyTorch的自定义数据读取pipeline模板和相关trciks以及如何优化数据读取的pipeline等。我们从PyTorch的数据对象类<code>Dataset</code>开始。<code>Dataset</code>在PyTorch中的模块位于<code>utils.data</code>下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br></pre></td></tr></table></figure>

<h3 id="3-1-Torch数据读取模板"><a href="#3-1-Torch数据读取模板" class="headerlink" title="3.1 Torch数据读取模板"></a>3.1 Torch数据读取模板</h3><p>PyTorch官方为我们提供了自定义数据读取的标准化代码代码模块，作为一个读取框架，我们这里称之为原始模板。其代码结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ...</span>):</span><br><span class="line">        <span class="comment"># stuff</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># stuff</span></span><br><span class="line">        <span class="keyword">return</span> (img, label)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># return examples size</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h3 id="3-2-transform与数据增强"><a href="#3-2-transform与数据增强" class="headerlink" title="3.2 transform与数据增强"></a>3.2 transform与数据增强</h3><p>PyTorch数据增强功能可以放在<code>transform</code>模块下，添加<code>transform</code>后的数据读取结构如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms <span class="keyword">as</span> T</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ...</span>):</span><br><span class="line">        <span class="comment"># stuff</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># compose the transforms methods</span></span><br><span class="line">        self.transform = T.Compose([T.CenterCrop(<span class="number">100</span>),</span><br><span class="line">                                T.RandomResizedCrop(<span class="number">256</span>),</span><br><span class="line">                                T.RandomRotation(<span class="number">45</span>),</span><br><span class="line">                                T.ToTensor()])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># stuff</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        data = <span class="comment"># Some data read from a file or image</span></span><br><span class="line">        labe = <span class="comment"># Some data read from a file or image</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># execute the transform</span></span><br><span class="line">        data = self.transform(data)  </span><br><span class="line">        label = self.transform(label)</span><br><span class="line">        <span class="keyword">return</span> (img, label)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># return examples size</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Call the dataset</span></span><br><span class="line">    custom_dataset = CustomDataset(...)</span><br></pre></td></tr></table></figure>

<p>需要说明的是，PyTorch <code>transform</code>模块所做的数据增强并不是我们所理解的广义上的数据增强。<code>transform</code>所做的增强，仅仅是在数据读取过程中随机地对某张图像做转化操作，实际数据量上并没有增多，可以将其视为是一种在线增强的策略。如果想要实现实际训练数据成倍数的增加，可以使用离线增强策略。</p>
<p>与图像分类仅需要对输入图像做增强不同的是，对于语义分割的数据增强而言，需要同时对输入图像和输入的mask同步进行数据增强工作。实际写代码时，要记得使用随机种子，在不失随机性的同时，保证输入图像和输出mask具备同样的转换。一个完整的语义分割在线数据增强代码实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentationDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="comment"># read the input images</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_load_input_image</span>(<span class="params">path</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            img = Image.<span class="built_in">open</span>(f)</span><br><span class="line">            <span class="keyword">return</span> img.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">    <span class="comment"># read the mask images</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_load_target_image</span>(<span class="params">path</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            img = Image.<span class="built_in">open</span>(f)</span><br><span class="line">            <span class="keyword">return</span> img.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_root, target_root, transform_input=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 transform_target=<span class="literal">None</span>, seed_fn=<span class="literal">None</span></span>):   </span><br><span class="line">        self.input_root = input_root</span><br><span class="line">        self.target_root = target_root</span><br><span class="line">        self.transform_input = transform_input</span><br><span class="line">        self.transform_target = transform_target</span><br><span class="line">        self.seed_fn = seed_fn</span><br><span class="line">        <span class="comment"># sort the ids     </span></span><br><span class="line">        self.input_ids = <span class="built_in">sorted</span>(img <span class="keyword">for</span> img <span class="keyword">in</span> os.listdir(self.input_root))</span><br><span class="line">        self.target_ids = <span class="built_in">sorted</span>(img <span class="keyword">for</span> img <span class="keyword">in</span> os.listdir(self.target_root))</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(self.input_ids) == <span class="built_in">len</span>(self.target_ids))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set random number seed</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_set_seed</span>(<span class="params">self, seed</span>):</span><br><span class="line">        random.seed(seed)</span><br><span class="line">        torch.manual_seed(seed)</span><br><span class="line">        <span class="keyword">if</span> self.seed_fn:</span><br><span class="line">            self.seed_fn(seed)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        input_img = self._load_input_image(</span><br><span class="line">            os.path.join(self.input_root, self.input_ids[idx]))</span><br><span class="line">        target_img = self._load_target_image(</span><br><span class="line">            os.path.join(self.target_root, self.target_ids[idx]))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.transform_input:</span><br><span class="line">            <span class="comment"># ensure that the input and output have the same randomness.</span></span><br><span class="line">            seed = random.randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">32</span>)</span><br><span class="line">            self._set_seed(seed)</span><br><span class="line">            input_img = self.transform_input(input_img)</span><br><span class="line">            self._set_seed(seed)</span><br><span class="line">            target_img = self.transform_target(target_img)  </span><br><span class="line">        <span class="keyword">return</span> input_img, target_img, self.input_ids[idx]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.input_ids)</span><br></pre></td></tr></table></figure>

<p>其中<code>transform_input</code>和<code>transform_target</code>均可由<code>transform</code>模块下的函数封装而成。一个皮肤病灶分割的在线数据增强实例效果如下图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic__12.png"
    width = "800" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig14. Example of online augmentation</div>
</center>


<h2 id="4-模型与算法"><a href="#4-模型与算法" class="headerlink" title="4. 模型与算法"></a>4. 模型与算法</h2><p>早期基于深度学习的图像分割以FCN为核心，旨在重点解决如何更好从卷积下采样中恢复丢掉的信息损失。后来逐渐形成了以U-Net为核心的这样一种编解码对称的U形结构。<strong>语义分割界迄今为止最重要的两个设计，一个是以U-Net为代表的U形结构，目前基于U-Net结构的创新就层出不穷，比如说应用于3D图像的V-Net，嵌套U-Net结构的U-Net++等。除此在外还有SegNet、RefineNet、HRNet和FastFCN。另一个则是以DeepLab系列为代表的Dilation设计，主要包括DeepLab系列和PSPNet。随着模型的Baseline效果不断提升，语义分割任务的主要矛盾也逐从downsample损失恢复像素逐渐演变为如何更有效地利用context上下文信息。</strong></p>
<h3 id="4-1-FCN"><a href="#4-1-FCN" class="headerlink" title="4.1 FCN"></a>4.1 FCN</h3><p>FCN（Fully Convilutional Networks）是语义分割领域的开山之作。FCN的提出是在2016年，相较于此前提出的AlexNet和VGG等卷积全连接的网络结构，FCN提出用卷积层代替全连接层来处理语义分割问题，这也是FCN的由来，即全卷积网络。</p>
<p>FCN的关键点主要有三，一是全卷积进行特征提取和下采样，二是双线性插值进行上采样，三是跳跃连接进行特征融合。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_6.png"
    width = "550" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig15. FCN</div>
</center>


<p>利用PyTorch实现一个FCN-8网络：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchimport torch.nn <span class="keyword">as</span> nnimport torch.nn.init <span class="keyword">as</span> initimport torch.nn.functional <span class="keyword">as</span> Ffrom torch.utils <span class="keyword">import</span> model_zoofrom torchvision <span class="keyword">import</span> modelsclass FCN8(nn.Module):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes</span>):        <span class="built_in">super</span>().__init__()        feats = <span class="built_in">list</span>(models.vgg16(pretrained=<span class="literal">True</span>).features.children())        self.feats = nn.Sequential(*feats[<span class="number">0</span>:<span class="number">9</span>])        self.feat3 = nn.Sequential(*feats[<span class="number">10</span>:<span class="number">16</span>])        self.feat4 = nn.Sequential(*feats[<span class="number">17</span>:<span class="number">23</span>])        self.feat5 = nn.Sequential(*feats[<span class="number">24</span>:<span class="number">30</span>])        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):                m.requires_grad = <span class="literal">False</span>        self.fconn = nn.Sequential(            nn.Conv2d(<span class="number">512</span>, <span class="number">4096</span>, <span class="number">7</span>),            nn.ReLU(inplace=<span class="literal">True</span>),            nn.Dropout(),            nn.Conv2d(<span class="number">4096</span>, <span class="number">4096</span>, <span class="number">1</span>),            nn.ReLU(inplace=<span class="literal">True</span>),            nn.Dropout(),        )        self.score_feat3 = nn.Conv2d(<span class="number">256</span>, num_classes, <span class="number">1</span>)        self.score_feat4 = nn.Conv2d(<span class="number">512</span>, num_classes, <span class="number">1</span>)        self.score_fconn = nn.Conv2d(<span class="number">4096</span>, num_classes, <span class="number">1</span>)    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):        feats = self.feats(x)        feat3 = self.feat3(feats)        feat4 = self.feat4(feat3)        feat5 = self.feat5(feat4)        fconn = self.fconn(feat5)        score_feat3 = self.score_feat3(feat3)        score_feat4 = self.score_feat4(feat4)        score_fconn = self.score_fconn(fconn)        score = F.upsample_bilinear(score_fconn, score_feat4.size()[<span class="number">2</span>:])        score += score_feat4        score = F.upsample_bilinear(score, score_feat3.size()[<span class="number">2</span>:])        score += score_feat3        <span class="keyword">return</span> F.upsample_bilinear(score, x.size()[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，我们使用了vgg16作为FCN-8的编码部分，这使得FCN-8具备较强的特征提取能力。</p>
<h3 id="4-2-UNet"><a href="#4-2-UNet" class="headerlink" title="4.2 UNet"></a>4.2 UNet</h3><p>早期基于深度学习的图像分割以FCN为核心，旨在重点解决如何更好从卷积下采样中恢复丢掉的信息损失。后来逐渐形成了以UNet为核心的这样一种编解码对称的U形结构。</p>
<p>UNet结构能够在分割界具有一统之势，最根本的还是其效果好，尤其是在医学图像领域。所以，做医学影像相关的深度学习应用时，一定都用过UNet，而且最原始的UNet一般都会有一个不错的baseline表现。2015年发表UNet的MICCAI，是目前医学图像分析领域最顶级的国际会议，UNet为什么在医学上效果这么好非常值得探讨一番。</p>
<p>U-Net结构如下图所示：</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_7.png"
    width = "500" height = "300">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig16. UNet</div>
</center>

<br>
乍一看很复杂，U形结构下貌似有很多细节问题。我们来把UNet简化一下，如下图所示：

<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_8.png"
    width = "500" height = "300">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig17. U-Net简化</div>
</center>

<br>
从图中可以看到，简化之后的UNet的关键点只有三条线：

<ul>
<li>下采样编码</li>
<li>上采样解码</li>
<li>跳跃连接</li>
</ul>
<p>下采样进行信息浓缩和上采样进行像素恢复，这是其他分割网络都会有的部分，UNet自然也不会跳出这个框架，可以看到，UNet进行了4次的最大池化下采样，每一次采样后都使用了卷积进行信息提取得到特征图，然后再经过4次上采样恢复输入像素尺寸。但UNet最关键的、也是最特色的部分在于图中红色虚线的Skip Connection。每一次下采样都会有一个跳跃连接与对应的上采样进行级联，这种不同尺度的特征融合对上采样恢复像素大有帮助，具体来说就是高层（浅层）下采样倍数小，特征图具备更加细致的图特征，底层（深层）下采样倍数大，信息经过大量浓缩，空间损失大，但有助于目标区域（分类）判断，当high level和low level的特征进行融合时，分割效果往往会非常好。从某种程度上讲，这种跳跃连接也可以视为一种Deep Supervision。</p>
<p>U-Net的简单实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编码块class UNetEnc(nn.Module):    def __init__(self, in_channels, out_channels, dropout=False):        super().__init__()        layers = [            nn.Conv2d(in_channels, out_channels, 3, dilation=2),            nn.ReLU(inplace=True),            nn.Conv2d(out_channels, out_channels, 3, dilation=2),            nn.ReLU(inplace=True),        ]        if dropout:            layers += [nn.Dropout(.5)]        layers += [nn.MaxPool2d(2, stride=2, ceil_mode=True)]        self.down = nn.Sequential(*layers)    def forward(self, x):        return self.down(x)# 解码块		class UNetDec(nn.Module):    def __init__(self, in_channels, features, out_channels):        super().__init__()        self.up = nn.Sequential(            nn.Conv2d(in_channels, features, 3),            nn.ReLU(inplace=True),            nn.Conv2d(features, features, 3),            nn.ReLU(inplace=True),            nn.ConvTranspose2d(features, out_channels, 2, stride=2),            nn.ReLU(inplace=True),        )    def forward(self, x):        return self.up(x)# U-Netclass UNet(nn.Module):    def __init__(self, num_classes):        super().__init__()        self.enc1 = UNetEnc(3, 64)        self.enc2 = UNetEnc(64, 128)        self.enc3 = UNetEnc(128, 256)        self.enc4 = UNetEnc(256, 512, dropout=True)        self.center = nn.Sequential(            nn.Conv2d(512, 1024, 3),            nn.ReLU(inplace=True),            nn.Conv2d(1024, 1024, 3),            nn.ReLU(inplace=True),            nn.Dropout(),            nn.ConvTranspose2d(1024, 512, 2, stride=2),            nn.ReLU(inplace=True),        )        self.dec4 = UNetDec(1024, 512, 256)        self.dec3 = UNetDec(512, 256, 128)        self.dec2 = UNetDec(256, 128, 64)        self.dec1 = nn.Sequential(            nn.Conv2d(128, 64, 3),            nn.ReLU(inplace=True),            nn.Conv2d(64, 64, 3),            nn.ReLU(inplace=True),        )        self.final = nn.Conv2d(64, num_classes, 1)    # 前向传播过程    def forward(self, x):        enc1 = self.enc1(x)        enc2 = self.enc2(enc1)        enc3 = self.enc3(enc2)        enc4 = self.enc4(enc3)        center = self.center(enc4)        # 包含了同层分辨率级联的解码块        dec4 = self.dec4(torch.cat([            center, F.upsample_bilinear(enc4, center.size()[2:])], 1))        dec3 = self.dec3(torch.cat([            dec4, F.upsample_bilinear(enc3, dec4.size()[2:])], 1))        dec2 = self.dec2(torch.cat([            dec3, F.upsample_bilinear(enc2, dec3.size()[2:])], 1))        dec1 = self.dec1(torch.cat([            dec2, F.upsample_bilinear(enc1, dec2.size()[2:])], 1))                return F.upsample_bilinear(self.final(dec1), x.size()[2:])</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-SegNet"><a href="#4-3-SegNet" class="headerlink" title="4.3 SegNet"></a>4.3 SegNet</h3><p>SegNet网络是典型的编码-解码结构。SegNet编码器网络由VGG16的前13个卷积层构成，所以通常是使用VGG16的预训练权重来进行初始化。每个编码器层都有一个对应的解码器层，因此解码器层也有13层。编码器最后的输出输入到softmax分类器中，输出每个像素的类别概率。SegNet如下图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_13.png"
    width = "600" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig18. SegNet结构</div>
</center>


<p>SegNet的一个简易参考实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchimport torch.nn <span class="keyword">as</span> nnimport torch.nn.init <span class="keyword">as</span> initimport torch.nn.functional <span class="keyword">as</span> Ffrom torchvision <span class="keyword">import</span> models<span class="comment"># define Decoderclass SegNetDec(nn.Module):    def __init__(self, in_channels, out_channels, num_layers):        super().__init__()        layers = [            nn.Conv2d(in_channels, in_channels // 2, 3, padding=1),            nn.BatchNorm2d(in_channels // 2),            nn.ReLU(inplace=True),        ]        layers += [            nn.Conv2d(in_channels // 2, in_channels // 2, 3, padding=1),            nn.BatchNorm2d(in_channels // 2),            nn.ReLU(inplace=True),        ] * num_layers        layers += [            nn.Conv2d(in_channels // 2, out_channels, 3, padding=1),            nn.BatchNorm2d(out_channels),            nn.ReLU(inplace=True),        ]        self.decode = nn.Sequential(*layers)    def forward(self, x):        return self.decode(x)# SegNetclass SegNet(nn.Module):    def __init__(self, classes):        super().__init__()        vgg16 = models.vgg16(pretrained=True)        features = vgg16.features        self.enc1 = features[0: 4]        self.enc2 = features[5: 9]        self.enc3 = features[10: 16]        self.enc4 = features[17: 23]        self.enc5 = features[24: -1]        for m in self.modules():            if isinstance(m, nn.Conv2d):                m.requires_grad = False        self.dec5 = SegNetDec(512, 512, 1)        self.dec4 = SegNetDec(512, 256, 1)        self.dec3 = SegNetDec(256, 128, 1)        self.dec2 = SegNetDec(128, 64, 0)        self.final = nn.Sequential(*[            nn.Conv2d(64, classes, 3, padding=1),            nn.BatchNorm2d(classes),            nn.ReLU(inplace=True)        ])    def forward(self, x):        x1 = self.enc1(x)        e1, m1 = F.max_pool2d(x1, kernel_size=2, stride=2, return_indices=True)        x2 = self.enc2(e1)        e2, m2 = F.max_pool2d(x2, kernel_size=2, stride=2, return_indices=True)        x3 = self.enc3(e2)        e3, m3 = F.max_pool2d(x3, kernel_size=2, stride=2, return_indices=True)        x4 = self.enc4(e3)        e4, m4 = F.max_pool2d(x4, kernel_size=2, stride=2, return_indices=True)        x5 = self.enc5(e4)        e5, m5 = F.max_pool2d(x5, kernel_size=2, stride=2, return_indices=True)        def upsample(d):            d5 = self.dec5(F.max_unpool2d(d, m5, kernel_size=2, stride=2, output_size=x5.size()))            d4 = self.dec4(F.max_unpool2d(d5, m4, kernel_size=2, stride=2, output_size=x4.size()))            d3 = self.dec3(F.max_unpool2d(d4, m3, kernel_size=2, stride=2, output_size=x3.size()))            d2 = self.dec2(F.max_unpool2d(d3, m2, kernel_size=2, stride=2, output_size=x2.size()))            d1 = F.max_unpool2d(d2, m1, kernel_size=2, stride=2, output_size=x1.size())            return d1        d = upsample(e5)        return self.final(d)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-Deeplab系列"><a href="#4-4-Deeplab系列" class="headerlink" title="4.4 Deeplab系列"></a>4.4 Deeplab系列</h3><p>Deeplab系列可以算是深度学习语义分割的另一个主要架构，其代表方法就是基于Dilation的多尺度设计。Deeplab系列主要包括：</p>
<ul>
<li>Deeplab v1</li>
<li>Deeplab v2</li>
<li>Deeplab v3</li>
<li>Deeplab v3+</li>
</ul>
<p>Deeplab v1主要是率先使用了空洞卷积，是Deeplab系列最原始的版本。Deeplab v2在Deeplab v1的基础上最大的改进在于提出了ASPP（Atrous Spatial Pyramid Pooling），即带有空洞卷积的金字塔池化，该设计的主要目的就是提取图像的多尺度特征。另外Deeplab v2也将Deeplab v1的Backone网络更换为ResNet。Deeplab v1和v2还有一个比较大的特点就是使用了CRF作为后处理技术。</p>
<p>这里重点说一下多尺度问题。多尺度问题就是当图像中的目标对象存在不同大小时，分割效果不佳的现象。比如同样的物体，在近处拍摄时物体显得大，远处拍摄时显得小。解决多尺度问题的目标就是不论目标对象是大还是小，网络都能将其分割地很好。Deeplab v2使用ASPP处理多尺度问题，ASPP设计结构如下图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_14.png"
    width = "500" height = "300">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig19. ASPP</div>
</center>


<p>从Deeplab v3开始，Deeplab系列舍弃了CRF后处理模块，提出了更加通用的、适用任何网络的分割框架，对ResNet最后的Block做了复制和级联（Cascade），对ASPP模块做了升级，在其中添加了BN层。改进后的ASPP如下图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/1594285975(1).png"
    width = "1000" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig20. ASPP of Deeplab v3</div>
</center>


<p>Deeplab v3+在Deeplab v3的基础上做了扩展和改进，其主要改进就是在编解码结构上使用了ASPP。Deeplab v3+可以视作是融合了语义分割两大流派的一项工作，即编解码+ASPP结构。另外Deeplab v3+的Backbone换成了Xception，其深度可分离卷积的设计使得分割网络更加高效。Deeplab v3+结构如下图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_15.png"
    width = "500" height = "250">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig21. ASPP</div>
</center>


<p>关于Deeplab系列各个版本的技术点构成总结如下表所示。Deeplab系列算法实现可参考GitHub上各版本，这里不再一一给出。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_16.png"
    width = "1000" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig22. Summary of Deeplab series.</div>
</center>


<h3 id="4-5-PSPNet"><a href="#4-5-PSPNet" class="headerlink" title="4.5 PSPNet"></a>4.5 PSPNet</h3><p>PSPNet是针对多尺度问题提出的另一种代表性分割网络。PSPNet认为此前的分割网络没有引入足够的上下文信息及不同感受野下的全局信息而存在分割出现错误的情况，因而引入Global-Scence-Level的信息解决该问题，其Backbone网络也是ResNet。简单来说，PSPNet就是将Deeplab的ASPP模块之前的特征图Pooling了四种尺度，然后将原始特征图和四种Pooling之后的特征图进行合并到一起，再经过一系列卷积之后进行预测的过程。PSPNet结构如下图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_17.png"
    width = "800" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig23. PSPNet</div>
</center>


<p>一个简易的带有深监督的PSPNet PPM模块写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pyramid Pooling Module class PPMDeepsup(nn.Module):    def __init__(self, num_class=150, fc_dim=4096,                 use_softmax=False, pool_scales=(1, 2, 3, 6)):        super(PPMDeepsup, self).__init__()        self.use_softmax = use_softmax        # PPM        self.ppm = []        for scale in pool_scales:            self.ppm.append(nn.Sequential(                nn.AdaptiveAvgPool2d(scale),                nn.Conv2d(fc_dim, 512, kernel_size=1, bias=False),                BatchNorm2d(512),                nn.ReLU(inplace=True)            ))        self.ppm = nn.ModuleList(self.ppm)        # Deep Supervision        self.cbr_deepsup = conv3x3_bn_relu(fc_dim // 2, fc_dim // 4, 1)        self.conv_last = nn.Sequential(            nn.Conv2d(fc_dim+len(pool_scales)*512, 512,                      kernel_size=3, padding=1, bias=False),            BatchNorm2d(512),            nn.ReLU(inplace=True),            nn.Dropout2d(0.1),            nn.Conv2d(512, num_class, kernel_size=1)        )        self.conv_last_deepsup = nn.Conv2d(fc_dim // 4, num_class, 1, 1, 0)        self.dropout_deepsup = nn.Dropout2d(0.1)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-UNet"><a href="#4-6-UNet" class="headerlink" title="4.6 UNet++"></a>4.6 UNet++</h3><p>自从2015年UNet网络提出后，这么多年大家没少在这个U形结构上折腾。大部分做语义分割的朋友都没少在UNet结构上做各种魔改，如果把UNet++算作是UNet的一种魔改的话，那它一定是最成功的魔改者。</p>
<p>UNet++是一种嵌套的U-Net结构，即内置了不同深度的UNet网络，并且利用了全尺度的跳跃连接（skip connection）和深度监督（deep supervisions）。另外UNet++还设计一种剪枝方案，加快了UNet++的推理速度。UNet++的结构示意图如下所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/pic_18.png"
    width = "300" height = "200">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig24. UNet++</div>
</center>


<p>单纯从结构设计的角度来看，UNet++效果好要归功于其嵌套结构和重新设计的跳跃连接，旨在解决UNet的两个关键挑战:1）优化整体结构的未知深度和2）跳跃连接的不必要的限制性设计。UNet++的一个简单的实现代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchfrom torch <span class="keyword">import</span> nnclass NestedUNet(nn.Module):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes, input_channels=<span class="number">3</span>, deep_supervision=<span class="literal">False</span>, **kwargs</span>):        <span class="built_in">super</span>().__init__()        nb_filter = [<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>]        self.deep_supervision = deep_supervision        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)        self.up = nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">&#x27;bilinear&#x27;</span>, align_corners=<span class="literal">True</span>)        self.conv0_0 = VGGBlock(input_channels, nb_filter[<span class="number">0</span>], nb_filter[<span class="number">0</span>])        self.conv1_0 = VGGBlock(nb_filter[<span class="number">0</span>], nb_filter[<span class="number">1</span>], nb_filter[<span class="number">1</span>])        self.conv2_0 = VGGBlock(nb_filter[<span class="number">1</span>], nb_filter[<span class="number">2</span>], nb_filter[<span class="number">2</span>])        self.conv3_0 = VGGBlock(nb_filter[<span class="number">2</span>], nb_filter[<span class="number">3</span>], nb_filter[<span class="number">3</span>])        self.conv4_0 = VGGBlock(nb_filter[<span class="number">3</span>], nb_filter[<span class="number">4</span>], nb_filter[<span class="number">4</span>])        self.conv0_1 = VGGBlock(nb_filter[<span class="number">0</span>]+nb_filter[<span class="number">1</span>], nb_filter[<span class="number">0</span>], nb_filter[<span class="number">0</span>])        self.conv1_1 = VGGBlock(nb_filter[<span class="number">1</span>]+nb_filter[<span class="number">2</span>], nb_filter[<span class="number">1</span>], nb_filter[<span class="number">1</span>])        self.conv2_1 = VGGBlock(nb_filter[<span class="number">2</span>]+nb_filter[<span class="number">3</span>], nb_filter[<span class="number">2</span>], nb_filter[<span class="number">2</span>])        self.conv3_1 = VGGBlock(nb_filter[<span class="number">3</span>]+nb_filter[<span class="number">4</span>], nb_filter[<span class="number">3</span>], nb_filter[<span class="number">3</span>])        self.conv0_2 = VGGBlock(nb_filter[<span class="number">0</span>]*<span class="number">2</span>+nb_filter[<span class="number">1</span>], nb_filter[<span class="number">0</span>], nb_filter[<span class="number">0</span>])        self.conv1_2 = VGGBlock(nb_filter[<span class="number">1</span>]*<span class="number">2</span>+nb_filter[<span class="number">2</span>], nb_filter[<span class="number">1</span>], nb_filter[<span class="number">1</span>])        self.conv2_2 = VGGBlock(nb_filter[<span class="number">2</span>]*<span class="number">2</span>+nb_filter[<span class="number">3</span>], nb_filter[<span class="number">2</span>], nb_filter[<span class="number">2</span>])        self.conv0_3 = VGGBlock(nb_filter[<span class="number">0</span>]*<span class="number">3</span>+nb_filter[<span class="number">1</span>], nb_filter[<span class="number">0</span>], nb_filter[<span class="number">0</span>])        self.conv1_3 = VGGBlock(nb_filter[<span class="number">1</span>]*<span class="number">3</span>+nb_filter[<span class="number">2</span>], nb_filter[<span class="number">1</span>], nb_filter[<span class="number">1</span>])        self.conv0_4 = VGGBlock(nb_filter[<span class="number">0</span>]*<span class="number">4</span>+nb_filter[<span class="number">1</span>], nb_filter[<span class="number">0</span>], nb_filter[<span class="number">0</span>])        <span class="keyword">if</span> self.deep_supervision:            self.final1 = nn.Conv2d(nb_filter[<span class="number">0</span>], num_classes, kernel_size=<span class="number">1</span>)            self.final2 = nn.Conv2d(nb_filter[<span class="number">0</span>], num_classes, kernel_size=<span class="number">1</span>)            self.final3 = nn.Conv2d(nb_filter[<span class="number">0</span>], num_classes, kernel_size=<span class="number">1</span>)            self.final4 = nn.Conv2d(nb_filter[<span class="number">0</span>], num_classes, kernel_size=<span class="number">1</span>)        <span class="keyword">else</span>:            self.final = nn.Conv2d(nb_filter[<span class="number">0</span>], num_classes, kernel_size=<span class="number">1</span>)    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):        x0_0 = self.conv0_0(<span class="built_in">input</span>)        x1_0 = self.conv1_0(self.pool(x0_0))        x0_1 = self.conv0_1(torch.cat([x0_0, self.up(x1_0)], <span class="number">1</span>))        x2_0 = self.conv2_0(self.pool(x1_0))        x1_1 = self.conv1_1(torch.cat([x1_0, self.up(x2_0)], <span class="number">1</span>))        x0_2 = self.conv0_2(torch.cat([x0_0, x0_1, self.up(x1_1)], <span class="number">1</span>))        x3_0 = self.conv3_0(self.pool(x2_0))        x2_1 = self.conv2_1(torch.cat([x2_0, self.up(x3_0)], <span class="number">1</span>))        x1_2 = self.conv1_2(torch.cat([x1_0, x1_1, self.up(x2_1)], <span class="number">1</span>))        x0_3 = self.conv0_3(torch.cat([x0_0, x0_1, x0_2, self.up(x1_2)], <span class="number">1</span>))        x4_0 = self.conv4_0(self.pool(x3_0))        x3_1 = self.conv3_1(torch.cat([x3_0, self.up(x4_0)], <span class="number">1</span>))        x2_2 = self.conv2_2(torch.cat([x2_0, x2_1, self.up(x3_1)], <span class="number">1</span>))        x1_3 = self.conv1_3(torch.cat([x1_0, x1_1, x1_2, self.up(x2_2)], <span class="number">1</span>))        x0_4 = self.conv0_4(torch.cat([x0_0, x0_1, x0_2, x0_3, self.up(x1_3)], <span class="number">1</span>))        <span class="keyword">if</span> self.deep_supervision:            output1 = self.final1(x0_1)            output2 = self.final2(x0_2)            output3 = self.final3(x0_3)            output4 = self.final4(x0_4)            <span class="keyword">return</span> [output1, output2, output3, output4]        <span class="keyword">else</span>:            output = self.final(x0_4)            <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>完整实现过程可参考<a href="https://github.com/4uiiurz1/pytorch-nested-unet/">GitHub</a>开源代码。</p>
<p>以上仅对几个主要的语义分割网络模型进行介绍，从当年的FCN到如今的各种模型层出不穷，想要对所有的SOTA模型全部进行介绍已经不太可能。其他诸如ENet、DeconvNet、RefineNet、HRNet、PixelNet、BiSeNet、UpperNet等网络模型，均各有千秋。本小节旨在让大家熟悉语义分割的主要模型结构和设计。深度学习和计算机视觉发展日新月异，一个新的SOTA模型出来，肯定很快就会被更新的结构设计所代替，重点是我们要了解语义分割的发展脉络，对主流的前沿研究能够保持一定的关注。</p>
<h2 id="5-语义分割训练Tips"><a href="#5-语义分割训练Tips" class="headerlink" title="5. 语义分割训练Tips"></a>5. 语义分割训练Tips</h2><p>PyTorch是一款极为便利的深度学习框架。在日常实验过程中，我们要多积累和总结，假以时日，人人都能总结出一套自己的高效模型搭建和训练套路。这一节我们给出一些惯用的PyTorch代码搭建方式，以及语义分割训练过程中的可视化方法，方便大家在训练过程中能够直观的看到训练效果。</p>
<h3 id="5-1-PyTorch代码搭建方式"><a href="#5-1-PyTorch代码搭建方式" class="headerlink" title="5.1 PyTorch代码搭建方式"></a>5.1 PyTorch代码搭建方式</h3><p>无论是分类、检测还是分割抑或是其他非视觉的深度学习任务，其代码套路相对来说较为固定，不会跳出基本的代码框架。一个深度学习的实现代码框架无非就是以下五个主要构成部分：</p>
<ul>
<li>数据：Data</li>
<li>模型：Model</li>
<li>判断：Criterion</li>
<li>优化：Optimizer</li>
<li>日志：Logger</li>
</ul>
<p>所以一个基本的顺序实现范式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># datadataset = VOC()||COCO()||ADE20K()data_loader = data.DataLoader(dataSet)# modelmodel = ...model_parallel = torch.nn.DataParallel(model)# Criterionloss = criterion(...)# Optimizeroptimer = optim.SGD(...)# Logger and Visulizationvisdom = ...tensorboard = ...textlog = ...# Model Parametersdata_size, batch_size, epoch_size, iterations = ..., ...</span></span><br></pre></td></tr></table></figure>

<p>不论是哪种深度学习任务，一般都免不了以上五项基本模块。所以一个简单的、相对完整的PyTorch模型项目代码应该是如下结构的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- semantic segmentation example    |-- dataset.py    |-- models        |-- unet.py        |-- deeplabv3.py        |-- pspnet.py        |-- ...    |-- _config.yml    |-- main.py    |-- utils    |   |-- visual.py    |   |-- loss.py    |   |-- ...    |-- README.md    ...</span><br></pre></td></tr></table></figure>

<p>上面的示例代码结构中，我们把训练和验证相关代码都放到<code>main.py</code>文件中，但在实际实验中，这块的灵活性极大。一般来说，模型训练策略有三种，一种是边训练边验证最后再测试、另一种则是在训练中验证，将验证过程糅合到训练过程中，还有一种最简单，就是训练完了再单独验证和测试。所以，我们这里也可以单独定义对应的函数，训练<code>train()</code>、验证<code>val()</code>以及测试<code>test()</code>除此之外，还有一些辅助功能需要设计，包括打印训练信息<code>print()</code>、绘制损失函数<code>plot()</code>、保存最优模型<code>save()</code>，调整训练参数<code>update()</code>。</p>
<p>所以训练代码控制流程可以归纳为TVT+PPSU的模式。</p>
<h3 id="5-2-可视化方法"><a href="#5-2-可视化方法" class="headerlink" title="5.2 可视化方法"></a>5.2 可视化方法</h3><p>PyTorch原生的可视化支持模块是Visdom，当然鉴于TensorFlow的应用广泛性，PyTorch同时也支持TensorBoard的可视化方法。语义分割需要能够直观的看到训练效果，所以在训练过程中辅以一定的可视化方法是十分必要的。</p>
<h4 id="Visdom"><a href="#Visdom" class="headerlink" title="Visdom"></a>Visdom</h4><p>visdom是一款用于创建、组织和共享实时大量训练数据可视化的灵活工具。深度学习模型训练通常放在远程的服务器上，服务器上训练的一个问题就在于不能方便地对训练进行可视化，相较于TensorFlow的可视化工具TensorBoard，visdom则是对应于PyTorch的可视化工具。直接通过<code>pip install visdom</code>即可完成安装，之后在终端输入如下命令即可启动visdom服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m visdom.server </span><br></pre></td></tr></table></figure>

<p>启动服务后输入本地或者远程地址，端口号8097，即可打开visdom主页。具体到深度学习训练时，我们可以在torch训练代码下插入visdom的可视化模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> args.steps_plot &gt; <span class="number">0</span> <span class="keyword">and</span> step % args.steps_plot == <span class="number">0</span>:    image = inputs[<span class="number">0</span>].cpu().data    vis.image(image,<span class="string">f&#x27;input (epoch: <span class="subst">&#123;epoch&#125;</span>, step: <span class="subst">&#123;step&#125;</span>)&#x27;</span>)    vis.image(outputs[<span class="number">0</span>].cpu().<span class="built_in">max</span>(<span class="number">0</span>)[<span class="number">1</span>].data, <span class="string">f&#x27;output (epoch: <span class="subst">&#123;epoch&#125;</span>, step: <span class="subst">&#123;step&#125;</span>)&#x27;</span>)    vis.image(targets[<span class="number">0</span>].cpu().data, <span class="string">f&#x27;target (epoch: <span class="subst">&#123;epoch&#125;</span>, step: <span class="subst">&#123;step&#125;</span>)&#x27;</span>)    vis.image(loss, <span class="string">f&#x27;loss (epoch: <span class="subst">&#123;epoch&#125;</span>, step: <span class="subst">&#123;step&#125;</span>)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>visdom效果展示如下：</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/640.jpg"
    width = "400" height = "300">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig25. visdom example</div>
</center>


<h4 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h4><p>很多TensorFlow用户更习惯于使用TensorBoard来进行训练的可视化展示。为了能让PyTorch用户也能用上TensorBoard，有开发者提供了PyTorch版本的TensorBoard，也就是tensorboardX。熟悉TensorBoard的用户可以无缝对接到tensorboardX，安装方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install tensorboardX</span><br></pre></td></tr></table></figure>

<p>除了要安装PyTorch之外，还需要安装TensorFlow。跟TensorBoard一样，tensorboardX也支持scalar, image, figure, histogram, audio, text, graph, onnx_graph, embedding, pr_curve，video等不同类型对象的可视化展示方式。tensorboardX和TensorBoard的启动方式一样，直接在终端下运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir runs</span><br></pre></td></tr></table></figure>

<p>一个完整tensorboardX使用demo如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchimport torchvision.utils <span class="keyword">as</span> vutilsimport numpy <span class="keyword">as</span> npimport torchvision.models <span class="keyword">as</span> modelsfrom torchvision <span class="keyword">import</span> datasetsfrom tensorboardX <span class="keyword">import</span> SummaryWriterresnet18 = models.resnet18(<span class="literal">False</span>)writer = SummaryWriter()sample_rate = <span class="number">44</span>100freqs = [<span class="number">262</span>, <span class="number">294</span>, <span class="number">330</span>, <span class="number">349</span>, <span class="number">392</span>, <span class="number">440</span>, <span class="number">440</span>, <span class="number">440</span>, <span class="number">440</span>, <span class="number">440</span>, <span class="number">440</span>]<span class="keyword">for</span> n_iter <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):    dummy_s1 = torch.rand(<span class="number">1</span>)    dummy_s2 = torch.rand(<span class="number">1</span>)    <span class="comment"># data grouping by `slash`    writer.add_scalar(&#x27;data/scalar1&#x27;, dummy_s1[0], n_iter)    writer.add_scalar(&#x27;data/scalar2&#x27;, dummy_s2[0], n_iter)    writer.add_scalars(&#x27;data/scalar_group&#x27;, &#123;&#x27;xsinx&#x27;: n_iter * np.sin(n_iter),                                             &#x27;xcosx&#x27;: n_iter * np.cos(n_iter),                                             &#x27;arctanx&#x27;: np.arctan(n_iter)&#125;, n_iter)    dummy_img = torch.rand(32, 3, 64, 64)  # output from network    if n_iter % 10 == 0:        x = vutils.make_grid(dummy_img, normalize=True, scale_each=True)        writer.add_image(&#x27;Image&#x27;, x, n_iter)        dummy_audio = torch.zeros(sample_rate * 2)        for i in range(x.size(0)):            # amplitude of sound should in [-1, 1]            dummy_audio[i] = np.cos(freqs[n_iter // 10] * np.pi * float(i) / float(sample_rate))        writer.add_audio(&#x27;myAudio&#x27;, dummy_audio, n_iter, sample_rate=sample_rate)        writer.add_text(&#x27;Text&#x27;, &#x27;text logged at step:&#x27; + str(n_iter), n_iter)        for name, param in resnet18.named_parameters():            writer.add_histogram(name, param.clone().cpu().data.numpy(), n_iter)        # needs tensorboard 0.4RC or later        writer.add_pr_curve(&#x27;xoxo&#x27;, np.random.randint(2, size=100), np.random.rand(100), n_iter)dataset = datasets.MNIST(&#x27;mnist&#x27;, train=False, download=True)images = dataset.test_data[:100].float()label = dataset.test_labels[:100]features = images.view(100, 784)writer.add_embedding(features, metadata=label, label_img=images.unsqueeze(1))# export scalar data to JSON for external processingwriter.export_scalars_to_json(&quot;./all_scalars.json&quot;)writer.close()</span></span><br></pre></td></tr></table></figure>

<p>tensorboardX的展示界面如图所示。</p>
<center>
    <img 
    src="https://github.com/luwill/louwill-python-learning/raw/master/650.jpg"
    width = "500" height = "280">
    <br>
    <div style="color: #999;
    font-size:11px;
    padding: 2px;">Fig26. tensorboardX example</div>
</center>

</div>


<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://github.com/mrgloom/awesome-semantic-segmentation">awesome-semantic-segmentation</a></li>
<li>Long J , Shelhamer E , Darrell T . Fully Convolutional Networks for Semantic Segmentation[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2015, 39(4):640-651.</li>
<li>Ronneberger O , Fischer P , Brox T . U-Net: Convolutional Networks for Biomedical Image Segmentation[J]. 2015.</li>
<li>Badrinarayanan V , Kendall A , Cipolla R . SegNet: A Deep Convolutional Encoder-Decoder Architecture for Image Segmentation[J]. 2015.</li>
<li>Zhao H , Shi J , Qi X , et al. Pyramid Scene Parsing Network[J]. 2016.</li>
<li>Huang H , Lin L , Tong R , et al. UNet 3+: A Full-Scale Connected UNet for Medical Image Segmentation[J]. arXiv, 2020.</li>
<li>UNet++: A Nested U-Net Architecture for Medical Image Segmentation</li>
<li><a href="https://github.com/4uiiurz1/pytorch-nested-unet">https://github.com/4uiiurz1/pytorch-nested-unet</a></li>
<li>Minaee S , Boykov Y , Porikli F , et al. Image Segmentation Using Deep Learning: A Survey[J]. 2020.</li>
<li>Guo Y , Liu Y , Georgiou T , et al. A review of semantic segmentation using deep neural networks[J]. International Journal of Multimedia Information Retrieval, 2017.</li>
<li><a href="https://github.com/fabioperez/pytorch-examples/">https://github.com/fabioperez/pytorch-examples/</a></li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础知识总结</title>
    <url>/2022/04/21/git%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="git基础知识总结"><a href="#git基础知识总结" class="headerlink" title="git基础知识总结"></a>git基础知识总结</h1><h2 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h2><p>git是目前世界上最先进的<strong>分布式版本控制</strong>系统。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204202246012.png" alt="image-20220420224552899"></p>
<p>上面的一些名词可能有点陌生，解释：</p>
<ul>
<li><strong>Workspace：</strong>工作区，就相当于本地项目目录。</li>
<li><strong>Index&#x2F;Satge：</strong>暂存库。</li>
<li><strong>Repositiry：</strong>仓库区，这里指本地仓库</li>
<li><strong>Remote：</strong>远程仓库，比如Gitee，Github…。</li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>用一个东西，当然第一件事情是下载了，下载在这就不过多说明了，直接去百度<strong>安装教程</strong>吧。</p>
<p>在这也推荐一个：</p>
<p><a href="https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%7B%22request_id%22:%22165046576716780261939238%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=165046576716780261939238&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-115693833.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;utm_term=git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187">git详解</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204202248594.png" alt="image-20220420224840542"></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="配置全局用户名"><a href="#配置全局用户名" class="headerlink" title="配置全局用户名"></a><strong>配置全局用户名</strong></h4><p> <code>git config --global user.name &quot;用户名&quot;</code></p>
<h4 id="配置全局邮箱"><a href="#配置全局邮箱" class="headerlink" title="配置全局邮箱"></a><strong>配置全局邮箱</strong></h4><p><code>git config --global user.email &quot;邮箱&quot;</code></p>
<p><strong>注意：配置了全局，你的所有git仓库都会使用这个配置，不过你也可以对指定某个仓库配置进行修改。</strong></p>
<h4 id="查看git配置"><a href="#查看git配置" class="headerlink" title="查看git配置"></a>查看git配置</h4><p><code>git config -l</code></p>
<h4 id="把你的目录初始化为git可以管理的仓库"><a href="#把你的目录初始化为git可以管理的仓库" class="headerlink" title="把你的目录初始化为git可以管理的仓库"></a>把你的目录初始化为git可以管理的仓库</h4><p><code>git init</code></p>
<p><strong>注意：.git目录不要随便篡改哦</strong></p>
<h4 id="将文件添加到暂存区"><a href="#将文件添加到暂存区" class="headerlink" title="将文件添加到暂存区"></a>将文件添加到暂存区</h4><p> <code>git add 文件</code></p>
<p><strong><code>git add .</code> 相当于把你当前文件夹下的所有内容添加到暂存区</strong></p>
<h4 id="查看暂存区的当前状态"><a href="#查看暂存区的当前状态" class="headerlink" title="查看暂存区的当前状态"></a>查看暂存区的当前状态</h4><p><code>git status</code></p>
<h4 id="将暂存区的文件提交到仓库"><a href="#将暂存区的文件提交到仓库" class="headerlink" title="将暂存区的文件提交到仓库"></a>将暂存区的文件提交到仓库</h4><p> <code>git commit -m ”提交描述“</code></p>
<h4 id="查看暂存区的文件修改内容"><a href="#查看暂存区的文件修改内容" class="headerlink" title="查看暂存区的文件修改内容"></a>查看暂存区的文件修改内容</h4><p><code>git diff 文件名 </code></p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><h4 id="显示最近提交版本日志"><a href="#显示最近提交版本日志" class="headerlink" title="显示最近提交版本日志"></a>显示最近提交版本日志</h4><p><code>git log</code></p>
<h4 id="简化显示日志"><a href="#简化显示日志" class="headerlink" title="简化显示日志"></a>简化显示日志</h4><p><code>git log –pretty=oneline</code></p>
<h4 id="回退到上个版本"><a href="#回退到上个版本" class="headerlink" title="回退到上个版本"></a>回退到上个版本</h4><p><code>git reset --hard HEAD^</code></p>
<h4 id="回退到上上个版本"><a href="#回退到上上个版本" class="headerlink" title="回退到上上个版本"></a>回退到上上个版本</h4><p><code>git reset --head HEAD^^</code></p>
<p><strong>回退几个就加几个^</strong></p>
<h4 id="回退到以前一百个版本"><a href="#回退到以前一百个版本" class="headerlink" title="回退到以前一百个版本"></a>回退到以前一百个版本</h4><p><code>git reset --hard Head~100</code></p>
<h3 id="工作区和暂存区的区别"><a href="#工作区和暂存区的区别" class="headerlink" title="工作区和暂存区的区别"></a>工作区和暂存区的区别</h3><p><strong>工作区</strong>：工作区就是本地电脑上看到的目录。</p>
<p><strong>暂存区</strong>：暂存区在我们git init生成一个git版本控制后，相应的目录下会生成一个.git目录，这个目录就是版本库（Repositiry），版本库中最重要的一个就是暂存区（storage），其中还有git自动创建的第一个分支master以及指向master的一个指针HEAD。</p>
<p><strong>第一步</strong>：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p>
<p><strong>第二步</strong>：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p>
<h3 id="撤销修改和删除文件操作"><a href="#撤销修改和删除文件操作" class="headerlink" title="撤销修改和删除文件操作"></a>撤销修改和删除文件操作</h3><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><h5 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h5><p><code>git checkout --文件名</code></p>
<p><strong>注意：命令git checkout – 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</strong></p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p><code>rm 文件名</code></p>
<h3 id="远程仓库相关"><a href="#远程仓库相关" class="headerlink" title="远程仓库相关"></a>远程仓库相关</h3><h4 id="为本地库添加远程仓库"><a href="#为本地库添加远程仓库" class="headerlink" title="为本地库添加远程仓库"></a>为本地库添加远程仓库</h4><p><code>git remote add origin 远程git仓库地址</code></p>
<h4 id="把本地分支内容推送到远程仓库"><a href="#把本地分支内容推送到远程仓库" class="headerlink" title="把本地分支内容推送到远程仓库"></a>把本地分支内容推送到远程仓库</h4><p><code>git push</code></p>
<p><strong>第一次创建了远程库肯定是空的，第一次推送本地master分支的时候，可以用<code>git push -u origin master</code> 命令，git不但会把本地master分支推送至远程，还会将本地master分支和远程关联起来，之后命令只用<code>git push</code>就自动提交到对应远程库了。</strong></p>
<h4 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a><strong>克隆远程库</strong></h4><p><code>git clone 远程库地址</code></p>
<h3 id="分支问题"><a href="#分支问题" class="headerlink" title="分支问题"></a>分支问题</h3><p><strong>从前面的<code>git log</code>可以看到，git把提交串成了一条时间线，这条时间线就是一个分支。创建git版本库时就默认创建了一个主分支master.HEAD严格来说不是指向提交，而是指向master，即指向分支，而分支才指向提交，所以HEAD指向的就是当前的这个分支。</strong></p>
<p><strong>多个分支并行执行，就会导致我们的代码不冲突，也就是存在多个版本。</strong></p>
<h4 id="创建-切换分支"><a href="#创建-切换分支" class="headerlink" title="创建+切换分支"></a>创建+切换分支</h4><p><code>git checkout -b 分支名</code>,-b相当于创建附带切换到这个分支</p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p> <code>git branch 分支名</code></p>
<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p><code>git checkout 分支名</code></p>
<h4 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h4><p><code>git branch</code></p>
<h4 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h4><p> <code>git branch -r</code></p>
<h4 id="将指定分支合并到当前分支"><a href="#将指定分支合并到当前分支" class="headerlink" title="将指定分支合并到当前分支"></a>将指定分支合并到当前分支</h4><p><code>git merge 指定分支名</code></p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p> <code>git branch -d 分支名</code></p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>你需要先把远程仓库拉到本地<code>git pull</code>，有冲突就解决， 完成合并后在<code>git push</code>。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式组件</title>
    <url>/2022/04/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式组件"><a href="#分布式组件" class="headerlink" title="分布式组件"></a>分布式组件</h1><blockquote>
<p>看到很多帖子，说SpringCloud的eureka停止维护了，开始采用<strong>SpringCloud Alibaba的Nacos</strong>作为注册中心和配置中心，也具有可视化监控界面，非常方便。</p>
</blockquote>
<p><strong><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/README-zh.md">中文文档</a></strong></p>
<h2 id="配置SpringCloud-Alibaba的依赖管理器"><a href="#配置SpringCloud-Alibaba的依赖管理器" class="headerlink" title="配置SpringCloud Alibaba的依赖管理器"></a>配置SpringCloud Alibaba的依赖管理器</h2><p>配置后，SpringCloud Alibaba的组件依赖就不用规定版本了，都交给依赖管理器统一管理。</p>
<p><strong>注意：版本需要跟SpringBoot的版本相互对应，要不会不兼容冲突。</strong><br><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204262109603.png" alt="image-20220426210910567"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.0.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><blockquote>
<p>Nacos 致力于发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>由于兼容性问题，我安装的是<strong>1.1.3</strong>版本的nacos，不会出现启动闪退的情况。</p>
<p><strong>注意：启动Nacos是要使用java环境的，请确定环境变量中添加了JAVA_HOME, %JAVA_HOME%\bin</strong></p>
<p>安装后启动startup程序：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204270954521.png" alt="image-20220426211641045"></p>
<p>会启动nacos服务器，该服务器的是默认在localhost:8848启动的：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204262117610.png" alt="image-20220426211725554"></p>
<p><strong>注意：在Springboot项目启动过程中，Nacos一定要保持在线状态！！</strong></p>
<h3 id="配置-注册中心（nacos-discovery）"><a href="#配置-注册中心（nacos-discovery）" class="headerlink" title="配置 注册中心（nacos-discovery）"></a>配置 注册中心（nacos-discovery）</h3><blockquote>
<p>注册中心，采用注册发现机制，上线一个微服务，就会到注册中心进行注册，注册中心对所有服务统一进行管理。</p>
</blockquote>
<h4 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h4><p>将子工程都需要的依赖导入父工程中，然后子工程依赖父工程，子工程就不用一个个配置相同的依赖了，方便很多。</p>
<p>注意，官网的是boot在2.4以下的依赖，如果是2.6X版本，需要排除ribbon，并且导入loadbalancer依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置nacos注册中心（服务注册发现）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--loadbalancer--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>微服务中，每启动一个服务，都需要注册到注册中心中统一管理，那么在远程调用的时候，就知道哪些服务在线，方便进行相应的调用。</p>
<p>如何让一个应用注册到Nacos呢？其实及其简单，在主程序上加上一个注解@EnableDiscoveryClient就可以解决了！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启了应用服务注册发现功能</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages= &quot;com.gulimall.member.feign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallMemberApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>同时需要在应用配置文件Application.yml中配置相应的服务名，和Nacos服务器地址</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gulimall-member</span>  <span class="string">//名字最好与服务模块名一样，方便管理</span></span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>这样，服务注册发现的配置就差不多配好了，咱们启动相应的服务，并访问<a href="http://localhost:8848/nacos/index.html%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E5%85%A5%E5%88%B0Nacos%E4%B8%BB%E9%A1%B5%EF%BC%8C%E7%99%BB%E5%BD%95%E8%BF%9B%E5%8E%BB%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%9B%B8%E5%BA%94%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%86%EF%BC%9A">http://localhost:8848/nacos/index.html，就可以进入到Nacos主页，登录进去，可以看到相应服务的状态，就可以可视化管理微服务了：</a></p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204270954663.png" alt="image-20220426212315143"></p>
<h3 id="配置-配置中心（nacos-config）"><a href="#配置-配置中心（nacos-config）" class="headerlink" title="配置 配置中心（nacos-config）"></a>配置 配置中心（nacos-config）</h3><blockquote>
<p>以前，如果要更改服务的某个配置，需要下线服务后修改好再重新打包部署上线，单体服务还好，但如果服务集群，那真的是裂开，有没有一种办法能统一管理一种服务的所有配置，并动态更改服务配置，就非常方便。</p>
<p>nacos-config组件，就是一个配置中心，可以将一个服务的配置全部托管至配置中心中管理，就不需要再在服务配置文件中做过多冗余配置了。</p>
</blockquote>
<h4 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h4><p><strong>注意：SpringBoot2.4x之前的只需要导入nacos-config启动器，但是后面的版本还需要导入BootStrap依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bootstrap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>需要添加一个BootStrap.Properties配置文件，这个文件优先级是高于Application.properties的，在其中配置服务名和Nacos地址。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">gulimall-coupon</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure>

<p>传统方式，在Applicaiton.yml中添加配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">coupon：</span></span><br><span class="line">	<span class="string">user：</span></span><br><span class="line">		<span class="string">name：jh</span></span><br><span class="line">		<span class="string">age：20</span></span><br></pre></td></tr></table></figure>

<p>之后通过@value(“${coupon.user.name}”)来获取相应的属性值，现在有了配置中心，所有配置都可以转移到配置中心上管理。</p>
<h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p>观察到本地的配置跟可以跟Nacos配置中心的名字（Data Id）为 应用名.properties 的配置进行绑定。</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204262220175.png"></p>
<p>那么我们在配置中心上添加一个Data Id为 <strong>应用名.properties</strong> 的配置，就可以绑定到相应服务的配置了。</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204262221363.png" alt="image-20220426222151101"></p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204270954176.png" alt="image-20220426222202795"></p>
<p><strong>注意：创建的配置一定是Properties，yml可能出错噢！！</strong></p>
<p>我们就不用在本地配置文件中编写属性配置了，直接交给配置中心统一管理就行了。</p>
<h4 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h4><p>动态更新配置注解。</p>
<p><strong>注意：如果配置中心和当前应用配置文件中都配置了相同的属性项。配置中心优先</strong></p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><blockquote>
<p>用作配置隔离。（一般每个<a href="https://so.csdn.net/so/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&spm=1001.2101.3001.7020">微服务</a>一个命名空间）</p>
</blockquote>
<ul>
<li>默认为public命名空间</li>
<li>可以自定义命名空间</li>
</ul>
<p>一般，一个微服务就对应一个命名空间，方便对不同的服务配置做统一管理。</p>
<h4 id="配置集"><a href="#配置集" class="headerlink" title="配置集"></a>配置集</h4><blockquote>
<p>类似于配置文件名，即Data ID(就是配置的名字加类型)</p>
</blockquote>
<h4 id="配置分组"><a href="#配置分组" class="headerlink" title="配置分组"></a>配置分组</h4><blockquote>
<p>不同配置对应的组别。默认所有的配置集都属于<code>DEFAULT_GROUP</code></p>
</blockquote>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202204270954914.png" alt="image-20220427093659310"></p>
<h4 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h4><blockquote>
<p>往往将所有配置都写在一个配置文件中太过于复杂，且不易于维护，我们可以将整体配置按不同类型拆分成多个小的配置文件，合起来便是整个配置文件。</p>
</blockquote>
<p><em><strong>如何将本地的配置转移到配置中心呢？</strong></em></p>
<p>很简单，只用在bootstrap.properties中添加相应的配置就行了。</p>
<p><strong>注意：所有配置中心的配置都要写在bootstrap.properties中。</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 声明应用名</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">gulimall-coupon</span></span><br><span class="line"><span class="comment"># nacos地址</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 使用对应命名空间号下的配置</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">417a06cb-3f8e-4b49-8010-c9b2684c217f</span></span><br><span class="line"><span class="comment"># 选择对应命名空间下对应组的配置</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 扩展配置文件声明</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="comment"># 确认对应配置文件的组别</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"># 开启自动刷新</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].data-id</span>=<span class="string">mybatis.yml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].data-id</span>=<span class="string">other.yml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>通常，我们采取<strong>每个微服务创建自己的命名空间，使用配置分组来区分环境（dev,test,prod…），同时一个环境的配置又可以通过分类拆分成小的配置文件，方便管理。</strong>但是，在开发过程中，为了方便，配置文件还是先写在本地，等部署完善后，再将配置转移至配置中心管理。</p>
<h2 id="远程调用（Feign"><a href="#远程调用（Feign" class="headerlink" title="远程调用（Feign)"></a>远程调用（Feign)</h2><blockquote>
<p>微服务中肯定存在互相调用，那么如何找到相应的服务并调用其中的接口，就要结合注册中心和Feign组件来完成。</p>
</blockquote>
<h3 id="配置依赖-1"><a href="#配置依赖-1" class="headerlink" title="配置依赖"></a>配置依赖</h3><p>在构建<strong>boot项目时勾选上SpringCloud的OpenFeign</strong>模块，就会导入相应依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置SprigCloud-OpenFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="编写远程调用接口"><a href="#编写远程调用接口" class="headerlink" title="编写远程调用接口"></a>编写远程调用接口</h3><p>不同微服务间通过Feign类来进行关联，编写相应的Feign：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@FeignClient声明此类是一个远程调用接口，参数为对应要调用服务的服务名</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;gulimall-coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CouponFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupon/coupon/member/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">memberCoupons</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对应的服务接口方法"><a href="#对应的服务接口方法" class="headerlink" title="对应的服务接口方法"></a>对应的服务接口方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;coupon/coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CouponController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CouponService couponService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/member/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span>  R <span class="title function_">memberCoupons</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">CouponEntity</span> <span class="variable">couponEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouponEntity</span>();</span><br><span class="line">        couponEntity.setCouponName(<span class="string">&quot;满100减10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> R.ok().put(<span class="string">&quot;coupons&quot;</span>, Arrays.asList(couponEntity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要把要调用服务的接口方法复制到Feign中，代表了想要调用对应服务的接口方法，调用接口的每一个方法都对应调用相应服务的一个接口。</p>
<h3 id="主程序配置"><a href="#主程序配置" class="headerlink" title="主程序配置"></a>主程序配置</h3><p>同时，我们需要应用能够扫描到Feign并加载，在主程序中加上相应的@EnableFeignClients注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启注册发现功能</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//开启远程调用功能，启动应用时，扫描该包下的所有带@FeignClient注解类，这些类就是远程调用的一个个接口。</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages= &quot;com.gulimall.member.feign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallMemberApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>编写一个controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;member/member&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//注入Feign组件</span></span><br><span class="line">    <span class="keyword">private</span> CouponFeignService couponFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupons&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MemberEntity</span> <span class="variable">memberEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemberEntity</span>();</span><br><span class="line">        memberEntity.setNickname(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> couponFeignService.memberCoupons();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">coupons</span> <span class="operator">=</span> r.get(<span class="string">&quot;coupons&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.ok().put(<span class="string">&quot;member&quot;</span>,memberEntity).put(<span class="string">&quot;coupons&quot;</span>,coupons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动两个服务，服务必须都上线，要不肯定不能完成相互调用，上线后，并访问相应接口，可以完成调用相应服务的对应接口。</p>
<h3 id="调用原理"><a href="#调用原理" class="headerlink" title="调用原理"></a>调用原理</h3><p><strong>调用远程调用接口的相应方法 –&gt; 先去注册中心中找相应服务名的服务 –&gt; 在匹配当前接口和调用服务的接口，完成匹配 –&gt; 调用成功</strong>    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>所有的实现都需要在启动Nacos的前提下，没有了Nacos，就都没了。</strong></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>基于SpringSecurity的认证授权</title>
    <url>/2022/05/15/%E5%9F%BA%E4%BA%8ESpringSecurity%E7%9A%84%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于SpringSecurity的认证授权"><a href="#基于SpringSecurity的认证授权" class="headerlink" title="基于SpringSecurity的认证授权"></a>基于SpringSecurity的认证授权</h1><blockquote>
<p>之前学习boot时，粗略的学习了一下<code>Shiro</code>和<code>SpringSecurity</code>，只是会基本的使用，但说到原理，不是很了解，今天刚好给课设添加登录认证授权，系统的学习了一下<code>SpringSecurity</code>的底层原理和定制化配置，确实也是基本掌握了，在此记一笔，方便以后回顾.</p>
</blockquote>
<p>说到<code>SpringSeCurity</code>,相信大家都不陌生，说的高大上，是一个跟<code>Springboot</code>良好集成的<strong>安全框架</strong>，说的易懂一点，其实就是一条<strong>过滤器链</strong>，向我们不用<code>SpringSeCurity</code>的时候，要实现登录认证授权，就需要自己手写过滤器和拦截器了，确实有点麻烦，那么使用<code>SpringSecurity</code>确实方便很多，下面来看看传统认证流程和<code>SpringSecurity</code>的认证流程有些啥区别：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205142147838.png" alt="image-20220514214713055"></p>
<p>可以看到，加了框架，在到达Controller之前，需要经过一条过滤器链，这条过滤器链，就是咱们安全的保障，能够最后经过这条链路的，都是”勇士”，传统的认证，咱们可以到达Controller，Controller调用Service层，去数据库通过用户名查询用户全部的信息，然后将用户的密码和请求体中的密码进行比较：</p>
<ul>
<li>若不一致，就返回”用户名或密码错误”的信息.</li>
<li>若一致， 就将用户存入session返回sessionId，或者基于userId生成token令牌返回给前端，后序持久到redis中，代表用户登录了。</li>
</ul>
<p><em><strong>这么一听，确实，也可以实现，但为什么还要使用SpringSecurity呢对吧？</strong></em></p>
<p><strong>框架</strong>，就强在它的完整性，它提供了一整套完整的认证授权流程，我们只需要在这个流程基础上，添加上少许自定义配置就可以实现严格的认证授权功能。</p>
<p><em><strong>说了这么多，下面正式进入正题了，咱们就是要用<code>SpringSecurity</code>实现认证授权，那么认证和授权到底是什么呢？</strong></em></p>
<ul>
<li><strong>认证：</strong>就是确定到底你是哪个用户，也就是登录的作用，登录就是为了确定你所扮演的角色。</li>
<li><strong>授权</strong>：确定了你是哪个用户后，那么就需要不同角色授予不同的权限，比如：管理员（登录认证为是管理员）具有管理后台的权限，而普通用户就没用该权限。</li>
</ul>
<p>做了那么多铺垫，下面就正式来揭开SpringSecurity的真面目：</p>
<h2 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h2><blockquote>
<p>就是在到达<code>Controller</code>之前的一条<strong>过滤器链</strong>，其中完成了用户<strong>认证和授权</strong>。</p>
</blockquote>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205142203197.png" alt="image-20220514220329142"></p>
<ul>
<li>**<code>UsernamePasswordAuthenticationFilter</code> **：负责处理我们登录页填写了用户名密码后的登录请求。</li>
<li>**<code>ExceptionTranslationFilter</code>**：处理过滤器中抛出的任何<code>AccessDeniedException</code>（权限异常）和<code>AuthenticationException</code>（认证异常）。</li>
<li>**<code>FilterSecurityInterceptor</code>**：负责权限校验的过滤器。</li>
</ul>
<p>其他的过滤器就不过多的说明了，主要我们使用需要接触到这三个过滤器。</p>
<h2 id="FilterChainProxy"><a href="#FilterChainProxy" class="headerlink" title="FilterChainProxy"></a>FilterChainProxy</h2><p>SpringSecurity添加了一个FilterChainProxy，这个代理过滤器会创建一套自定义的过滤器链，然后执行这一套过滤器链，也就是生成了上面图中的一整条过滤链路，我们来大致看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">                     FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    ...省略其他代码</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Spring Security的一套过滤器</span></span><br><span class="line">    List&lt;Filter&gt; filters = getFilters(request);</span><br><span class="line">    <span class="comment">// 将这一套过滤器组成Spring Security自己的过滤链，并开始执行</span></span><br><span class="line">    <span class="type">VirtualFilterChain</span> <span class="variable">vfc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualFilterChain</span>(fwRequest, chain, filters);</span><br><span class="line">    vfc.doFilter(request, response);</span><br><span class="line">    </span><br><span class="line">    ...省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dubug看看到底SpringSecurity启动了多少条过滤器：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205142213181.png" alt="image-20220514221306105"></p>
<p>看的让人头皮发麻，不要怕，让我们继续往下学！全部的精髓都在这一条的过滤器中，掌握了这条过滤器链和其中调用了的一些组件，等于你也就掌握了SpringSecurity。</p>
<h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><blockquote>
<p>只需要导入SpringSecurity的启动器就行。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入该依赖后，你再启动程序，会发现啥接口都访问不了了，因为被SpringSecurity保护了，没用自定义配置之前，啥接口都会被拦截掉，相反的会跳转到一个login页面，你需要提供<strong>账号</strong>（默认为user）和<strong>密码</strong>（启动项目时控制台会输出一串字符），登陆后才能访问到相应接口。</p>
<p>实际开发中，显然默认配置是不满足我们的需求的，我们就需要自定义一些配置。</p>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><blockquote>
<p>很简单，只需要添加一个配置类.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="comment">//标记该注解，会注入ioc容器，并指定该类为SpringSecurity配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;&#125;</span><br><span class="line"><span class="comment">//该类需要继承WebSecurityConfigurerAdapter，重写其中的一些方法来自定义</span></span><br></pre></td></tr></table></figure>

<h3 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h3><blockquote>
<p>不管运用什么框架完成登录认证，思想是不变的。</p>
</blockquote>
<p>如何判断当前是哪个用户正在使用咱们的系统就是登录认证的<strong>最终目的</strong>。如果不知道是哪个用户，A下了订单，结果要B来付钱，岂不是很尴尬。判断当前的用户在**<code>SpringSecurity</code><strong>的实现就是</strong><code>Authentication</code>**，它其实就是用户的一种封装，其中包含用户信息和权限信息。</p>
<p>在我们的程序中，需要通过**<code>SecurityContext</code><strong>类（上下文对象）来获取到当前的</strong><code>Authentication</code>**。</p>
<blockquote>
<p>这种在一个线程中，横跨若干个方法，但每个方法中都需要使用和传递的对象，就称为<strong>上下文（context）</strong>，上下文对象很有必要，要不你需要每个方法都加一个参数来提供这个对象。</p>
</blockquote>
<p>而这个上下文对象交给**<code>SecurityContextHolder</code>**来管理，可以通过它来获得上下文对象，进而获得咱们的用户认证信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br></pre></td></tr></table></figure>

<p><strong>调用链路：SecurityContextHolder—&gt;SecurityContext—&gt;Authentication</strong></p>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>📝<code>Authentication</code>：存储了认证信息，代表当前登录用户</p>
<p>📝<code>SeucirtyContext</code>：上下文对象，用来获取<code>Authentication</code></p>
<p>📝<code>SecurityContextHolder</code>：上下文管理对象，用来在程序任何地方获取<code>SecurityContext</code>（类似于ThreadLocal）</p>
<p>他们仨的关系是这样的：<img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205142233669.png" alt="image-20220514223327577"></p>
<h4 id="认证逻辑"><a href="#认证逻辑" class="headerlink" title="认证逻辑"></a>认证逻辑</h4><p>之前没用框架的逻辑是这样的：查询用户数据–&gt;判断是否正确–&gt;正确就将用户信息储存在上下文中表示用户登录了.</p>
<p>用了框架也一样，只不过是将用户（Authentication）放入上下文（SeucirtyContext）就能完成认证了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(用户名，用户密码，用户的权限集合);</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authentication);</span><br></pre></td></tr></table></figure>

<p>这时认证完成后，后面的过滤器链都可以通过获得这个<strong>authentication</strong>来进行针对性的操作，比如授权等，所以认证过滤器通常是放在过滤器第一位的，要不后面过滤器连**<code>authentication</code>**也就是用户都不知道，拿屁操作。</p>
<p>那么，我们需要判断这个登录用户是否合法后才能放入上下文，就需要有一个判断流程，这个流程跟不加框架是一样的，都是可以操作调用Service层处理，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginParam param)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(userService.login(账号,密码))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;账号或密码错误&quot;</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">// 生成一个包含账号密码的认证信息</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(param.getUsername(), param.getPassword());</span><br><span class="line">        <span class="comment">// 将返回的Authentication存到上下文中</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等于说Service完成了所有判断，但SpringSecurity中也有相应的<strong>判断组件</strong>供我们使用，更加方便。</p>
<p>如果我们不做操作，会经过**<code>UsernamePasswordAuthenticationFilter</code>**来判断用户名和密码，但是如果是调用它的，就跟刚开始说的，是判断框架自带的账号密码，并不是我们数据库查出来的，没啥用，我们可以参考一下这个过滤器中的源码写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainUsername(request);</span><br><span class="line">        username = username != <span class="literal">null</span> ? username : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        username = username.trim();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainPassword(request);</span><br><span class="line">        password = password != <span class="literal">null</span> ? password : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line">        <span class="built_in">this</span>.setDetails(request, authRequest);</span><br><span class="line">        <span class="comment">//这个是关键：调用了AuthenticationManager其中的authenticate方法完成判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，咱们自己写，也可以来通过AuthenticationManager其中的authenticate方法来完成判断。</p>
<h4 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h4><p>要使用AuthenticationManager，我们先在ioc中添加AuthenticationManager组件.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.antMatchers(<span class="string">&quot;/login&quot;</span>).permitAll() <span class="comment">//表示所有人可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：我们需要对登录接口”&#x2F;login”放行才行，要不就会经过”残酷”的过滤器链，包括<code>UsernamePasswordAuthenticationFilter</code>，那么自定义登录认证也就失去意义了哦！！</strong></p>
<p>接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginParam param)</span> &#123;</span><br><span class="line">        <span class="comment">// 生成一个包含账号密码的认证信息</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(param.getUsername(), param.getPassword());</span><br><span class="line">        <span class="comment">// AuthenticationManager校验这个认证信息，返回一个已认证的Authentication</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> authenticationManager.authenticate(authentication);</span><br><span class="line">        <span class="comment">// 将返回的Authentication存到上下文中</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是思路清晰了很多，**<code>AuthenticationManager</code><strong>完成了之前</strong><code>userService</code>**的业务操作。</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>根据<strong>用户名</strong>先查询出<strong>用户对象</strong>(没有查到则抛出异常)👉将用户对象的密码和传递过来的密码进行校验，密码不匹配则抛出异常</p>
<p>这个逻辑没啥好说的，再简单不过了。<strong>重点是这里每一个步骤Spring Security都提供了组件</strong>：</p>
<p>📝是谁执行 <strong>根据用户名查询出用户对象</strong> 逻辑的呢？用户对象数据可以存在内存中、文件中、数据库中，你得确定好怎么查才行。这一部分就是交由<strong>💡<code>UserDetialsService</code></strong> 处理，该接口只有一个方法<code>loadUserByUsername(String username)</code>，通过用户名查询用户对象，默认实现是在内存中查询。</p>
<p>📝那查询出来的 <strong>用户对象</strong> 又是什么呢？每个系统中的用户对象数据都不尽相同，咱们需要确认我们的用户数据是啥样的才行。Spring Security中的用户数据则是由<strong>💡<code>UserDetails</code></strong> 来体现，该接口中提供了账号、密码等通用属性。</p>
<p>📝<strong>对密码进行校验</strong>大家可能会觉得比较简单，<code>if、else</code>搞定，就没必要用什么组件了吧？但框架毕竟是框架考虑的比较周全，除了<code>if、else</code>外还解决了密码加密的问题，这个组件就是**💡<code>PasswordEncoder</code>**，负责密码加密与校验。</p>
<p>我们可以看下<code>AuthenticationManager</code>校验逻辑的大概源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    ...省略其他代码</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递过来的用户名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">    <span class="comment">// 调用UserDetailService的方法，通过用户名查询出用户对象UserDetail（查询不出来UserDetailService则会抛出异常）</span></span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">    <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 传递过来的密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">    <span class="comment">// 使用密码解析器PasswordEncoder传递过来的密码是否和真实的用户密码匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!passwordEncoder.matches(password, userDetails.getPassword())) &#123;</span><br><span class="line">        <span class="comment">// 密码错误则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;错误信息...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意哦，这里返回的已认证Authentication，是将整个UserDetails放进去充当Principal</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(userDetails,</span><br><span class="line">				authentication.getCredentials(), userDetails.getAuthorities());</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    ...省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>流程：UserDetialsService--&gt;UserDetails---&gt;PasswordEncoder。</code></strong></p>
<h6 id="UserDetials"><a href="#UserDetials" class="headerlink" title="UserDetials"></a>UserDetials</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="comment">//权限等级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="comment">//用户信息</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">    <span class="comment">//权限集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permission;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(UserInfo userInfo,List&lt;String&gt; permission)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userInfo = userInfo;</span><br><span class="line">        <span class="built_in">this</span>.permission = permission;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="built_in">this</span>.permission) &#123;</span><br><span class="line">            authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userInfo.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userInfo.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="UserDetialsService"><a href="#UserDetialsService" class="headerlink" title="UserDetialsService"></a>UserDetialsService</h6><blockquote>
<p>业务实现这个接口，重写其中的<code>loadUserByUsername</code>方法即可。这个方法就执行根据用户名到数据库中查找相应用户，并封装成UserDetails类返回的操作.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>, UserDetailsService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过用户名 查找用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">findUserByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(username)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请输入用户名!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LambdaQueryWrapper&lt;UserInfo&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(UserInfo::getUsername, username);</span><br><span class="line">        wrapper.last(<span class="string">&quot;limit 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(userInfo)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户们不存在!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写UserDetailService的方法来自定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.findUserByUsername(s);</span><br><span class="line">        <span class="keyword">if</span>(user.getLevel() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//1:管理员，具有&quot;user&quot;, &quot;admin&quot;权限。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;admin&quot;</span>)));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2：用户</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;user&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h6><blockquote>
<p>可以看到**<code>authenticate</code>**方法中使用了密码加密校验，但是框架自带的是{noop}明文校验，明文校验并不安全，所以我们可以配置一下自己的校验器。在开始的配置文件中添加一个加密器到容器中即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><blockquote>
<p>说完了认证，授权其实就简单了，只是在**<code>Authentication</code>**类中多添加一个用户的权限集合就行了.也可以通过注解实现，但我并不推荐，注解在后序的维护中及其困难。</p>
</blockquote>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205142348682.png" alt="image-20220514234823604"></p>
<p>最主要的是，这些权限有啥用，肯定是不同权限能够访问不同的资源撒，那么我们需要在配置类中配置对应的权限能够访问哪些接口，接口就是对应的资源了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.csrf().disable()    <span class="comment">//关闭csrf防止跨域攻击</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/error&quot;</span>,<span class="string">&quot;/auth&quot;</span>, <span class="string">&quot;/comment/getAll&quot;</span>, <span class="string">&quot;/foodCategory/**&quot;</span>, <span class="string">&quot;/foodMaterial/**&quot;</span>, <span class="string">&quot;/introduce/**&quot;</span>, <span class="string">&quot;/mainPage/**&quot;</span>).permitAll() <span class="comment">//表示所有人都可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/end/**&quot;</span>).hasAuthority(<span class="string">&quot;admin&quot;</span>)  <span class="comment">//表示只有具有&quot;admin&quot;权限才能访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/comment/&quot;</span>, <span class="string">&quot;/foodCollect&quot;</span>, <span class="string">&quot;/logout&quot;</span>, <span class="string">&quot;/user/**&quot;</span>, <span class="string">&quot;/update&quot;</span>).authenticated() <span class="comment">//表示需要登录认证才能访问</span></span><br><span class="line">                .and()</span><br><span class="line">                .cors();   <span class="comment">//允许跨域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异常自定义处理"><a href="#异常自定义处理" class="headerlink" title="异常自定义处理"></a>异常自定义处理</h3><blockquote>
<p>如果你自己实战过，可以发现，添加了框架后，认证授权会报很多你之前没有见过的异常，这些是SpringSecurity自定义的异常，由其中的一个过滤器**<code>ExceptionTranslationFilter</code>**处理。</p>
</blockquote>
<p>如果我们不自定义异常处理，那么返回给用户的消息就是这样的：</p>
<p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205142335222.png" alt="image-20220514233519173"></p>
<p>这违背了我们统一消息体返回的原则，那么我们需要自定义配置异常处理:</p>
<p>异常分为认证异常，授权异常，有相应的处理器:</p>
<p><strong>AuthenticationEntryPoint</strong></p>
<blockquote>
<p>认证异常处理器,是一个接口，咱们自定义认证异常处理需要实现这个接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        httpServletResponse.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        httpServletResponse.getWriter().print(JSONUtil.toJsonStr(Result.fail(ResultCode.NOT_ACCESS.getCode(), ResultCode.NOT_ACCESS.getMsg())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AccessDeniedHandler</strong></p>
<blockquote>
<p>授权认证处理器,也是一个接口，自定义授权异常处理需要实现这个接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthorizationHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        httpServletResponse.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        httpServletResponse.getWriter().print(JSONUtil.toJsonStr(Result.fail(ResultCode.NOT_AUTH.getCode(), ResultCode.NOT_AUTH.getMsg())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：<code>ResultCode</code>是自定义的返回类哈，需要自己写emmm</strong></p>
<p>编写了自己的配置，还需要添加到SpringSecurity的配置中去:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyAuthorizationHandler myAuthorizationHandler;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authenticationEntryPoint(myAuthenticationEntryPoint)</span><br><span class="line">             .accessDeniedHandler(myAuthorizationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么之后出现了认证或者授权异常，都会进入我们的异常处理类中进行相应处理.</p>
<h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><blockquote>
<p>前后端分离，通常使用JWT来认证，那么用户登录后，返回的token，之后的请求都需要在请求头中添加token，以便于后端验证。</p>
</blockquote>
<p><em>那么问题是，之前咱们的过滤器都是针对登录认证的，没有应对登录后用户请求的过滤器，无法处理请求中的token，若不处理，进入到<code>UsernamePasswordAuthenticationFilter</code>，又会使用框架自带的账号密码来过滤，就很尴尬，那么怎么办呢？</em></p>
<p>自定义一个过滤器不就行了嘛,用来专门验证请求的token，如果token合法，就生成**<code>Authentication</code><strong>存入上下文对象中，这样，后面的过滤器调用上下文中的</strong><code>Authentication</code>**，就会知道该用户已经认证过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="comment">//放行，后面会报错</span></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> userService.findUserByToken(token);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(userInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//放行，后面会报错</span></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//配置到上下文中</span></span><br><span class="line">        <span class="comment">//授权</span></span><br><span class="line">        LoginUser loginUser;</span><br><span class="line">        Authentication authentication;</span><br><span class="line">        <span class="keyword">if</span>(userInfo.getLevel() == <span class="number">1</span>) &#123;</span><br><span class="line">            loginUser = <span class="keyword">new</span> <span class="title class_">LoginUser</span>(userInfo,<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>)));</span><br><span class="line">            authentication = <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">            System.out.println(loginUser.getAuthorities());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            loginUser = <span class="keyword">new</span> <span class="title class_">LoginUser</span>(userInfo,<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;user&quot;</span>)));</span><br><span class="line">            authentication = <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个过滤器配置到过滤器链中去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JWTAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放在**<code>UsernamePasswordAuthenticationFilter</code><strong>过滤之前，替代了默认的认证过滤器。登陆后的用户访问其他接口时，就会带上</strong>token**进入到我们自定义的认证过滤器中验证了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://jhblog-image.oss-cn-chengdu.aliyuncs.com/blogImg/202205150023834.png" alt="image-20220515002354734"></p>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件开发</title>
    <url>/2022/02/26/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="html中使用Vue组件"><a href="#html中使用Vue组件" class="headerlink" title="html中使用Vue组件"></a>html中使用Vue组件</h2><h3 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h3><p>组件化是Vue.js中的重要思想它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。任何的应用都会被抽象成一颗组件树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">&#x27;#cpn&#x27;</span>,<span class="comment">//1.模板属性 - 定义HTML结构</span></span><br><span class="line">    data() &#123;         <span class="comment">//2.data属性 - 定义HTML数据  </span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        title: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src="资料/组件化开发原理.jpg">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">组件化图 </div>
</center>  

<p>组件化思想的应用：</p>
<ol>
<li>有了组件化的思想，我们在之后的开发中就要充分的利用它。</li>
<li>尽可能的将页面拆分成一个个小的、可复用的组件。</li>
<li>这样让我们的代码更加方便组织和管理，并且扩展性也更强。</li>
</ol>
<h3 id="组件开发流程"><a href="#组件开发流程" class="headerlink" title="组件开发流程"></a>组件开发流程</h3><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src="资料/组件使用步骤.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">组件开发流程 </div>
</center>


<h4 id="1-Vue-extend-："><a href="#1-Vue-extend-：" class="headerlink" title="1.Vue.extend()："></a><font color=ff00aa>1.Vue.extend()：</font></h4><p>调用Vue.extend()创建的是一个组件构造器。<br>通常在创建组件构造器时，传入template代表我们自定义组件的模板。<br>该模板就是在使用到组件的地方，要显示的HTML代码。<br>事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础。</p>
<h4 id="2-Vue-component-："><a href="#2-Vue-component-：" class="headerlink" title="2.Vue.component()："></a><font color=ff00aa>2.Vue.component()：</font></h4><p>调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。所以需要传递两个参数：1、注册组件的标签名 2、组件构造器</p>
<p>组件必须挂载在某个Vue实例下，否则它不会生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;!--<span class="number">3.</span>使用组件--&gt;</span><br><span class="line">  &lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line">  &lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--必须在vue托管实例下才生效--&gt;</span><br><span class="line">&lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 1.创建组件构造器对象</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">cpnC</span> <span class="operator">=</span> Vue.extend(&#123;</span><br><span class="line">    template: `</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;`</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.注册组件</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;my-cpn&#x27;</span>, cpnC)</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--app2下不能使用cpn组件--&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;app2&quot;</span>&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 1.创建组件构造器</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">cpnC</span> <span class="operator">=</span> Vue.extend(&#123;</span><br><span class="line">    template: `</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;我是内容,哈哈哈哈啊&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.注册组件(全局组件)</span></span><br><span class="line">  <span class="comment">// Vue.component(&#x27;cpn&#x27;, cpnC)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      <span class="comment">// 局部组件</span></span><br><span class="line">      <span class="comment">// 在components中声明组件时，为该vue实例托管HTML下使用</span></span><br><span class="line">      cpn: cpnC</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="comment">// 测试，cpnC在该vue实例下不能使用</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">app2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app2&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;cpn2&gt;&lt;/cpn2&gt;</span><br><span class="line">  &lt;!--&lt;cpn1&gt;&lt;/cpn1&gt;--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 1.创建第一个组件构造器(子组件)</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">cpnC1</span> <span class="operator">=</span> Vue.extend(&#123;</span><br><span class="line">    template: `</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是标题<span class="number">1</span>&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建第二个组件构造器(父组件) 父组件中使用components声明</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">cpnC2</span> <span class="operator">=</span> Vue.extend(&#123;</span><br><span class="line">    template: `</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是标题<span class="number">2</span>&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt;</span><br><span class="line">        &lt;cpn1&gt;&lt;/cpn1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    `,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn1: cpnC1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// root组件</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn2: cpnC2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件语法糖"><a href="#组件语法糖" class="headerlink" title="组件语法糖"></a><font color=ff00aa>组件语法糖</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.注册全局组件语法糖</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;cpn1&#x27;</span>, &#123;</span><br><span class="line">    template: `</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是标题<span class="number">1</span>&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.注册局部组件的语法糖</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      <span class="string">&#x27;cpn2&#x27;</span>: &#123;</span><br><span class="line">        template: `</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;我是标题<span class="number">2</span>&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;我是内容, 呵呵呵&lt;/p&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件模板分离写法"><a href="#组件模板分离写法" class="headerlink" title="组件模板分离写法"></a><font color=ff00aa>组件模板分离写法</font></h4><p>如果以后开发中势必会有很多的模板，这样直接会导致js中存在过多的HTML模板代码。因此最好在HTML代码中能够书写模板代码。方别日后的维护。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--方式一：<span class="number">1.</span>script标签, 注意:类型必须是text/x-template--&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/x-template&quot;</span> id=<span class="string">&quot;cpn1&quot;</span>&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">  &lt;p&gt;我是内容,哈哈哈&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--方式二：<span class="number">2.</span>template标签--&gt;</span><br><span class="line">&lt;template id=<span class="string">&quot;cpn2&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是内容,呵呵呵&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.注册一个全局组件</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">&#x27;#cpn2&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件数据存放"><a href="#组件数据存放" class="headerlink" title="组件数据存放"></a><font color=ff00aa>组件数据存放</font></h4><p>组件是一个单独功能模块的封装：这个模块有属于自己的HTML模板，也应该有属性自己的数据data。</p>
<blockquote>
<p>组件中模板并不可以使用vue实例中的数据。相对于vue实例：组件是个单独的个体。组件的数据和模板都是私有的。类似于Java类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;title&#125;&#125;  &#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是内容,呵呵呵&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.注册一个全局组件</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        title: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">        name:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span><br><span class="line">      <span class="comment">// title: &#x27;我是标题&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h4 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a><font color=ff00aa>父子组件通信</font></h4><p>上面说过子组件是不能引用父组件或者Vue实例的数据的。但是，在开发中，往往一些数据确实需要从上层传递到下层：</p>
<blockquote>
<p>比如在一个页面中，我们从服务器请求到了很多的数据。其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件(父组件)将数据传递给小组件(子组件)。</p>
</blockquote>
<p>如何进行父子组件间的通信呢？Vue官方提到</p>
<ol>
<li>通过props向子组件传递数据  : 父传子</li>
<li>通过事件向父组件发送消息    : 子传父</li>
</ol>
<p>在组件中，使用选项props来声明需要从父级接收到的数据。props的值有两种方式：</p>
<p>方式一：字符串数组，数组中的字符串就是传递时的名称。<br>方式二：对象，对象可以设置传递时的类型，也可以设置默认值等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;!--<span class="number">2.</span> 在vue实例或父组件HTML中使用子组件模板并传递数据--&gt;</span><br><span class="line">  &lt;cpn :cmessage=<span class="string">&quot;message&quot;</span> :cmovies=<span class="string">&quot;movies&quot;</span> :cbooks=<span class="string">&quot;books&quot;</span>&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="number">3.</span> 在子组件模板中使用vue实例数据--&gt;</span><br><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;item in cmovies&quot;</span>&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;cbooks.name&#125;&#125;  &#123;&#123;cbooks.price&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//父组件请求整个页面需要的网络数据 父传子: props</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">cpn</span> <span class="operator">=</span> &#123;</span><br><span class="line">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">    <span class="comment">//1. 在子组件中声明props属性。</span></span><br><span class="line">    <span class="comment">// props: [&#x27;cmovies&#x27;, &#x27;cmessage&#x27;],</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      <span class="comment">// 类型限制</span></span><br><span class="line">      <span class="comment">// cmovies: Array,</span></span><br><span class="line">      <span class="comment">// cmessage: String,</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 提供一些默认值, 以及必传值</span></span><br><span class="line">      cmessage: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&#x27;aaaaaaaa&#x27;</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 类型是对象或者数组时, 默认值必须是一个函数</span></span><br><span class="line">      cmovies: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        <span class="keyword">default</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      cbooks: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        <span class="keyword">default</span>:function () &#123;</span><br><span class="line">          <span class="keyword">return</span>&#123;mess:<span class="string">&#x27;hello vue&#x27;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span><br><span class="line">      movies: [<span class="string">&#x27;海王&#x27;</span>, <span class="string">&#x27;海贼王&#x27;</span>, <span class="string">&#x27;海尔兄弟&#x27;</span>],</span><br><span class="line">      books:&#123;</span><br><span class="line">        name:<span class="string">&#x27;Java从入门到放弃&#x27;</span>,</span><br><span class="line">        price:<span class="string">&#x27;78.5&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</p>
<blockquote>
<p>为何使用插槽？</p>
</blockquote>
<p>插槽的目的是让我们原来的设备具备更多的扩展性。</p>
<blockquote>
<p>组件的插槽：</p>
</blockquote>
<p>移动开发中，几乎每个页面都有导航栏。导航栏我们必然会封装成一个插件，比如nav-bar组件。一旦有了这个组件，我们就可以在多个页面中复用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line"><span class="number">1.</span>插槽的基本使用 &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line"><span class="number">2.</span>插槽的默认值 &lt;slot&gt;button&lt;/slot&gt;</span><br><span class="line"><span class="number">3.</span>如果有多个值, 同时放入到组件进行替换时, 一起作为替换元素</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;!-- <span class="number">2.</span> 组件显示 默认插槽--&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--<span class="number">3.</span> 调用插槽时  插入内容代替solt--&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;/cpn&gt;</span><br><span class="line"></span><br><span class="line">  &lt;cpn&gt;&lt;i&gt;呵呵呵&lt;/i&gt;&lt;/cpn&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--<span class="number">4.</span> 一个插槽对应多个插入内容时，则一块显示--&gt;</span><br><span class="line">  &lt;cpn&gt;</span><br><span class="line">    &lt;i&gt;呵呵呵&lt;/i&gt;</span><br><span class="line">    &lt;div&gt;我是div元素&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;我是p元素&lt;/p&gt;</span><br><span class="line">  &lt;/cpn&gt;</span><br><span class="line"></span><br><span class="line">  &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--<span class="number">1.</span> 在模板中定义插槽 具体内容看调用方如何插入--&gt;</span><br><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是组件&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是组件, 哈哈哈&lt;/p&gt;</span><br><span class="line">    &lt;slot&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;!--&lt;button&gt;按钮&lt;/button&gt;--&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line">        template: <span class="string">&#x27;#cpn&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h4 id="具名插槽slot"><a href="#具名插槽slot" class="headerlink" title="具名插槽slot"></a>具名插槽slot</h4><p>上述讲过，如果单个插槽对应多个插入内容则一起显示，而如果要多个插入内容和多个插槽一一对应则需要使用具名插槽。</p>
<blockquote>
<p>只要给slot元素一个name属性即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--<span class="number">2.</span> --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;span slot=<span class="string">&quot;center&quot;</span>&gt;标题&lt;/span&gt;&lt;/cpn&gt;</span><br><span class="line">  &lt;cpn&gt;&lt;button slot=<span class="string">&quot;left&quot;</span>&gt;返回&lt;/button&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--<span class="number">1.</span> name属性--&gt;</span><br><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot name=<span class="string">&quot;left&quot;</span>&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=<span class="string">&quot;center&quot;</span>&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=<span class="string">&quot;right&quot;</span>&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line">        template: <span class="string">&#x27;#cpn&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>正常插槽使用都是由父组件提供内容插入子组件中。而如果有种情况是：父组件插入的数据是子组件内容又该如何？作用域插槽可以解决此问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;cpn v-show=<span class="string">&quot;isShow&quot;</span>&gt;&lt;/cpn&gt;</span><br><span class="line">  &lt;cpn v-<span class="keyword">for</span>=<span class="string">&quot;item in names&quot;</span>&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是子组件&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是内容, 哈哈哈&lt;/p&gt;</span><br><span class="line">    &lt;!--<span class="number">2.</span> 依赖子组件中数据--&gt;</span><br><span class="line">    &lt;button v-show=<span class="string">&quot;isShow&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span><br><span class="line">      isShow: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line">        <span class="comment">//1. 子组件中提供数据</span></span><br><span class="line">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">        data() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            isShow: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<h2 id="纯Vue项目开发"><a href="#纯Vue项目开发" class="headerlink" title="纯Vue项目开发"></a>纯Vue项目开发</h2><blockquote>
<p>为什么要分<code>HTML中vue组件</code>和<code>纯Vue项目开发</code>呢。由于之前学习的时候老师是HTML中穿插vue.js使用的。因此笔记都是HTML中使用vue.js内容。HTML中穿插vue.js属于过度阶段。现在主流都是纯vue项目，当然也会穿插js。哈哈~ 因此日后会逐步加入<code>纯Vue项目中组件化开发</code></p>
</blockquote>
<ul>
<li>HTML项目中是由HTML作为页面展现内容。Vue项目中是以vue component作为页面展现。</li>
</ul>
<h3 id="组件之间调用"><a href="#组件之间调用" class="headerlink" title="组件之间调用"></a>组件之间调用</h3><p>被调用方</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>: <span class="string">&quot;testComponent&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>调用方</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 3.在template中就可以直接使用了 --&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">testComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">testComponent</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//1.先使用import导入你要在该组件中使用的子组件  </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">import</span> testComponent <span class="keyword">from</span> <span class="string">&#x27;./testComponent.vue&#x27;</span>  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//2.然后,在components中写入子组件  </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">components</span>: &#123;testComponent&#125;,  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>: &#123;&#125;,  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>



<h3 id="组件之间调用数据"><a href="#组件之间调用数据" class="headerlink" title="组件之间调用数据"></a>组件之间调用数据</h3><p>被调用方</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    testComponent</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>: <span class="string">&quot;testComponent&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>调用方</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">testComponent</span> <span class="attr">ref</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">testComponent</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">import</span> testComponent <span class="keyword">from</span> <span class="string">&#x27;./testComponent.vue&#x27;</span>  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">components</span>: &#123;testComponent&#125;,  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>: &#123;&#125;, </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      	<span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//修改data为newData</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          	<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">test</span>.<span class="property">data</span>=<span class="string">&#x27;newData&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven常用依赖配置</title>
    <url>/2022/02/10/%E5%B8%B8%E7%94%A8%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Maven常用依赖配置"><a href="#Maven常用依赖配置" class="headerlink" title="Maven常用依赖配置"></a>Maven常用依赖配置</h1><h2 id="Thymleaf"><a href="#Thymleaf" class="headerlink" title="Thymleaf"></a>Thymleaf</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="1-maven依赖配置"><a href="#1-maven依赖配置" class="headerlink" title="1.maven依赖配置"></a>1.maven依赖配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//Pom.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-mapper-xml配置（https-mybatis-org-mybatis-3-getting-started-html）"><a href="#2-mapper-xml配置（https-mybatis-org-mybatis-3-getting-started-html）" class="headerlink" title="2.mapper.xml配置（https://mybatis.org/mybatis-3/getting-started.html）"></a>2.mapper.xml配置（<a href="https://mybatis.org/mybatis-3/getting-started.html%EF%BC%89">https://mybatis.org/mybatis-3/getting-started.html）</a></h3><h4 id="namespace需要改成自己的"><a href="#namespace需要改成自己的" class="headerlink" title="namespace需要改成自己的"></a>namespace需要改成自己的</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-application-yml"><a href="#3-application-yml" class="headerlink" title="3.application.yml"></a>3.application.yml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">//配置你的实体类路径</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">配置你的mapper的xml文件路径</span></span><br></pre></td></tr></table></figure>

<h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h2><p>maven依赖配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">配置你的mapper的xml文件路径</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">配置你的实体类路径</span></span><br><span class="line"><span class="comment">#  动将下划线格式的表字段，转换为以驼峰格式命名的属性</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h3 id="1-maven依赖配置-1"><a href="#1-maven依赖配置-1" class="headerlink" title="1.maven依赖配置"></a>1.maven依赖配置</h3><h4 id="注意：Swagger最新版和springboot-Starter最新版不兼容的问题"><a href="#注意：Swagger最新版和springboot-Starter最新版不兼容的问题" class="headerlink" title="注意：Swagger最新版和springboot-Starter最新版不兼容的问题"></a>注意：Swagger最新版和springboot-Starter最新版不兼容的问题</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要降低sterter的版本才能兼容Swagger --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-自定义SwaggerConfig"><a href="#2-自定义SwaggerConfig" class="headerlink" title="2.自定义SwaggerConfig"></a>2.自定义SwaggerConfig</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2 //开启Swagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mail"><a href="#Mail" class="headerlink" title="Mail"></a>Mail</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Shiro-1"><a href="#Shiro-1" class="headerlink" title="Shiro"></a>Shiro</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Shiro-Redis"><a href="#Shiro-Redis" class="headerlink" title="Shiro-Redis"></a>Shiro-Redis</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.crazycake<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-redis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Jwt"><a href="#Jwt" class="headerlink" title="Jwt"></a>Jwt</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.auth0/java-jwt --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.18.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SpringSession-Redis"><a href="#SpringSession-Redis" class="headerlink" title="SpringSession-Redis"></a>SpringSession-Redis</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
</search>
